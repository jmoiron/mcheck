package main

// Code generated by peg grammar.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleStart
	ruleStatement
	ruleUseStmt
	ruleUsePath
	ruleTypeAlias
	ruleStructDef
	ruleFieldList
	ruleField
	ruleFieldName
	ruleEnumDef
	ruleEnumValueList
	ruleEnumValue
	ruleDispatchStmt
	ruleDispatchPath
	ruleDispatchTarget
	ruleSpreadStruct
	ruleType
	ruleUnionType
	ruleArrayType
	ruleStructType
	rulePrimitiveType
	ruleReferenceType
	ruleLiteralType
	ruleArrayConstraint
	ruleRange
	ruleAttribute
	ruleAttributeList
	ruleAttributePair
	ruleAttributeValue
	ruleComment
	ruleDocComment
	ruleIdentifier
	ruleString
	ruleNumber
	ruleBoolean
	ruleDoubleColon
	ruleSingleColon
	rule_
	ruleEOL
)

var rul3s = [...]string{
	"Unknown",
	"Start",
	"Statement",
	"UseStmt",
	"UsePath",
	"TypeAlias",
	"StructDef",
	"FieldList",
	"Field",
	"FieldName",
	"EnumDef",
	"EnumValueList",
	"EnumValue",
	"DispatchStmt",
	"DispatchPath",
	"DispatchTarget",
	"SpreadStruct",
	"Type",
	"UnionType",
	"ArrayType",
	"StructType",
	"PrimitiveType",
	"ReferenceType",
	"LiteralType",
	"ArrayConstraint",
	"Range",
	"Attribute",
	"AttributeList",
	"AttributePair",
	"AttributeValue",
	"Comment",
	"DocComment",
	"Identifier",
	"String",
	"Number",
	"Boolean",
	"DoubleColon",
	"SingleColon",
	"_",
	"EOL",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type MCDocParser struct {
	Buffer string
	buffer []rune
	rules  [40]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *MCDocParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *MCDocParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *MCDocParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *MCDocParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *MCDocParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *MCDocParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *MCDocParser) Init(options ...func(*MCDocParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Start <- <(_ Statement* _ !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule_]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleStatement]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[rule_]() {
					goto l0
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !matchDot() {
						goto l4
					}
					goto l0
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
				add(ruleStart, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Statement <- <((UseStmt / TypeAlias / StructDef / EnumDef / DispatchStmt) _)> */
		func() bool {
			position5, tokenIndex5 := position, tokenIndex
			{
				position6 := position
				{
					position7, tokenIndex7 := position, tokenIndex
					if !_rules[ruleUseStmt]() {
						goto l8
					}
					goto l7
				l8:
					position, tokenIndex = position7, tokenIndex7
					if !_rules[ruleTypeAlias]() {
						goto l9
					}
					goto l7
				l9:
					position, tokenIndex = position7, tokenIndex7
					if !_rules[ruleStructDef]() {
						goto l10
					}
					goto l7
				l10:
					position, tokenIndex = position7, tokenIndex7
					if !_rules[ruleEnumDef]() {
						goto l11
					}
					goto l7
				l11:
					position, tokenIndex = position7, tokenIndex7
					if !_rules[ruleDispatchStmt]() {
						goto l5
					}
				}
			l7:
				if !_rules[rule_]() {
					goto l5
				}
				add(ruleStatement, position6)
			}
			return true
		l5:
			position, tokenIndex = position5, tokenIndex5
			return false
		},
		/* 2 UseStmt <- <('u' 's' 'e' _ UsePath _)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if buffer[position] != rune('u') {
					goto l12
				}
				position++
				if buffer[position] != rune('s') {
					goto l12
				}
				position++
				if buffer[position] != rune('e') {
					goto l12
				}
				position++
				if !_rules[rule_]() {
					goto l12
				}
				if !_rules[ruleUsePath]() {
					goto l12
				}
				if !_rules[rule_]() {
					goto l12
				}
				add(ruleUseStmt, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 UsePath <- <(DoubleColon / Identifier / SingleColon)+> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				{
					position18, tokenIndex18 := position, tokenIndex
					if !_rules[ruleDoubleColon]() {
						goto l19
					}
					goto l18
				l19:
					position, tokenIndex = position18, tokenIndex18
					if !_rules[ruleIdentifier]() {
						goto l20
					}
					goto l18
				l20:
					position, tokenIndex = position18, tokenIndex18
					if !_rules[ruleSingleColon]() {
						goto l14
					}
				}
			l18:
			l16:
				{
					position17, tokenIndex17 := position, tokenIndex
					{
						position21, tokenIndex21 := position, tokenIndex
						if !_rules[ruleDoubleColon]() {
							goto l22
						}
						goto l21
					l22:
						position, tokenIndex = position21, tokenIndex21
						if !_rules[ruleIdentifier]() {
							goto l23
						}
						goto l21
					l23:
						position, tokenIndex = position21, tokenIndex21
						if !_rules[ruleSingleColon]() {
							goto l17
						}
					}
				l21:
					goto l16
				l17:
					position, tokenIndex = position17, tokenIndex17
				}
				add(ruleUsePath, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 4 TypeAlias <- <('t' 'y' 'p' 'e' _ Identifier _ '=' _ Type _)> */
		func() bool {
			position24, tokenIndex24 := position, tokenIndex
			{
				position25 := position
				if buffer[position] != rune('t') {
					goto l24
				}
				position++
				if buffer[position] != rune('y') {
					goto l24
				}
				position++
				if buffer[position] != rune('p') {
					goto l24
				}
				position++
				if buffer[position] != rune('e') {
					goto l24
				}
				position++
				if !_rules[rule_]() {
					goto l24
				}
				if !_rules[ruleIdentifier]() {
					goto l24
				}
				if !_rules[rule_]() {
					goto l24
				}
				if buffer[position] != rune('=') {
					goto l24
				}
				position++
				if !_rules[rule_]() {
					goto l24
				}
				if !_rules[ruleType]() {
					goto l24
				}
				if !_rules[rule_]() {
					goto l24
				}
				add(ruleTypeAlias, position25)
			}
			return true
		l24:
			position, tokenIndex = position24, tokenIndex24
			return false
		},
		/* 5 StructDef <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier _ '{' _ FieldList? _ '}' _)> */
		func() bool {
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				if buffer[position] != rune('s') {
					goto l26
				}
				position++
				if buffer[position] != rune('t') {
					goto l26
				}
				position++
				if buffer[position] != rune('r') {
					goto l26
				}
				position++
				if buffer[position] != rune('u') {
					goto l26
				}
				position++
				if buffer[position] != rune('c') {
					goto l26
				}
				position++
				if buffer[position] != rune('t') {
					goto l26
				}
				position++
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleIdentifier]() {
					goto l26
				}
				if !_rules[rule_]() {
					goto l26
				}
				if buffer[position] != rune('{') {
					goto l26
				}
				position++
				if !_rules[rule_]() {
					goto l26
				}
				{
					position28, tokenIndex28 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l28
					}
					goto l29
				l28:
					position, tokenIndex = position28, tokenIndex28
				}
			l29:
				if !_rules[rule_]() {
					goto l26
				}
				if buffer[position] != rune('}') {
					goto l26
				}
				position++
				if !_rules[rule_]() {
					goto l26
				}
				add(ruleStructDef, position27)
			}
			return true
		l26:
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 6 FieldList <- <(Field (',' _ Field)* ','? _)> */
		func() bool {
			position30, tokenIndex30 := position, tokenIndex
			{
				position31 := position
				if !_rules[ruleField]() {
					goto l30
				}
			l32:
				{
					position33, tokenIndex33 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l33
					}
					position++
					if !_rules[rule_]() {
						goto l33
					}
					if !_rules[ruleField]() {
						goto l33
					}
					goto l32
				l33:
					position, tokenIndex = position33, tokenIndex33
				}
				{
					position34, tokenIndex34 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l34
					}
					position++
					goto l35
				l34:
					position, tokenIndex = position34, tokenIndex34
				}
			l35:
				if !_rules[rule_]() {
					goto l30
				}
				add(ruleFieldList, position31)
			}
			return true
		l30:
			position, tokenIndex = position30, tokenIndex30
			return false
		},
		/* 7 Field <- <(Attribute* _ FieldName _ ':' _ Type _)> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
			l38:
				{
					position39, tokenIndex39 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l39
					}
					goto l38
				l39:
					position, tokenIndex = position39, tokenIndex39
				}
				if !_rules[rule_]() {
					goto l36
				}
				if !_rules[ruleFieldName]() {
					goto l36
				}
				if !_rules[rule_]() {
					goto l36
				}
				if buffer[position] != rune(':') {
					goto l36
				}
				position++
				if !_rules[rule_]() {
					goto l36
				}
				if !_rules[ruleType]() {
					goto l36
				}
				if !_rules[rule_]() {
					goto l36
				}
				add(ruleField, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 8 FieldName <- <(Identifier '?'?)> */
		func() bool {
			position40, tokenIndex40 := position, tokenIndex
			{
				position41 := position
				if !_rules[ruleIdentifier]() {
					goto l40
				}
				{
					position42, tokenIndex42 := position, tokenIndex
					if buffer[position] != rune('?') {
						goto l42
					}
					position++
					goto l43
				l42:
					position, tokenIndex = position42, tokenIndex42
				}
			l43:
				add(ruleFieldName, position41)
			}
			return true
		l40:
			position, tokenIndex = position40, tokenIndex40
			return false
		},
		/* 9 EnumDef <- <('e' 'n' 'u' 'm' _ '(' _ Type _ ')' _ Identifier _ '{' _ EnumValueList? _ '}' _)> */
		func() bool {
			position44, tokenIndex44 := position, tokenIndex
			{
				position45 := position
				if buffer[position] != rune('e') {
					goto l44
				}
				position++
				if buffer[position] != rune('n') {
					goto l44
				}
				position++
				if buffer[position] != rune('u') {
					goto l44
				}
				position++
				if buffer[position] != rune('m') {
					goto l44
				}
				position++
				if !_rules[rule_]() {
					goto l44
				}
				if buffer[position] != rune('(') {
					goto l44
				}
				position++
				if !_rules[rule_]() {
					goto l44
				}
				if !_rules[ruleType]() {
					goto l44
				}
				if !_rules[rule_]() {
					goto l44
				}
				if buffer[position] != rune(')') {
					goto l44
				}
				position++
				if !_rules[rule_]() {
					goto l44
				}
				if !_rules[ruleIdentifier]() {
					goto l44
				}
				if !_rules[rule_]() {
					goto l44
				}
				if buffer[position] != rune('{') {
					goto l44
				}
				position++
				if !_rules[rule_]() {
					goto l44
				}
				{
					position46, tokenIndex46 := position, tokenIndex
					if !_rules[ruleEnumValueList]() {
						goto l46
					}
					goto l47
				l46:
					position, tokenIndex = position46, tokenIndex46
				}
			l47:
				if !_rules[rule_]() {
					goto l44
				}
				if buffer[position] != rune('}') {
					goto l44
				}
				position++
				if !_rules[rule_]() {
					goto l44
				}
				add(ruleEnumDef, position45)
			}
			return true
		l44:
			position, tokenIndex = position44, tokenIndex44
			return false
		},
		/* 10 EnumValueList <- <(EnumValue (',' _ EnumValue)* ','? _)> */
		func() bool {
			position48, tokenIndex48 := position, tokenIndex
			{
				position49 := position
				if !_rules[ruleEnumValue]() {
					goto l48
				}
			l50:
				{
					position51, tokenIndex51 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l51
					}
					position++
					if !_rules[rule_]() {
						goto l51
					}
					if !_rules[ruleEnumValue]() {
						goto l51
					}
					goto l50
				l51:
					position, tokenIndex = position51, tokenIndex51
				}
				{
					position52, tokenIndex52 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l52
					}
					position++
					goto l53
				l52:
					position, tokenIndex = position52, tokenIndex52
				}
			l53:
				if !_rules[rule_]() {
					goto l48
				}
				add(ruleEnumValueList, position49)
			}
			return true
		l48:
			position, tokenIndex = position48, tokenIndex48
			return false
		},
		/* 11 EnumValue <- <(Identifier _ '=' _ String _)> */
		func() bool {
			position54, tokenIndex54 := position, tokenIndex
			{
				position55 := position
				if !_rules[ruleIdentifier]() {
					goto l54
				}
				if !_rules[rule_]() {
					goto l54
				}
				if buffer[position] != rune('=') {
					goto l54
				}
				position++
				if !_rules[rule_]() {
					goto l54
				}
				if !_rules[ruleString]() {
					goto l54
				}
				if !_rules[rule_]() {
					goto l54
				}
				add(ruleEnumValue, position55)
			}
			return true
		l54:
			position, tokenIndex = position54, tokenIndex54
			return false
		},
		/* 12 DispatchStmt <- <('d' 'i' 's' 'p' 'a' 't' 'c' 'h' _ DispatchPath _ ('t' 'o') _ DispatchTarget _)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if buffer[position] != rune('d') {
					goto l56
				}
				position++
				if buffer[position] != rune('i') {
					goto l56
				}
				position++
				if buffer[position] != rune('s') {
					goto l56
				}
				position++
				if buffer[position] != rune('p') {
					goto l56
				}
				position++
				if buffer[position] != rune('a') {
					goto l56
				}
				position++
				if buffer[position] != rune('t') {
					goto l56
				}
				position++
				if buffer[position] != rune('c') {
					goto l56
				}
				position++
				if buffer[position] != rune('h') {
					goto l56
				}
				position++
				if !_rules[rule_]() {
					goto l56
				}
				if !_rules[ruleDispatchPath]() {
					goto l56
				}
				if !_rules[rule_]() {
					goto l56
				}
				if buffer[position] != rune('t') {
					goto l56
				}
				position++
				if buffer[position] != rune('o') {
					goto l56
				}
				position++
				if !_rules[rule_]() {
					goto l56
				}
				if !_rules[ruleDispatchTarget]() {
					goto l56
				}
				if !_rules[rule_]() {
					goto l56
				}
				add(ruleDispatchStmt, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 13 DispatchPath <- <('m' 'i' 'n' 'e' 'c' 'r' 'a' 'f' 't' ':' 'r' 'e' 's' 'o' 'u' 'r' 'c' 'e' '[' Identifier ']')> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
				if buffer[position] != rune('m') {
					goto l58
				}
				position++
				if buffer[position] != rune('i') {
					goto l58
				}
				position++
				if buffer[position] != rune('n') {
					goto l58
				}
				position++
				if buffer[position] != rune('e') {
					goto l58
				}
				position++
				if buffer[position] != rune('c') {
					goto l58
				}
				position++
				if buffer[position] != rune('r') {
					goto l58
				}
				position++
				if buffer[position] != rune('a') {
					goto l58
				}
				position++
				if buffer[position] != rune('f') {
					goto l58
				}
				position++
				if buffer[position] != rune('t') {
					goto l58
				}
				position++
				if buffer[position] != rune(':') {
					goto l58
				}
				position++
				if buffer[position] != rune('r') {
					goto l58
				}
				position++
				if buffer[position] != rune('e') {
					goto l58
				}
				position++
				if buffer[position] != rune('s') {
					goto l58
				}
				position++
				if buffer[position] != rune('o') {
					goto l58
				}
				position++
				if buffer[position] != rune('u') {
					goto l58
				}
				position++
				if buffer[position] != rune('r') {
					goto l58
				}
				position++
				if buffer[position] != rune('c') {
					goto l58
				}
				position++
				if buffer[position] != rune('e') {
					goto l58
				}
				position++
				if buffer[position] != rune('[') {
					goto l58
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l58
				}
				if buffer[position] != rune(']') {
					goto l58
				}
				position++
				add(ruleDispatchPath, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 14 DispatchTarget <- <(('s' 't' 'r' 'u' 'c' 't' _ Identifier _ '{' _ FieldList? _ '}') / Type)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				{
					position62, tokenIndex62 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l63
					}
					position++
					if buffer[position] != rune('t') {
						goto l63
					}
					position++
					if buffer[position] != rune('r') {
						goto l63
					}
					position++
					if buffer[position] != rune('u') {
						goto l63
					}
					position++
					if buffer[position] != rune('c') {
						goto l63
					}
					position++
					if buffer[position] != rune('t') {
						goto l63
					}
					position++
					if !_rules[rule_]() {
						goto l63
					}
					if !_rules[ruleIdentifier]() {
						goto l63
					}
					if !_rules[rule_]() {
						goto l63
					}
					if buffer[position] != rune('{') {
						goto l63
					}
					position++
					if !_rules[rule_]() {
						goto l63
					}
					{
						position64, tokenIndex64 := position, tokenIndex
						if !_rules[ruleFieldList]() {
							goto l64
						}
						goto l65
					l64:
						position, tokenIndex = position64, tokenIndex64
					}
				l65:
					if !_rules[rule_]() {
						goto l63
					}
					if buffer[position] != rune('}') {
						goto l63
					}
					position++
					goto l62
				l63:
					position, tokenIndex = position62, tokenIndex62
					if !_rules[ruleType]() {
						goto l60
					}
				}
			l62:
				add(ruleDispatchTarget, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 15 SpreadStruct <- <('.' '.' '.' _ ('s' 't' 'r' 'u' 'c' 't') _ Identifier _ '{' _ FieldList? _ '}' _)> */
		nil,
		/* 16 Type <- <(UnionType / ArrayType / StructType / PrimitiveType / ReferenceType / LiteralType)> */
		func() bool {
			position67, tokenIndex67 := position, tokenIndex
			{
				position68 := position
				{
					position69, tokenIndex69 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l70
					}
					goto l69
				l70:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleArrayType]() {
						goto l71
					}
					goto l69
				l71:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleStructType]() {
						goto l72
					}
					goto l69
				l72:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[rulePrimitiveType]() {
						goto l73
					}
					goto l69
				l73:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleReferenceType]() {
						goto l74
					}
					goto l69
				l74:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleLiteralType]() {
						goto l67
					}
				}
			l69:
				add(ruleType, position68)
			}
			return true
		l67:
			position, tokenIndex = position67, tokenIndex67
			return false
		},
		/* 17 UnionType <- <('(' _ Type (_ '|' _ Type)+ _ ')')> */
		func() bool {
			position75, tokenIndex75 := position, tokenIndex
			{
				position76 := position
				if buffer[position] != rune('(') {
					goto l75
				}
				position++
				if !_rules[rule_]() {
					goto l75
				}
				if !_rules[ruleType]() {
					goto l75
				}
				if !_rules[rule_]() {
					goto l75
				}
				if buffer[position] != rune('|') {
					goto l75
				}
				position++
				if !_rules[rule_]() {
					goto l75
				}
				if !_rules[ruleType]() {
					goto l75
				}
			l77:
				{
					position78, tokenIndex78 := position, tokenIndex
					if !_rules[rule_]() {
						goto l78
					}
					if buffer[position] != rune('|') {
						goto l78
					}
					position++
					if !_rules[rule_]() {
						goto l78
					}
					if !_rules[ruleType]() {
						goto l78
					}
					goto l77
				l78:
					position, tokenIndex = position78, tokenIndex78
				}
				if !_rules[rule_]() {
					goto l75
				}
				if buffer[position] != rune(')') {
					goto l75
				}
				position++
				add(ruleUnionType, position76)
			}
			return true
		l75:
			position, tokenIndex = position75, tokenIndex75
			return false
		},
		/* 18 ArrayType <- <('[' _ Type _ ']' _ ArrayConstraint?)> */
		func() bool {
			position79, tokenIndex79 := position, tokenIndex
			{
				position80 := position
				if buffer[position] != rune('[') {
					goto l79
				}
				position++
				if !_rules[rule_]() {
					goto l79
				}
				if !_rules[ruleType]() {
					goto l79
				}
				if !_rules[rule_]() {
					goto l79
				}
				if buffer[position] != rune(']') {
					goto l79
				}
				position++
				if !_rules[rule_]() {
					goto l79
				}
				{
					position81, tokenIndex81 := position, tokenIndex
					if !_rules[ruleArrayConstraint]() {
						goto l81
					}
					goto l82
				l81:
					position, tokenIndex = position81, tokenIndex81
				}
			l82:
				add(ruleArrayType, position80)
			}
			return true
		l79:
			position, tokenIndex = position79, tokenIndex79
			return false
		},
		/* 19 StructType <- <('s' 't' 'r' 'u' 'c' 't' _ '{' _ FieldList? _ '}')> */
		func() bool {
			position83, tokenIndex83 := position, tokenIndex
			{
				position84 := position
				if buffer[position] != rune('s') {
					goto l83
				}
				position++
				if buffer[position] != rune('t') {
					goto l83
				}
				position++
				if buffer[position] != rune('r') {
					goto l83
				}
				position++
				if buffer[position] != rune('u') {
					goto l83
				}
				position++
				if buffer[position] != rune('c') {
					goto l83
				}
				position++
				if buffer[position] != rune('t') {
					goto l83
				}
				position++
				if !_rules[rule_]() {
					goto l83
				}
				if buffer[position] != rune('{') {
					goto l83
				}
				position++
				if !_rules[rule_]() {
					goto l83
				}
				{
					position85, tokenIndex85 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l85
					}
					goto l86
				l85:
					position, tokenIndex = position85, tokenIndex85
				}
			l86:
				if !_rules[rule_]() {
					goto l83
				}
				if buffer[position] != rune('}') {
					goto l83
				}
				position++
				add(ruleStructType, position84)
			}
			return true
		l83:
			position, tokenIndex = position83, tokenIndex83
			return false
		},
		/* 20 PrimitiveType <- <(('s' 't' 'r' 'i' 'n' 'g') / ('i' 'n' 't') / ('f' 'l' 'o' 'a' 't') / ('d' 'o' 'u' 'b' 'l' 'e') / ('b' 'o' 'o' 'l' 'e' 'a' 'n') / ('a' 'n' 'y'))> */
		func() bool {
			position87, tokenIndex87 := position, tokenIndex
			{
				position88 := position
				{
					position89, tokenIndex89 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l90
					}
					position++
					if buffer[position] != rune('t') {
						goto l90
					}
					position++
					if buffer[position] != rune('r') {
						goto l90
					}
					position++
					if buffer[position] != rune('i') {
						goto l90
					}
					position++
					if buffer[position] != rune('n') {
						goto l90
					}
					position++
					if buffer[position] != rune('g') {
						goto l90
					}
					position++
					goto l89
				l90:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('i') {
						goto l91
					}
					position++
					if buffer[position] != rune('n') {
						goto l91
					}
					position++
					if buffer[position] != rune('t') {
						goto l91
					}
					position++
					goto l89
				l91:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('f') {
						goto l92
					}
					position++
					if buffer[position] != rune('l') {
						goto l92
					}
					position++
					if buffer[position] != rune('o') {
						goto l92
					}
					position++
					if buffer[position] != rune('a') {
						goto l92
					}
					position++
					if buffer[position] != rune('t') {
						goto l92
					}
					position++
					goto l89
				l92:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('d') {
						goto l93
					}
					position++
					if buffer[position] != rune('o') {
						goto l93
					}
					position++
					if buffer[position] != rune('u') {
						goto l93
					}
					position++
					if buffer[position] != rune('b') {
						goto l93
					}
					position++
					if buffer[position] != rune('l') {
						goto l93
					}
					position++
					if buffer[position] != rune('e') {
						goto l93
					}
					position++
					goto l89
				l93:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('b') {
						goto l94
					}
					position++
					if buffer[position] != rune('o') {
						goto l94
					}
					position++
					if buffer[position] != rune('o') {
						goto l94
					}
					position++
					if buffer[position] != rune('l') {
						goto l94
					}
					position++
					if buffer[position] != rune('e') {
						goto l94
					}
					position++
					if buffer[position] != rune('a') {
						goto l94
					}
					position++
					if buffer[position] != rune('n') {
						goto l94
					}
					position++
					goto l89
				l94:
					position, tokenIndex = position89, tokenIndex89
					if buffer[position] != rune('a') {
						goto l87
					}
					position++
					if buffer[position] != rune('n') {
						goto l87
					}
					position++
					if buffer[position] != rune('y') {
						goto l87
					}
					position++
				}
			l89:
				add(rulePrimitiveType, position88)
			}
			return true
		l87:
			position, tokenIndex = position87, tokenIndex87
			return false
		},
		/* 21 ReferenceType <- <Identifier> */
		func() bool {
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				if !_rules[ruleIdentifier]() {
					goto l95
				}
				add(ruleReferenceType, position96)
			}
			return true
		l95:
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 22 LiteralType <- <(String / Number / Boolean)> */
		func() bool {
			position97, tokenIndex97 := position, tokenIndex
			{
				position98 := position
				{
					position99, tokenIndex99 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l100
					}
					goto l99
				l100:
					position, tokenIndex = position99, tokenIndex99
					if !_rules[ruleNumber]() {
						goto l101
					}
					goto l99
				l101:
					position, tokenIndex = position99, tokenIndex99
					if !_rules[ruleBoolean]() {
						goto l97
					}
				}
			l99:
				add(ruleLiteralType, position98)
			}
			return true
		l97:
			position, tokenIndex = position97, tokenIndex97
			return false
		},
		/* 23 ArrayConstraint <- <('@' _ (Number / Range))> */
		func() bool {
			position102, tokenIndex102 := position, tokenIndex
			{
				position103 := position
				if buffer[position] != rune('@') {
					goto l102
				}
				position++
				if !_rules[rule_]() {
					goto l102
				}
				{
					position104, tokenIndex104 := position, tokenIndex
					if !_rules[ruleNumber]() {
						goto l105
					}
					goto l104
				l105:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleRange]() {
						goto l102
					}
				}
			l104:
				add(ruleArrayConstraint, position103)
			}
			return true
		l102:
			position, tokenIndex = position102, tokenIndex102
			return false
		},
		/* 24 Range <- <(Number ('.' '.') Number)> */
		func() bool {
			position106, tokenIndex106 := position, tokenIndex
			{
				position107 := position
				if !_rules[ruleNumber]() {
					goto l106
				}
				if buffer[position] != rune('.') {
					goto l106
				}
				position++
				if buffer[position] != rune('.') {
					goto l106
				}
				position++
				if !_rules[ruleNumber]() {
					goto l106
				}
				add(ruleRange, position107)
			}
			return true
		l106:
			position, tokenIndex = position106, tokenIndex106
			return false
		},
		/* 25 Attribute <- <('#' '[' _ AttributeList _ ']' _)> */
		func() bool {
			position108, tokenIndex108 := position, tokenIndex
			{
				position109 := position
				if buffer[position] != rune('#') {
					goto l108
				}
				position++
				if buffer[position] != rune('[') {
					goto l108
				}
				position++
				if !_rules[rule_]() {
					goto l108
				}
				if !_rules[ruleAttributeList]() {
					goto l108
				}
				if !_rules[rule_]() {
					goto l108
				}
				if buffer[position] != rune(']') {
					goto l108
				}
				position++
				if !_rules[rule_]() {
					goto l108
				}
				add(ruleAttribute, position109)
			}
			return true
		l108:
			position, tokenIndex = position108, tokenIndex108
			return false
		},
		/* 26 AttributeList <- <(AttributePair (',' _ AttributePair)*)> */
		func() bool {
			position110, tokenIndex110 := position, tokenIndex
			{
				position111 := position
				if !_rules[ruleAttributePair]() {
					goto l110
				}
			l112:
				{
					position113, tokenIndex113 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l113
					}
					position++
					if !_rules[rule_]() {
						goto l113
					}
					if !_rules[ruleAttributePair]() {
						goto l113
					}
					goto l112
				l113:
					position, tokenIndex = position113, tokenIndex113
				}
				add(ruleAttributeList, position111)
			}
			return true
		l110:
			position, tokenIndex = position110, tokenIndex110
			return false
		},
		/* 27 AttributePair <- <(Identifier '=' AttributeValue)> */
		func() bool {
			position114, tokenIndex114 := position, tokenIndex
			{
				position115 := position
				if !_rules[ruleIdentifier]() {
					goto l114
				}
				if buffer[position] != rune('=') {
					goto l114
				}
				position++
				if !_rules[ruleAttributeValue]() {
					goto l114
				}
				add(ruleAttributePair, position115)
			}
			return true
		l114:
			position, tokenIndex = position114, tokenIndex114
			return false
		},
		/* 28 AttributeValue <- <(String / Number / Boolean / Identifier)> */
		func() bool {
			position116, tokenIndex116 := position, tokenIndex
			{
				position117 := position
				{
					position118, tokenIndex118 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l119
					}
					goto l118
				l119:
					position, tokenIndex = position118, tokenIndex118
					if !_rules[ruleNumber]() {
						goto l120
					}
					goto l118
				l120:
					position, tokenIndex = position118, tokenIndex118
					if !_rules[ruleBoolean]() {
						goto l121
					}
					goto l118
				l121:
					position, tokenIndex = position118, tokenIndex118
					if !_rules[ruleIdentifier]() {
						goto l116
					}
				}
			l118:
				add(ruleAttributeValue, position117)
			}
			return true
		l116:
			position, tokenIndex = position116, tokenIndex116
			return false
		},
		/* 29 Comment <- <('/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position122, tokenIndex122 := position, tokenIndex
			{
				position123 := position
				if buffer[position] != rune('/') {
					goto l122
				}
				position++
				if buffer[position] != rune('/') {
					goto l122
				}
				position++
			l124:
				{
					position125, tokenIndex125 := position, tokenIndex
					{
						position126, tokenIndex126 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l126
						}
						goto l125
					l126:
						position, tokenIndex = position126, tokenIndex126
					}
					if !matchDot() {
						goto l125
					}
					goto l124
				l125:
					position, tokenIndex = position125, tokenIndex125
				}
				{
					position127, tokenIndex127 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l128
					}
					goto l127
				l128:
					position, tokenIndex = position127, tokenIndex127
					{
						position129, tokenIndex129 := position, tokenIndex
						if !matchDot() {
							goto l129
						}
						goto l122
					l129:
						position, tokenIndex = position129, tokenIndex129
					}
				}
			l127:
				add(ruleComment, position123)
			}
			return true
		l122:
			position, tokenIndex = position122, tokenIndex122
			return false
		},
		/* 30 DocComment <- <('/' '/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				if buffer[position] != rune('/') {
					goto l130
				}
				position++
				if buffer[position] != rune('/') {
					goto l130
				}
				position++
				if buffer[position] != rune('/') {
					goto l130
				}
				position++
			l132:
				{
					position133, tokenIndex133 := position, tokenIndex
					{
						position134, tokenIndex134 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l134
						}
						goto l133
					l134:
						position, tokenIndex = position134, tokenIndex134
					}
					if !matchDot() {
						goto l133
					}
					goto l132
				l133:
					position, tokenIndex = position133, tokenIndex133
				}
				{
					position135, tokenIndex135 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l136
					}
					goto l135
				l136:
					position, tokenIndex = position135, tokenIndex135
					{
						position137, tokenIndex137 := position, tokenIndex
						if !matchDot() {
							goto l137
						}
						goto l130
					l137:
						position, tokenIndex = position137, tokenIndex137
					}
				}
			l135:
				add(ruleDocComment, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 31 Identifier <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')*)> */
		func() bool {
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				{
					position140, tokenIndex140 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l141
					}
					position++
					goto l140
				l141:
					position, tokenIndex = position140, tokenIndex140
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l142
					}
					position++
					goto l140
				l142:
					position, tokenIndex = position140, tokenIndex140
					if buffer[position] != rune('_') {
						goto l138
					}
					position++
				}
			l140:
			l143:
				{
					position144, tokenIndex144 := position, tokenIndex
					{
						position145, tokenIndex145 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l146
						}
						position++
						goto l145
					l146:
						position, tokenIndex = position145, tokenIndex145
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l147
						}
						position++
						goto l145
					l147:
						position, tokenIndex = position145, tokenIndex145
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l148
						}
						position++
						goto l145
					l148:
						position, tokenIndex = position145, tokenIndex145
						if buffer[position] != rune('_') {
							goto l144
						}
						position++
					}
				l145:
					goto l143
				l144:
					position, tokenIndex = position144, tokenIndex144
				}
				add(ruleIdentifier, position139)
			}
			return true
		l138:
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 32 String <- <('"' (!'"' .)* '"')> */
		func() bool {
			position149, tokenIndex149 := position, tokenIndex
			{
				position150 := position
				if buffer[position] != rune('"') {
					goto l149
				}
				position++
			l151:
				{
					position152, tokenIndex152 := position, tokenIndex
					{
						position153, tokenIndex153 := position, tokenIndex
						if buffer[position] != rune('"') {
							goto l153
						}
						position++
						goto l152
					l153:
						position, tokenIndex = position153, tokenIndex153
					}
					if !matchDot() {
						goto l152
					}
					goto l151
				l152:
					position, tokenIndex = position152, tokenIndex152
				}
				if buffer[position] != rune('"') {
					goto l149
				}
				position++
				add(ruleString, position150)
			}
			return true
		l149:
			position, tokenIndex = position149, tokenIndex149
			return false
		},
		/* 33 Number <- <([0-9]+ ('.' [0-9]+)?)> */
		func() bool {
			position154, tokenIndex154 := position, tokenIndex
			{
				position155 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l154
				}
				position++
			l156:
				{
					position157, tokenIndex157 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l157
					}
					position++
					goto l156
				l157:
					position, tokenIndex = position157, tokenIndex157
				}
				{
					position158, tokenIndex158 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l158
					}
					position++
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l158
					}
					position++
				l160:
					{
						position161, tokenIndex161 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l161
						}
						position++
						goto l160
					l161:
						position, tokenIndex = position161, tokenIndex161
					}
					goto l159
				l158:
					position, tokenIndex = position158, tokenIndex158
				}
			l159:
				add(ruleNumber, position155)
			}
			return true
		l154:
			position, tokenIndex = position154, tokenIndex154
			return false
		},
		/* 34 Boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		func() bool {
			position162, tokenIndex162 := position, tokenIndex
			{
				position163 := position
				{
					position164, tokenIndex164 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l165
					}
					position++
					if buffer[position] != rune('r') {
						goto l165
					}
					position++
					if buffer[position] != rune('u') {
						goto l165
					}
					position++
					if buffer[position] != rune('e') {
						goto l165
					}
					position++
					goto l164
				l165:
					position, tokenIndex = position164, tokenIndex164
					if buffer[position] != rune('f') {
						goto l162
					}
					position++
					if buffer[position] != rune('a') {
						goto l162
					}
					position++
					if buffer[position] != rune('l') {
						goto l162
					}
					position++
					if buffer[position] != rune('s') {
						goto l162
					}
					position++
					if buffer[position] != rune('e') {
						goto l162
					}
					position++
				}
			l164:
				add(ruleBoolean, position163)
			}
			return true
		l162:
			position, tokenIndex = position162, tokenIndex162
			return false
		},
		/* 35 DoubleColon <- <(':' ':')> */
		func() bool {
			position166, tokenIndex166 := position, tokenIndex
			{
				position167 := position
				if buffer[position] != rune(':') {
					goto l166
				}
				position++
				if buffer[position] != rune(':') {
					goto l166
				}
				position++
				add(ruleDoubleColon, position167)
			}
			return true
		l166:
			position, tokenIndex = position166, tokenIndex166
			return false
		},
		/* 36 SingleColon <- <':'> */
		func() bool {
			position168, tokenIndex168 := position, tokenIndex
			{
				position169 := position
				if buffer[position] != rune(':') {
					goto l168
				}
				position++
				add(ruleSingleColon, position169)
			}
			return true
		l168:
			position, tokenIndex = position168, tokenIndex168
			return false
		},
		/* 37 _ <- <(' ' / '\t' / '\r' / '\n' / Comment / DocComment)*> */
		func() bool {
			{
				position171 := position
			l172:
				{
					position173, tokenIndex173 := position, tokenIndex
					{
						position174, tokenIndex174 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l175
						}
						position++
						goto l174
					l175:
						position, tokenIndex = position174, tokenIndex174
						if buffer[position] != rune('\t') {
							goto l176
						}
						position++
						goto l174
					l176:
						position, tokenIndex = position174, tokenIndex174
						if buffer[position] != rune('\r') {
							goto l177
						}
						position++
						goto l174
					l177:
						position, tokenIndex = position174, tokenIndex174
						if buffer[position] != rune('\n') {
							goto l178
						}
						position++
						goto l174
					l178:
						position, tokenIndex = position174, tokenIndex174
						if !_rules[ruleComment]() {
							goto l179
						}
						goto l174
					l179:
						position, tokenIndex = position174, tokenIndex174
						if !_rules[ruleDocComment]() {
							goto l173
						}
					}
				l174:
					goto l172
				l173:
					position, tokenIndex = position173, tokenIndex173
				}
				add(rule_, position171)
			}
			return true
		},
		/* 38 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position180, tokenIndex180 := position, tokenIndex
			{
				position181 := position
				{
					position182, tokenIndex182 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l183
					}
					position++
					if buffer[position] != rune('\n') {
						goto l183
					}
					position++
					goto l182
				l183:
					position, tokenIndex = position182, tokenIndex182
					if buffer[position] != rune('\n') {
						goto l184
					}
					position++
					goto l182
				l184:
					position, tokenIndex = position182, tokenIndex182
					if buffer[position] != rune('\r') {
						goto l180
					}
					position++
				}
			l182:
				add(ruleEOL, position181)
			}
			return true
		l180:
			position, tokenIndex = position180, tokenIndex180
			return false
		},
	}
	p.rules = _rules
	return nil
}
