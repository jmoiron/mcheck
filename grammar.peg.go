package main

// Code generated by peg grammar.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleStart
	ruleStatement
	ruleUseStmt
	ruleUsePath
	ruleTypeAlias
	ruleStructDef
	ruleFieldList
	ruleFieldOrSpread
	ruleField
	ruleComputedField
	ruleNamedField
	ruleSpreadField
	ruleFieldName
	ruleEnumDef
	ruleEnumValueList
	ruleEnumValue
	ruleDispatchStmt
	ruleDispatchPath
	ruleDispatchKeyList
	ruleDispatchKey
	ruleDispatchTarget
	ruleSpreadStruct
	ruleType
	ruleAttributedType
	ruleConstrainedType
	ruleUnionType
	ruleArrayType
	ruleStructType
	rulePrimitiveType
	ruleReferenceType
	ruleComplexReference
	ruleComplexRefParam
	ruleStaticIndexKey
	ruleLiteralType
	ruleArrayConstraint
	ruleRange
	ruleAttribute
	ruleAttributeList
	ruleAttributeItem
	ruleAttributeCall
	ruleAttributeParamList
	ruleAttributeParam
	ruleAttributePair
	ruleAttributeValue
	ruleArrayLiteral
	ruleComment
	ruleDocComment
	ruleIdentifier
	ruleString
	ruleNumber
	ruleBoolean
	ruleDoubleColon
	ruleSingleColon
	rule_
	ruleEOL
)

var rul3s = [...]string{
	"Unknown",
	"Start",
	"Statement",
	"UseStmt",
	"UsePath",
	"TypeAlias",
	"StructDef",
	"FieldList",
	"FieldOrSpread",
	"Field",
	"ComputedField",
	"NamedField",
	"SpreadField",
	"FieldName",
	"EnumDef",
	"EnumValueList",
	"EnumValue",
	"DispatchStmt",
	"DispatchPath",
	"DispatchKeyList",
	"DispatchKey",
	"DispatchTarget",
	"SpreadStruct",
	"Type",
	"AttributedType",
	"ConstrainedType",
	"UnionType",
	"ArrayType",
	"StructType",
	"PrimitiveType",
	"ReferenceType",
	"ComplexReference",
	"ComplexRefParam",
	"StaticIndexKey",
	"LiteralType",
	"ArrayConstraint",
	"Range",
	"Attribute",
	"AttributeList",
	"AttributeItem",
	"AttributeCall",
	"AttributeParamList",
	"AttributeParam",
	"AttributePair",
	"AttributeValue",
	"ArrayLiteral",
	"Comment",
	"DocComment",
	"Identifier",
	"String",
	"Number",
	"Boolean",
	"DoubleColon",
	"SingleColon",
	"_",
	"EOL",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type MCDocParser struct {
	Buffer string
	buffer []rune
	rules  [56]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *MCDocParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *MCDocParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *MCDocParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *MCDocParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *MCDocParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *MCDocParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *MCDocParser) Init(options ...func(*MCDocParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Start <- <(_ Statement* _ !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule_]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleStatement]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[rule_]() {
					goto l0
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !matchDot() {
						goto l4
					}
					goto l0
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
				add(ruleStart, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Statement <- <(Attribute* _ (UseStmt / TypeAlias / StructDef / EnumDef / DispatchStmt) _)> */
		func() bool {
			position5, tokenIndex5 := position, tokenIndex
			{
				position6 := position
			l7:
				{
					position8, tokenIndex8 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l8
					}
					goto l7
				l8:
					position, tokenIndex = position8, tokenIndex8
				}
				if !_rules[rule_]() {
					goto l5
				}
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[ruleUseStmt]() {
						goto l10
					}
					goto l9
				l10:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleTypeAlias]() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleStructDef]() {
						goto l12
					}
					goto l9
				l12:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleEnumDef]() {
						goto l13
					}
					goto l9
				l13:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleDispatchStmt]() {
						goto l5
					}
				}
			l9:
				if !_rules[rule_]() {
					goto l5
				}
				add(ruleStatement, position6)
			}
			return true
		l5:
			position, tokenIndex = position5, tokenIndex5
			return false
		},
		/* 2 UseStmt <- <('u' 's' 'e' _ UsePath _)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if buffer[position] != rune('u') {
					goto l14
				}
				position++
				if buffer[position] != rune('s') {
					goto l14
				}
				position++
				if buffer[position] != rune('e') {
					goto l14
				}
				position++
				if !_rules[rule_]() {
					goto l14
				}
				if !_rules[ruleUsePath]() {
					goto l14
				}
				if !_rules[rule_]() {
					goto l14
				}
				add(ruleUseStmt, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 3 UsePath <- <(DoubleColon / Identifier / SingleColon)+> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				{
					position20, tokenIndex20 := position, tokenIndex
					if !_rules[ruleDoubleColon]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position20, tokenIndex20
					if !_rules[ruleIdentifier]() {
						goto l22
					}
					goto l20
				l22:
					position, tokenIndex = position20, tokenIndex20
					if !_rules[ruleSingleColon]() {
						goto l16
					}
				}
			l20:
			l18:
				{
					position19, tokenIndex19 := position, tokenIndex
					{
						position23, tokenIndex23 := position, tokenIndex
						if !_rules[ruleDoubleColon]() {
							goto l24
						}
						goto l23
					l24:
						position, tokenIndex = position23, tokenIndex23
						if !_rules[ruleIdentifier]() {
							goto l25
						}
						goto l23
					l25:
						position, tokenIndex = position23, tokenIndex23
						if !_rules[ruleSingleColon]() {
							goto l19
						}
					}
				l23:
					goto l18
				l19:
					position, tokenIndex = position19, tokenIndex19
				}
				add(ruleUsePath, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 4 TypeAlias <- <('t' 'y' 'p' 'e' _ Identifier _ '=' _ Type _)> */
		func() bool {
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				if buffer[position] != rune('t') {
					goto l26
				}
				position++
				if buffer[position] != rune('y') {
					goto l26
				}
				position++
				if buffer[position] != rune('p') {
					goto l26
				}
				position++
				if buffer[position] != rune('e') {
					goto l26
				}
				position++
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleIdentifier]() {
					goto l26
				}
				if !_rules[rule_]() {
					goto l26
				}
				if buffer[position] != rune('=') {
					goto l26
				}
				position++
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleType]() {
					goto l26
				}
				if !_rules[rule_]() {
					goto l26
				}
				add(ruleTypeAlias, position27)
			}
			return true
		l26:
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 5 StructDef <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier _ '{' _ FieldList? _ '}' _)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				if buffer[position] != rune('s') {
					goto l28
				}
				position++
				if buffer[position] != rune('t') {
					goto l28
				}
				position++
				if buffer[position] != rune('r') {
					goto l28
				}
				position++
				if buffer[position] != rune('u') {
					goto l28
				}
				position++
				if buffer[position] != rune('c') {
					goto l28
				}
				position++
				if buffer[position] != rune('t') {
					goto l28
				}
				position++
				if !_rules[rule_]() {
					goto l28
				}
				if !_rules[ruleIdentifier]() {
					goto l28
				}
				if !_rules[rule_]() {
					goto l28
				}
				if buffer[position] != rune('{') {
					goto l28
				}
				position++
				if !_rules[rule_]() {
					goto l28
				}
				{
					position30, tokenIndex30 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l30
					}
					goto l31
				l30:
					position, tokenIndex = position30, tokenIndex30
				}
			l31:
				if !_rules[rule_]() {
					goto l28
				}
				if buffer[position] != rune('}') {
					goto l28
				}
				position++
				if !_rules[rule_]() {
					goto l28
				}
				add(ruleStructDef, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 6 FieldList <- <(FieldOrSpread (',' _ FieldOrSpread)* ','? _)> */
		func() bool {
			position32, tokenIndex32 := position, tokenIndex
			{
				position33 := position
				if !_rules[ruleFieldOrSpread]() {
					goto l32
				}
			l34:
				{
					position35, tokenIndex35 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l35
					}
					position++
					if !_rules[rule_]() {
						goto l35
					}
					if !_rules[ruleFieldOrSpread]() {
						goto l35
					}
					goto l34
				l35:
					position, tokenIndex = position35, tokenIndex35
				}
				{
					position36, tokenIndex36 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l36
					}
					position++
					goto l37
				l36:
					position, tokenIndex = position36, tokenIndex36
				}
			l37:
				if !_rules[rule_]() {
					goto l32
				}
				add(ruleFieldList, position33)
			}
			return true
		l32:
			position, tokenIndex = position32, tokenIndex32
			return false
		},
		/* 7 FieldOrSpread <- <(SpreadField / Field)> */
		func() bool {
			position38, tokenIndex38 := position, tokenIndex
			{
				position39 := position
				{
					position40, tokenIndex40 := position, tokenIndex
					if !_rules[ruleSpreadField]() {
						goto l41
					}
					goto l40
				l41:
					position, tokenIndex = position40, tokenIndex40
					if !_rules[ruleField]() {
						goto l38
					}
				}
			l40:
				add(ruleFieldOrSpread, position39)
			}
			return true
		l38:
			position, tokenIndex = position38, tokenIndex38
			return false
		},
		/* 8 Field <- <(Attribute* _ (ComputedField / NamedField))> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
			l44:
				{
					position45, tokenIndex45 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l45
					}
					goto l44
				l45:
					position, tokenIndex = position45, tokenIndex45
				}
				if !_rules[rule_]() {
					goto l42
				}
				{
					position46, tokenIndex46 := position, tokenIndex
					if !_rules[ruleComputedField]() {
						goto l47
					}
					goto l46
				l47:
					position, tokenIndex = position46, tokenIndex46
					if !_rules[ruleNamedField]() {
						goto l42
					}
				}
			l46:
				add(ruleField, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 9 ComputedField <- <('[' _ Type _ ']' _ ':' _ Type _)> */
		func() bool {
			position48, tokenIndex48 := position, tokenIndex
			{
				position49 := position
				if buffer[position] != rune('[') {
					goto l48
				}
				position++
				if !_rules[rule_]() {
					goto l48
				}
				if !_rules[ruleType]() {
					goto l48
				}
				if !_rules[rule_]() {
					goto l48
				}
				if buffer[position] != rune(']') {
					goto l48
				}
				position++
				if !_rules[rule_]() {
					goto l48
				}
				if buffer[position] != rune(':') {
					goto l48
				}
				position++
				if !_rules[rule_]() {
					goto l48
				}
				if !_rules[ruleType]() {
					goto l48
				}
				if !_rules[rule_]() {
					goto l48
				}
				add(ruleComputedField, position49)
			}
			return true
		l48:
			position, tokenIndex = position48, tokenIndex48
			return false
		},
		/* 10 NamedField <- <(FieldName _ ':' _ Type _)> */
		func() bool {
			position50, tokenIndex50 := position, tokenIndex
			{
				position51 := position
				if !_rules[ruleFieldName]() {
					goto l50
				}
				if !_rules[rule_]() {
					goto l50
				}
				if buffer[position] != rune(':') {
					goto l50
				}
				position++
				if !_rules[rule_]() {
					goto l50
				}
				if !_rules[ruleType]() {
					goto l50
				}
				if !_rules[rule_]() {
					goto l50
				}
				add(ruleNamedField, position51)
			}
			return true
		l50:
			position, tokenIndex = position50, tokenIndex50
			return false
		},
		/* 11 SpreadField <- <(Attribute* _ ('.' '.' '.') _ Type _)> */
		func() bool {
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
			l54:
				{
					position55, tokenIndex55 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l55
					}
					goto l54
				l55:
					position, tokenIndex = position55, tokenIndex55
				}
				if !_rules[rule_]() {
					goto l52
				}
				if buffer[position] != rune('.') {
					goto l52
				}
				position++
				if buffer[position] != rune('.') {
					goto l52
				}
				position++
				if buffer[position] != rune('.') {
					goto l52
				}
				position++
				if !_rules[rule_]() {
					goto l52
				}
				if !_rules[ruleType]() {
					goto l52
				}
				if !_rules[rule_]() {
					goto l52
				}
				add(ruleSpreadField, position53)
			}
			return true
		l52:
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 12 FieldName <- <(Identifier '?'?)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if !_rules[ruleIdentifier]() {
					goto l56
				}
				{
					position58, tokenIndex58 := position, tokenIndex
					if buffer[position] != rune('?') {
						goto l58
					}
					position++
					goto l59
				l58:
					position, tokenIndex = position58, tokenIndex58
				}
			l59:
				add(ruleFieldName, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 13 EnumDef <- <('e' 'n' 'u' 'm' _ '(' _ Type _ ')' _ Identifier _ '{' _ EnumValueList? _ '}' _)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if buffer[position] != rune('e') {
					goto l60
				}
				position++
				if buffer[position] != rune('n') {
					goto l60
				}
				position++
				if buffer[position] != rune('u') {
					goto l60
				}
				position++
				if buffer[position] != rune('m') {
					goto l60
				}
				position++
				if !_rules[rule_]() {
					goto l60
				}
				if buffer[position] != rune('(') {
					goto l60
				}
				position++
				if !_rules[rule_]() {
					goto l60
				}
				if !_rules[ruleType]() {
					goto l60
				}
				if !_rules[rule_]() {
					goto l60
				}
				if buffer[position] != rune(')') {
					goto l60
				}
				position++
				if !_rules[rule_]() {
					goto l60
				}
				if !_rules[ruleIdentifier]() {
					goto l60
				}
				if !_rules[rule_]() {
					goto l60
				}
				if buffer[position] != rune('{') {
					goto l60
				}
				position++
				if !_rules[rule_]() {
					goto l60
				}
				{
					position62, tokenIndex62 := position, tokenIndex
					if !_rules[ruleEnumValueList]() {
						goto l62
					}
					goto l63
				l62:
					position, tokenIndex = position62, tokenIndex62
				}
			l63:
				if !_rules[rule_]() {
					goto l60
				}
				if buffer[position] != rune('}') {
					goto l60
				}
				position++
				if !_rules[rule_]() {
					goto l60
				}
				add(ruleEnumDef, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 14 EnumValueList <- <(EnumValue (',' _ EnumValue)* ','? _)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if !_rules[ruleEnumValue]() {
					goto l64
				}
			l66:
				{
					position67, tokenIndex67 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l67
					}
					position++
					if !_rules[rule_]() {
						goto l67
					}
					if !_rules[ruleEnumValue]() {
						goto l67
					}
					goto l66
				l67:
					position, tokenIndex = position67, tokenIndex67
				}
				{
					position68, tokenIndex68 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l68
					}
					position++
					goto l69
				l68:
					position, tokenIndex = position68, tokenIndex68
				}
			l69:
				if !_rules[rule_]() {
					goto l64
				}
				add(ruleEnumValueList, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 15 EnumValue <- <(Identifier _ '=' _ String _)> */
		func() bool {
			position70, tokenIndex70 := position, tokenIndex
			{
				position71 := position
				if !_rules[ruleIdentifier]() {
					goto l70
				}
				if !_rules[rule_]() {
					goto l70
				}
				if buffer[position] != rune('=') {
					goto l70
				}
				position++
				if !_rules[rule_]() {
					goto l70
				}
				if !_rules[ruleString]() {
					goto l70
				}
				if !_rules[rule_]() {
					goto l70
				}
				add(ruleEnumValue, position71)
			}
			return true
		l70:
			position, tokenIndex = position70, tokenIndex70
			return false
		},
		/* 16 DispatchStmt <- <('d' 'i' 's' 'p' 'a' 't' 'c' 'h' _ DispatchPath _ ('t' 'o') _ DispatchTarget _)> */
		func() bool {
			position72, tokenIndex72 := position, tokenIndex
			{
				position73 := position
				if buffer[position] != rune('d') {
					goto l72
				}
				position++
				if buffer[position] != rune('i') {
					goto l72
				}
				position++
				if buffer[position] != rune('s') {
					goto l72
				}
				position++
				if buffer[position] != rune('p') {
					goto l72
				}
				position++
				if buffer[position] != rune('a') {
					goto l72
				}
				position++
				if buffer[position] != rune('t') {
					goto l72
				}
				position++
				if buffer[position] != rune('c') {
					goto l72
				}
				position++
				if buffer[position] != rune('h') {
					goto l72
				}
				position++
				if !_rules[rule_]() {
					goto l72
				}
				if !_rules[ruleDispatchPath]() {
					goto l72
				}
				if !_rules[rule_]() {
					goto l72
				}
				if buffer[position] != rune('t') {
					goto l72
				}
				position++
				if buffer[position] != rune('o') {
					goto l72
				}
				position++
				if !_rules[rule_]() {
					goto l72
				}
				if !_rules[ruleDispatchTarget]() {
					goto l72
				}
				if !_rules[rule_]() {
					goto l72
				}
				add(ruleDispatchStmt, position73)
			}
			return true
		l72:
			position, tokenIndex = position72, tokenIndex72
			return false
		},
		/* 17 DispatchPath <- <('m' 'i' 'n' 'e' 'c' 'r' 'a' 'f' 't' ':' Identifier '[' DispatchKeyList ']')> */
		func() bool {
			position74, tokenIndex74 := position, tokenIndex
			{
				position75 := position
				if buffer[position] != rune('m') {
					goto l74
				}
				position++
				if buffer[position] != rune('i') {
					goto l74
				}
				position++
				if buffer[position] != rune('n') {
					goto l74
				}
				position++
				if buffer[position] != rune('e') {
					goto l74
				}
				position++
				if buffer[position] != rune('c') {
					goto l74
				}
				position++
				if buffer[position] != rune('r') {
					goto l74
				}
				position++
				if buffer[position] != rune('a') {
					goto l74
				}
				position++
				if buffer[position] != rune('f') {
					goto l74
				}
				position++
				if buffer[position] != rune('t') {
					goto l74
				}
				position++
				if buffer[position] != rune(':') {
					goto l74
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l74
				}
				if buffer[position] != rune('[') {
					goto l74
				}
				position++
				if !_rules[ruleDispatchKeyList]() {
					goto l74
				}
				if buffer[position] != rune(']') {
					goto l74
				}
				position++
				add(ruleDispatchPath, position75)
			}
			return true
		l74:
			position, tokenIndex = position74, tokenIndex74
			return false
		},
		/* 18 DispatchKeyList <- <(DispatchKey (',' DispatchKey)*)> */
		func() bool {
			position76, tokenIndex76 := position, tokenIndex
			{
				position77 := position
				if !_rules[ruleDispatchKey]() {
					goto l76
				}
			l78:
				{
					position79, tokenIndex79 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l79
					}
					position++
					if !_rules[ruleDispatchKey]() {
						goto l79
					}
					goto l78
				l79:
					position, tokenIndex = position79, tokenIndex79
				}
				add(ruleDispatchKeyList, position77)
			}
			return true
		l76:
			position, tokenIndex = position76, tokenIndex76
			return false
		},
		/* 19 DispatchKey <- <(StaticIndexKey / Identifier)> */
		func() bool {
			position80, tokenIndex80 := position, tokenIndex
			{
				position81 := position
				{
					position82, tokenIndex82 := position, tokenIndex
					if !_rules[ruleStaticIndexKey]() {
						goto l83
					}
					goto l82
				l83:
					position, tokenIndex = position82, tokenIndex82
					if !_rules[ruleIdentifier]() {
						goto l80
					}
				}
			l82:
				add(ruleDispatchKey, position81)
			}
			return true
		l80:
			position, tokenIndex = position80, tokenIndex80
			return false
		},
		/* 20 DispatchTarget <- <(('s' 't' 'r' 'u' 'c' 't' _ Identifier _ '{' _ FieldList? _ '}') / Type)> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				{
					position86, tokenIndex86 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l87
					}
					position++
					if buffer[position] != rune('t') {
						goto l87
					}
					position++
					if buffer[position] != rune('r') {
						goto l87
					}
					position++
					if buffer[position] != rune('u') {
						goto l87
					}
					position++
					if buffer[position] != rune('c') {
						goto l87
					}
					position++
					if buffer[position] != rune('t') {
						goto l87
					}
					position++
					if !_rules[rule_]() {
						goto l87
					}
					if !_rules[ruleIdentifier]() {
						goto l87
					}
					if !_rules[rule_]() {
						goto l87
					}
					if buffer[position] != rune('{') {
						goto l87
					}
					position++
					if !_rules[rule_]() {
						goto l87
					}
					{
						position88, tokenIndex88 := position, tokenIndex
						if !_rules[ruleFieldList]() {
							goto l88
						}
						goto l89
					l88:
						position, tokenIndex = position88, tokenIndex88
					}
				l89:
					if !_rules[rule_]() {
						goto l87
					}
					if buffer[position] != rune('}') {
						goto l87
					}
					position++
					goto l86
				l87:
					position, tokenIndex = position86, tokenIndex86
					if !_rules[ruleType]() {
						goto l84
					}
				}
			l86:
				add(ruleDispatchTarget, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 21 SpreadStruct <- <('.' '.' '.' _ ('s' 't' 'r' 'u' 'c' 't') _ Identifier _ '{' _ FieldList? _ '}' _)> */
		nil,
		/* 22 Type <- <(UnionType / AttributedType / ArrayType / StructType / ConstrainedType / PrimitiveType / ReferenceType / LiteralType)> */
		func() bool {
			position91, tokenIndex91 := position, tokenIndex
			{
				position92 := position
				{
					position93, tokenIndex93 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l94
					}
					goto l93
				l94:
					position, tokenIndex = position93, tokenIndex93
					if !_rules[ruleAttributedType]() {
						goto l95
					}
					goto l93
				l95:
					position, tokenIndex = position93, tokenIndex93
					if !_rules[ruleArrayType]() {
						goto l96
					}
					goto l93
				l96:
					position, tokenIndex = position93, tokenIndex93
					if !_rules[ruleStructType]() {
						goto l97
					}
					goto l93
				l97:
					position, tokenIndex = position93, tokenIndex93
					if !_rules[ruleConstrainedType]() {
						goto l98
					}
					goto l93
				l98:
					position, tokenIndex = position93, tokenIndex93
					if !_rules[rulePrimitiveType]() {
						goto l99
					}
					goto l93
				l99:
					position, tokenIndex = position93, tokenIndex93
					if !_rules[ruleReferenceType]() {
						goto l100
					}
					goto l93
				l100:
					position, tokenIndex = position93, tokenIndex93
					if !_rules[ruleLiteralType]() {
						goto l91
					}
				}
			l93:
				add(ruleType, position92)
			}
			return true
		l91:
			position, tokenIndex = position91, tokenIndex91
			return false
		},
		/* 23 AttributedType <- <(Attribute+ _ (ArrayType / ConstrainedType / StructType / PrimitiveType / ReferenceType / LiteralType))> */
		func() bool {
			position101, tokenIndex101 := position, tokenIndex
			{
				position102 := position
				if !_rules[ruleAttribute]() {
					goto l101
				}
			l103:
				{
					position104, tokenIndex104 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l104
					}
					goto l103
				l104:
					position, tokenIndex = position104, tokenIndex104
				}
				if !_rules[rule_]() {
					goto l101
				}
				{
					position105, tokenIndex105 := position, tokenIndex
					if !_rules[ruleArrayType]() {
						goto l106
					}
					goto l105
				l106:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleConstrainedType]() {
						goto l107
					}
					goto l105
				l107:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleStructType]() {
						goto l108
					}
					goto l105
				l108:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[rulePrimitiveType]() {
						goto l109
					}
					goto l105
				l109:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleReferenceType]() {
						goto l110
					}
					goto l105
				l110:
					position, tokenIndex = position105, tokenIndex105
					if !_rules[ruleLiteralType]() {
						goto l101
					}
				}
			l105:
				add(ruleAttributedType, position102)
			}
			return true
		l101:
			position, tokenIndex = position101, tokenIndex101
			return false
		},
		/* 24 ConstrainedType <- <((PrimitiveType / ReferenceType / LiteralType) _ ArrayConstraint)> */
		func() bool {
			position111, tokenIndex111 := position, tokenIndex
			{
				position112 := position
				{
					position113, tokenIndex113 := position, tokenIndex
					if !_rules[rulePrimitiveType]() {
						goto l114
					}
					goto l113
				l114:
					position, tokenIndex = position113, tokenIndex113
					if !_rules[ruleReferenceType]() {
						goto l115
					}
					goto l113
				l115:
					position, tokenIndex = position113, tokenIndex113
					if !_rules[ruleLiteralType]() {
						goto l111
					}
				}
			l113:
				if !_rules[rule_]() {
					goto l111
				}
				if !_rules[ruleArrayConstraint]() {
					goto l111
				}
				add(ruleConstrainedType, position112)
			}
			return true
		l111:
			position, tokenIndex = position111, tokenIndex111
			return false
		},
		/* 25 UnionType <- <('(' _ Type (_ '|' _ Type)* (_ '|')? _ ')')> */
		func() bool {
			position116, tokenIndex116 := position, tokenIndex
			{
				position117 := position
				if buffer[position] != rune('(') {
					goto l116
				}
				position++
				if !_rules[rule_]() {
					goto l116
				}
				if !_rules[ruleType]() {
					goto l116
				}
			l118:
				{
					position119, tokenIndex119 := position, tokenIndex
					if !_rules[rule_]() {
						goto l119
					}
					if buffer[position] != rune('|') {
						goto l119
					}
					position++
					if !_rules[rule_]() {
						goto l119
					}
					if !_rules[ruleType]() {
						goto l119
					}
					goto l118
				l119:
					position, tokenIndex = position119, tokenIndex119
				}
				{
					position120, tokenIndex120 := position, tokenIndex
					if !_rules[rule_]() {
						goto l120
					}
					if buffer[position] != rune('|') {
						goto l120
					}
					position++
					goto l121
				l120:
					position, tokenIndex = position120, tokenIndex120
				}
			l121:
				if !_rules[rule_]() {
					goto l116
				}
				if buffer[position] != rune(')') {
					goto l116
				}
				position++
				add(ruleUnionType, position117)
			}
			return true
		l116:
			position, tokenIndex = position116, tokenIndex116
			return false
		},
		/* 26 ArrayType <- <('[' _ Type _ ']' _ ArrayConstraint?)> */
		func() bool {
			position122, tokenIndex122 := position, tokenIndex
			{
				position123 := position
				if buffer[position] != rune('[') {
					goto l122
				}
				position++
				if !_rules[rule_]() {
					goto l122
				}
				if !_rules[ruleType]() {
					goto l122
				}
				if !_rules[rule_]() {
					goto l122
				}
				if buffer[position] != rune(']') {
					goto l122
				}
				position++
				if !_rules[rule_]() {
					goto l122
				}
				{
					position124, tokenIndex124 := position, tokenIndex
					if !_rules[ruleArrayConstraint]() {
						goto l124
					}
					goto l125
				l124:
					position, tokenIndex = position124, tokenIndex124
				}
			l125:
				add(ruleArrayType, position123)
			}
			return true
		l122:
			position, tokenIndex = position122, tokenIndex122
			return false
		},
		/* 27 StructType <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier? _ '{' _ FieldList? _ '}')> */
		func() bool {
			position126, tokenIndex126 := position, tokenIndex
			{
				position127 := position
				if buffer[position] != rune('s') {
					goto l126
				}
				position++
				if buffer[position] != rune('t') {
					goto l126
				}
				position++
				if buffer[position] != rune('r') {
					goto l126
				}
				position++
				if buffer[position] != rune('u') {
					goto l126
				}
				position++
				if buffer[position] != rune('c') {
					goto l126
				}
				position++
				if buffer[position] != rune('t') {
					goto l126
				}
				position++
				if !_rules[rule_]() {
					goto l126
				}
				{
					position128, tokenIndex128 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l128
					}
					goto l129
				l128:
					position, tokenIndex = position128, tokenIndex128
				}
			l129:
				if !_rules[rule_]() {
					goto l126
				}
				if buffer[position] != rune('{') {
					goto l126
				}
				position++
				if !_rules[rule_]() {
					goto l126
				}
				{
					position130, tokenIndex130 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l130
					}
					goto l131
				l130:
					position, tokenIndex = position130, tokenIndex130
				}
			l131:
				if !_rules[rule_]() {
					goto l126
				}
				if buffer[position] != rune('}') {
					goto l126
				}
				position++
				add(ruleStructType, position127)
			}
			return true
		l126:
			position, tokenIndex = position126, tokenIndex126
			return false
		},
		/* 28 PrimitiveType <- <(('s' 't' 'r' 'i' 'n' 'g') / ('d' 'o' 'u' 'b' 'l' 'e') / ('f' 'l' 'o' 'a' 't') / ('i' 'n' 't') / ('b' 'o' 'o' 'l' 'e' 'a' 'n') / ('a' 'n' 'y'))> */
		func() bool {
			position132, tokenIndex132 := position, tokenIndex
			{
				position133 := position
				{
					position134, tokenIndex134 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l135
					}
					position++
					if buffer[position] != rune('t') {
						goto l135
					}
					position++
					if buffer[position] != rune('r') {
						goto l135
					}
					position++
					if buffer[position] != rune('i') {
						goto l135
					}
					position++
					if buffer[position] != rune('n') {
						goto l135
					}
					position++
					if buffer[position] != rune('g') {
						goto l135
					}
					position++
					goto l134
				l135:
					position, tokenIndex = position134, tokenIndex134
					if buffer[position] != rune('d') {
						goto l136
					}
					position++
					if buffer[position] != rune('o') {
						goto l136
					}
					position++
					if buffer[position] != rune('u') {
						goto l136
					}
					position++
					if buffer[position] != rune('b') {
						goto l136
					}
					position++
					if buffer[position] != rune('l') {
						goto l136
					}
					position++
					if buffer[position] != rune('e') {
						goto l136
					}
					position++
					goto l134
				l136:
					position, tokenIndex = position134, tokenIndex134
					if buffer[position] != rune('f') {
						goto l137
					}
					position++
					if buffer[position] != rune('l') {
						goto l137
					}
					position++
					if buffer[position] != rune('o') {
						goto l137
					}
					position++
					if buffer[position] != rune('a') {
						goto l137
					}
					position++
					if buffer[position] != rune('t') {
						goto l137
					}
					position++
					goto l134
				l137:
					position, tokenIndex = position134, tokenIndex134
					if buffer[position] != rune('i') {
						goto l138
					}
					position++
					if buffer[position] != rune('n') {
						goto l138
					}
					position++
					if buffer[position] != rune('t') {
						goto l138
					}
					position++
					goto l134
				l138:
					position, tokenIndex = position134, tokenIndex134
					if buffer[position] != rune('b') {
						goto l139
					}
					position++
					if buffer[position] != rune('o') {
						goto l139
					}
					position++
					if buffer[position] != rune('o') {
						goto l139
					}
					position++
					if buffer[position] != rune('l') {
						goto l139
					}
					position++
					if buffer[position] != rune('e') {
						goto l139
					}
					position++
					if buffer[position] != rune('a') {
						goto l139
					}
					position++
					if buffer[position] != rune('n') {
						goto l139
					}
					position++
					goto l134
				l139:
					position, tokenIndex = position134, tokenIndex134
					if buffer[position] != rune('a') {
						goto l132
					}
					position++
					if buffer[position] != rune('n') {
						goto l132
					}
					position++
					if buffer[position] != rune('y') {
						goto l132
					}
					position++
				}
			l134:
				add(rulePrimitiveType, position133)
			}
			return true
		l132:
			position, tokenIndex = position132, tokenIndex132
			return false
		},
		/* 29 ReferenceType <- <(ComplexReference / Identifier)> */
		func() bool {
			position140, tokenIndex140 := position, tokenIndex
			{
				position141 := position
				{
					position142, tokenIndex142 := position, tokenIndex
					if !_rules[ruleComplexReference]() {
						goto l143
					}
					goto l142
				l143:
					position, tokenIndex = position142, tokenIndex142
					if !_rules[ruleIdentifier]() {
						goto l140
					}
				}
			l142:
				add(ruleReferenceType, position141)
			}
			return true
		l140:
			position, tokenIndex = position140, tokenIndex140
			return false
		},
		/* 30 ComplexReference <- <(Identifier ':' Identifier (('[' '[' ComplexRefParam ']' ']') / ('[' ComplexRefParam ']')))> */
		func() bool {
			position144, tokenIndex144 := position, tokenIndex
			{
				position145 := position
				if !_rules[ruleIdentifier]() {
					goto l144
				}
				if buffer[position] != rune(':') {
					goto l144
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l144
				}
				{
					position146, tokenIndex146 := position, tokenIndex
					if buffer[position] != rune('[') {
						goto l147
					}
					position++
					if buffer[position] != rune('[') {
						goto l147
					}
					position++
					if !_rules[ruleComplexRefParam]() {
						goto l147
					}
					if buffer[position] != rune(']') {
						goto l147
					}
					position++
					if buffer[position] != rune(']') {
						goto l147
					}
					position++
					goto l146
				l147:
					position, tokenIndex = position146, tokenIndex146
					if buffer[position] != rune('[') {
						goto l144
					}
					position++
					if !_rules[ruleComplexRefParam]() {
						goto l144
					}
					if buffer[position] != rune(']') {
						goto l144
					}
					position++
				}
			l146:
				add(ruleComplexReference, position145)
			}
			return true
		l144:
			position, tokenIndex = position144, tokenIndex144
			return false
		},
		/* 31 ComplexRefParam <- <(StaticIndexKey / String / Identifier)> */
		func() bool {
			position148, tokenIndex148 := position, tokenIndex
			{
				position149 := position
				{
					position150, tokenIndex150 := position, tokenIndex
					if !_rules[ruleStaticIndexKey]() {
						goto l151
					}
					goto l150
				l151:
					position, tokenIndex = position150, tokenIndex150
					if !_rules[ruleString]() {
						goto l152
					}
					goto l150
				l152:
					position, tokenIndex = position150, tokenIndex150
					if !_rules[ruleIdentifier]() {
						goto l148
					}
				}
			l150:
				add(ruleComplexRefParam, position149)
			}
			return true
		l148:
			position, tokenIndex = position148, tokenIndex148
			return false
		},
		/* 32 StaticIndexKey <- <(('%' 'f' 'a' 'l' 'l' 'b' 'a' 'c' 'k') / ('%' 'k' 'e' 'y') / ('%' 'p' 'a' 'r' 'e' 'n' 't') / ('%' 'n' 'o' 'n' 'e') / ('%' 'u' 'n' 'k' 'n' 'o' 'w' 'n'))> */
		func() bool {
			position153, tokenIndex153 := position, tokenIndex
			{
				position154 := position
				{
					position155, tokenIndex155 := position, tokenIndex
					if buffer[position] != rune('%') {
						goto l156
					}
					position++
					if buffer[position] != rune('f') {
						goto l156
					}
					position++
					if buffer[position] != rune('a') {
						goto l156
					}
					position++
					if buffer[position] != rune('l') {
						goto l156
					}
					position++
					if buffer[position] != rune('l') {
						goto l156
					}
					position++
					if buffer[position] != rune('b') {
						goto l156
					}
					position++
					if buffer[position] != rune('a') {
						goto l156
					}
					position++
					if buffer[position] != rune('c') {
						goto l156
					}
					position++
					if buffer[position] != rune('k') {
						goto l156
					}
					position++
					goto l155
				l156:
					position, tokenIndex = position155, tokenIndex155
					if buffer[position] != rune('%') {
						goto l157
					}
					position++
					if buffer[position] != rune('k') {
						goto l157
					}
					position++
					if buffer[position] != rune('e') {
						goto l157
					}
					position++
					if buffer[position] != rune('y') {
						goto l157
					}
					position++
					goto l155
				l157:
					position, tokenIndex = position155, tokenIndex155
					if buffer[position] != rune('%') {
						goto l158
					}
					position++
					if buffer[position] != rune('p') {
						goto l158
					}
					position++
					if buffer[position] != rune('a') {
						goto l158
					}
					position++
					if buffer[position] != rune('r') {
						goto l158
					}
					position++
					if buffer[position] != rune('e') {
						goto l158
					}
					position++
					if buffer[position] != rune('n') {
						goto l158
					}
					position++
					if buffer[position] != rune('t') {
						goto l158
					}
					position++
					goto l155
				l158:
					position, tokenIndex = position155, tokenIndex155
					if buffer[position] != rune('%') {
						goto l159
					}
					position++
					if buffer[position] != rune('n') {
						goto l159
					}
					position++
					if buffer[position] != rune('o') {
						goto l159
					}
					position++
					if buffer[position] != rune('n') {
						goto l159
					}
					position++
					if buffer[position] != rune('e') {
						goto l159
					}
					position++
					goto l155
				l159:
					position, tokenIndex = position155, tokenIndex155
					if buffer[position] != rune('%') {
						goto l153
					}
					position++
					if buffer[position] != rune('u') {
						goto l153
					}
					position++
					if buffer[position] != rune('n') {
						goto l153
					}
					position++
					if buffer[position] != rune('k') {
						goto l153
					}
					position++
					if buffer[position] != rune('n') {
						goto l153
					}
					position++
					if buffer[position] != rune('o') {
						goto l153
					}
					position++
					if buffer[position] != rune('w') {
						goto l153
					}
					position++
					if buffer[position] != rune('n') {
						goto l153
					}
					position++
				}
			l155:
				add(ruleStaticIndexKey, position154)
			}
			return true
		l153:
			position, tokenIndex = position153, tokenIndex153
			return false
		},
		/* 33 LiteralType <- <(String / Number / Boolean)> */
		func() bool {
			position160, tokenIndex160 := position, tokenIndex
			{
				position161 := position
				{
					position162, tokenIndex162 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l163
					}
					goto l162
				l163:
					position, tokenIndex = position162, tokenIndex162
					if !_rules[ruleNumber]() {
						goto l164
					}
					goto l162
				l164:
					position, tokenIndex = position162, tokenIndex162
					if !_rules[ruleBoolean]() {
						goto l160
					}
				}
			l162:
				add(ruleLiteralType, position161)
			}
			return true
		l160:
			position, tokenIndex = position160, tokenIndex160
			return false
		},
		/* 34 ArrayConstraint <- <('@' _ (Range / Number))> */
		func() bool {
			position165, tokenIndex165 := position, tokenIndex
			{
				position166 := position
				if buffer[position] != rune('@') {
					goto l165
				}
				position++
				if !_rules[rule_]() {
					goto l165
				}
				{
					position167, tokenIndex167 := position, tokenIndex
					if !_rules[ruleRange]() {
						goto l168
					}
					goto l167
				l168:
					position, tokenIndex = position167, tokenIndex167
					if !_rules[ruleNumber]() {
						goto l165
					}
				}
			l167:
				add(ruleArrayConstraint, position166)
			}
			return true
		l165:
			position, tokenIndex = position165, tokenIndex165
			return false
		},
		/* 35 Range <- <(Number ('.' '.') Number?)> */
		func() bool {
			position169, tokenIndex169 := position, tokenIndex
			{
				position170 := position
				if !_rules[ruleNumber]() {
					goto l169
				}
				if buffer[position] != rune('.') {
					goto l169
				}
				position++
				if buffer[position] != rune('.') {
					goto l169
				}
				position++
				{
					position171, tokenIndex171 := position, tokenIndex
					if !_rules[ruleNumber]() {
						goto l171
					}
					goto l172
				l171:
					position, tokenIndex = position171, tokenIndex171
				}
			l172:
				add(ruleRange, position170)
			}
			return true
		l169:
			position, tokenIndex = position169, tokenIndex169
			return false
		},
		/* 36 Attribute <- <('#' '[' _ AttributeList _ ']' _)> */
		func() bool {
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				if buffer[position] != rune('#') {
					goto l173
				}
				position++
				if buffer[position] != rune('[') {
					goto l173
				}
				position++
				if !_rules[rule_]() {
					goto l173
				}
				if !_rules[ruleAttributeList]() {
					goto l173
				}
				if !_rules[rule_]() {
					goto l173
				}
				if buffer[position] != rune(']') {
					goto l173
				}
				position++
				if !_rules[rule_]() {
					goto l173
				}
				add(ruleAttribute, position174)
			}
			return true
		l173:
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 37 AttributeList <- <(AttributeItem (',' _ AttributeItem)*)> */
		func() bool {
			position175, tokenIndex175 := position, tokenIndex
			{
				position176 := position
				if !_rules[ruleAttributeItem]() {
					goto l175
				}
			l177:
				{
					position178, tokenIndex178 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l178
					}
					position++
					if !_rules[rule_]() {
						goto l178
					}
					if !_rules[ruleAttributeItem]() {
						goto l178
					}
					goto l177
				l178:
					position, tokenIndex = position178, tokenIndex178
				}
				add(ruleAttributeList, position176)
			}
			return true
		l175:
			position, tokenIndex = position175, tokenIndex175
			return false
		},
		/* 38 AttributeItem <- <(AttributePair / AttributeCall / Identifier)> */
		func() bool {
			position179, tokenIndex179 := position, tokenIndex
			{
				position180 := position
				{
					position181, tokenIndex181 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l182
					}
					goto l181
				l182:
					position, tokenIndex = position181, tokenIndex181
					if !_rules[ruleAttributeCall]() {
						goto l183
					}
					goto l181
				l183:
					position, tokenIndex = position181, tokenIndex181
					if !_rules[ruleIdentifier]() {
						goto l179
					}
				}
			l181:
				add(ruleAttributeItem, position180)
			}
			return true
		l179:
			position, tokenIndex = position179, tokenIndex179
			return false
		},
		/* 39 AttributeCall <- <(Identifier '(' _ AttributeParamList? _ ')')> */
		func() bool {
			position184, tokenIndex184 := position, tokenIndex
			{
				position185 := position
				if !_rules[ruleIdentifier]() {
					goto l184
				}
				if buffer[position] != rune('(') {
					goto l184
				}
				position++
				if !_rules[rule_]() {
					goto l184
				}
				{
					position186, tokenIndex186 := position, tokenIndex
					if !_rules[ruleAttributeParamList]() {
						goto l186
					}
					goto l187
				l186:
					position, tokenIndex = position186, tokenIndex186
				}
			l187:
				if !_rules[rule_]() {
					goto l184
				}
				if buffer[position] != rune(')') {
					goto l184
				}
				position++
				add(ruleAttributeCall, position185)
			}
			return true
		l184:
			position, tokenIndex = position184, tokenIndex184
			return false
		},
		/* 40 AttributeParamList <- <(AttributeParam (_ ',' _ AttributeParam)*)> */
		func() bool {
			position188, tokenIndex188 := position, tokenIndex
			{
				position189 := position
				if !_rules[ruleAttributeParam]() {
					goto l188
				}
			l190:
				{
					position191, tokenIndex191 := position, tokenIndex
					if !_rules[rule_]() {
						goto l191
					}
					if buffer[position] != rune(',') {
						goto l191
					}
					position++
					if !_rules[rule_]() {
						goto l191
					}
					if !_rules[ruleAttributeParam]() {
						goto l191
					}
					goto l190
				l191:
					position, tokenIndex = position191, tokenIndex191
				}
				add(ruleAttributeParamList, position189)
			}
			return true
		l188:
			position, tokenIndex = position188, tokenIndex188
			return false
		},
		/* 41 AttributeParam <- <(AttributePair / AttributeValue)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194, tokenIndex194 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l195
					}
					goto l194
				l195:
					position, tokenIndex = position194, tokenIndex194
					if !_rules[ruleAttributeValue]() {
						goto l192
					}
				}
			l194:
				add(ruleAttributeParam, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 42 AttributePair <- <(Identifier '=' AttributeValue)> */
		func() bool {
			position196, tokenIndex196 := position, tokenIndex
			{
				position197 := position
				if !_rules[ruleIdentifier]() {
					goto l196
				}
				if buffer[position] != rune('=') {
					goto l196
				}
				position++
				if !_rules[ruleAttributeValue]() {
					goto l196
				}
				add(ruleAttributePair, position197)
			}
			return true
		l196:
			position, tokenIndex = position196, tokenIndex196
			return false
		},
		/* 43 AttributeValue <- <(ArrayLiteral / String / Number / Boolean / Identifier)> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				{
					position200, tokenIndex200 := position, tokenIndex
					if !_rules[ruleArrayLiteral]() {
						goto l201
					}
					goto l200
				l201:
					position, tokenIndex = position200, tokenIndex200
					if !_rules[ruleString]() {
						goto l202
					}
					goto l200
				l202:
					position, tokenIndex = position200, tokenIndex200
					if !_rules[ruleNumber]() {
						goto l203
					}
					goto l200
				l203:
					position, tokenIndex = position200, tokenIndex200
					if !_rules[ruleBoolean]() {
						goto l204
					}
					goto l200
				l204:
					position, tokenIndex = position200, tokenIndex200
					if !_rules[ruleIdentifier]() {
						goto l198
					}
				}
			l200:
				add(ruleAttributeValue, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 44 ArrayLiteral <- <('[' _ (AttributeValue (_ ',' _ AttributeValue)*)? _ ']')> */
		func() bool {
			position205, tokenIndex205 := position, tokenIndex
			{
				position206 := position
				if buffer[position] != rune('[') {
					goto l205
				}
				position++
				if !_rules[rule_]() {
					goto l205
				}
				{
					position207, tokenIndex207 := position, tokenIndex
					if !_rules[ruleAttributeValue]() {
						goto l207
					}
				l209:
					{
						position210, tokenIndex210 := position, tokenIndex
						if !_rules[rule_]() {
							goto l210
						}
						if buffer[position] != rune(',') {
							goto l210
						}
						position++
						if !_rules[rule_]() {
							goto l210
						}
						if !_rules[ruleAttributeValue]() {
							goto l210
						}
						goto l209
					l210:
						position, tokenIndex = position210, tokenIndex210
					}
					goto l208
				l207:
					position, tokenIndex = position207, tokenIndex207
				}
			l208:
				if !_rules[rule_]() {
					goto l205
				}
				if buffer[position] != rune(']') {
					goto l205
				}
				position++
				add(ruleArrayLiteral, position206)
			}
			return true
		l205:
			position, tokenIndex = position205, tokenIndex205
			return false
		},
		/* 45 Comment <- <('/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position211, tokenIndex211 := position, tokenIndex
			{
				position212 := position
				if buffer[position] != rune('/') {
					goto l211
				}
				position++
				if buffer[position] != rune('/') {
					goto l211
				}
				position++
			l213:
				{
					position214, tokenIndex214 := position, tokenIndex
					{
						position215, tokenIndex215 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l215
						}
						goto l214
					l215:
						position, tokenIndex = position215, tokenIndex215
					}
					if !matchDot() {
						goto l214
					}
					goto l213
				l214:
					position, tokenIndex = position214, tokenIndex214
				}
				{
					position216, tokenIndex216 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l217
					}
					goto l216
				l217:
					position, tokenIndex = position216, tokenIndex216
					{
						position218, tokenIndex218 := position, tokenIndex
						if !matchDot() {
							goto l218
						}
						goto l211
					l218:
						position, tokenIndex = position218, tokenIndex218
					}
				}
			l216:
				add(ruleComment, position212)
			}
			return true
		l211:
			position, tokenIndex = position211, tokenIndex211
			return false
		},
		/* 46 DocComment <- <('/' '/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if buffer[position] != rune('/') {
					goto l219
				}
				position++
				if buffer[position] != rune('/') {
					goto l219
				}
				position++
				if buffer[position] != rune('/') {
					goto l219
				}
				position++
			l221:
				{
					position222, tokenIndex222 := position, tokenIndex
					{
						position223, tokenIndex223 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l223
						}
						goto l222
					l223:
						position, tokenIndex = position223, tokenIndex223
					}
					if !matchDot() {
						goto l222
					}
					goto l221
				l222:
					position, tokenIndex = position222, tokenIndex222
				}
				{
					position224, tokenIndex224 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l225
					}
					goto l224
				l225:
					position, tokenIndex = position224, tokenIndex224
					{
						position226, tokenIndex226 := position, tokenIndex
						if !matchDot() {
							goto l226
						}
						goto l219
					l226:
						position, tokenIndex = position226, tokenIndex226
					}
				}
			l224:
				add(ruleDocComment, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 47 Identifier <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')*)> */
		func() bool {
			position227, tokenIndex227 := position, tokenIndex
			{
				position228 := position
				{
					position229, tokenIndex229 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l230
					}
					position++
					goto l229
				l230:
					position, tokenIndex = position229, tokenIndex229
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l231
					}
					position++
					goto l229
				l231:
					position, tokenIndex = position229, tokenIndex229
					if buffer[position] != rune('_') {
						goto l227
					}
					position++
				}
			l229:
			l232:
				{
					position233, tokenIndex233 := position, tokenIndex
					{
						position234, tokenIndex234 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l235
						}
						position++
						goto l234
					l235:
						position, tokenIndex = position234, tokenIndex234
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l236
						}
						position++
						goto l234
					l236:
						position, tokenIndex = position234, tokenIndex234
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l237
						}
						position++
						goto l234
					l237:
						position, tokenIndex = position234, tokenIndex234
						if buffer[position] != rune('_') {
							goto l233
						}
						position++
					}
				l234:
					goto l232
				l233:
					position, tokenIndex = position233, tokenIndex233
				}
				add(ruleIdentifier, position228)
			}
			return true
		l227:
			position, tokenIndex = position227, tokenIndex227
			return false
		},
		/* 48 String <- <('"' (!'"' .)* '"')> */
		func() bool {
			position238, tokenIndex238 := position, tokenIndex
			{
				position239 := position
				if buffer[position] != rune('"') {
					goto l238
				}
				position++
			l240:
				{
					position241, tokenIndex241 := position, tokenIndex
					{
						position242, tokenIndex242 := position, tokenIndex
						if buffer[position] != rune('"') {
							goto l242
						}
						position++
						goto l241
					l242:
						position, tokenIndex = position242, tokenIndex242
					}
					if !matchDot() {
						goto l241
					}
					goto l240
				l241:
					position, tokenIndex = position241, tokenIndex241
				}
				if buffer[position] != rune('"') {
					goto l238
				}
				position++
				add(ruleString, position239)
			}
			return true
		l238:
			position, tokenIndex = position238, tokenIndex238
			return false
		},
		/* 49 Number <- <('-'? [0-9]+ ('.' [0-9]+)?)> */
		func() bool {
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position245, tokenIndex245 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l245
					}
					position++
					goto l246
				l245:
					position, tokenIndex = position245, tokenIndex245
				}
			l246:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l243
				}
				position++
			l247:
				{
					position248, tokenIndex248 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l248
					}
					position++
					goto l247
				l248:
					position, tokenIndex = position248, tokenIndex248
				}
				{
					position249, tokenIndex249 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l249
					}
					position++
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l249
					}
					position++
				l251:
					{
						position252, tokenIndex252 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l252
						}
						position++
						goto l251
					l252:
						position, tokenIndex = position252, tokenIndex252
					}
					goto l250
				l249:
					position, tokenIndex = position249, tokenIndex249
				}
			l250:
				add(ruleNumber, position244)
			}
			return true
		l243:
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 50 Boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		func() bool {
			position253, tokenIndex253 := position, tokenIndex
			{
				position254 := position
				{
					position255, tokenIndex255 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l256
					}
					position++
					if buffer[position] != rune('r') {
						goto l256
					}
					position++
					if buffer[position] != rune('u') {
						goto l256
					}
					position++
					if buffer[position] != rune('e') {
						goto l256
					}
					position++
					goto l255
				l256:
					position, tokenIndex = position255, tokenIndex255
					if buffer[position] != rune('f') {
						goto l253
					}
					position++
					if buffer[position] != rune('a') {
						goto l253
					}
					position++
					if buffer[position] != rune('l') {
						goto l253
					}
					position++
					if buffer[position] != rune('s') {
						goto l253
					}
					position++
					if buffer[position] != rune('e') {
						goto l253
					}
					position++
				}
			l255:
				add(ruleBoolean, position254)
			}
			return true
		l253:
			position, tokenIndex = position253, tokenIndex253
			return false
		},
		/* 51 DoubleColon <- <(':' ':')> */
		func() bool {
			position257, tokenIndex257 := position, tokenIndex
			{
				position258 := position
				if buffer[position] != rune(':') {
					goto l257
				}
				position++
				if buffer[position] != rune(':') {
					goto l257
				}
				position++
				add(ruleDoubleColon, position258)
			}
			return true
		l257:
			position, tokenIndex = position257, tokenIndex257
			return false
		},
		/* 52 SingleColon <- <':'> */
		func() bool {
			position259, tokenIndex259 := position, tokenIndex
			{
				position260 := position
				if buffer[position] != rune(':') {
					goto l259
				}
				position++
				add(ruleSingleColon, position260)
			}
			return true
		l259:
			position, tokenIndex = position259, tokenIndex259
			return false
		},
		/* 53 _ <- <(' ' / '\t' / '\r' / '\n' / Comment / DocComment)*> */
		func() bool {
			{
				position262 := position
			l263:
				{
					position264, tokenIndex264 := position, tokenIndex
					{
						position265, tokenIndex265 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l266
						}
						position++
						goto l265
					l266:
						position, tokenIndex = position265, tokenIndex265
						if buffer[position] != rune('\t') {
							goto l267
						}
						position++
						goto l265
					l267:
						position, tokenIndex = position265, tokenIndex265
						if buffer[position] != rune('\r') {
							goto l268
						}
						position++
						goto l265
					l268:
						position, tokenIndex = position265, tokenIndex265
						if buffer[position] != rune('\n') {
							goto l269
						}
						position++
						goto l265
					l269:
						position, tokenIndex = position265, tokenIndex265
						if !_rules[ruleComment]() {
							goto l270
						}
						goto l265
					l270:
						position, tokenIndex = position265, tokenIndex265
						if !_rules[ruleDocComment]() {
							goto l264
						}
					}
				l265:
					goto l263
				l264:
					position, tokenIndex = position264, tokenIndex264
				}
				add(rule_, position262)
			}
			return true
		},
		/* 54 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position271, tokenIndex271 := position, tokenIndex
			{
				position272 := position
				{
					position273, tokenIndex273 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l274
					}
					position++
					if buffer[position] != rune('\n') {
						goto l274
					}
					position++
					goto l273
				l274:
					position, tokenIndex = position273, tokenIndex273
					if buffer[position] != rune('\n') {
						goto l275
					}
					position++
					goto l273
				l275:
					position, tokenIndex = position273, tokenIndex273
					if buffer[position] != rune('\r') {
						goto l271
					}
					position++
				}
			l273:
				add(ruleEOL, position272)
			}
			return true
		l271:
			position, tokenIndex = position271, tokenIndex271
			return false
		},
	}
	p.rules = _rules
	return nil
}
