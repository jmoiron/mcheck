package main

// Code generated by peg grammar.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleStart
	ruleStatement
	ruleUseStmt
	ruleUsePath
	ruleTypeAlias
	ruleTypeName
	ruleStructDef
	ruleFieldList
	ruleFieldOrSpread
	ruleField
	ruleComputedField
	ruleNamedField
	ruleSpreadField
	ruleFieldName
	ruleEnumDef
	ruleEnumValueList
	ruleEnumValue
	ruleDispatchStmt
	ruleDispatchPath
	ruleDispatchKeyList
	ruleDispatchKey
	ruleDispatchTarget
	ruleSpreadStruct
	ruleType
	ruleAttributedType
	ruleConstrainedType
	ruleUnionType
	ruleArrayType
	ruleStructType
	ruleGenericType
	ruleGenericTypeParams
	rulePrimitiveType
	ruleReferenceType
	ruleComplexReference
	ruleComplexRefParam
	ruleDottedStaticIndexKey
	ruleStaticIndexKey
	ruleLiteralType
	ruleArrayConstraint
	ruleRange
	ruleAttribute
	ruleAttributeList
	ruleAttributeItem
	ruleAttributeCall
	ruleAttributeParamList
	ruleAttributeParam
	ruleAttributePair
	ruleAttributeValue
	ruleArrayLiteral
	ruleComment
	ruleDocComment
	ruleIdentifier
	ruleString
	ruleNumber
	ruleBoolean
	ruleLBRACE
	ruleRBRACE
	ruleLBRACKET
	ruleRBRACKET
	ruleLPAREN
	ruleRPAREN
	ruleCOMMA
	ruleCOLON
	ruleSEMICOLON
	ruleEQUALS
	rulePIPE
	ruleDOT
	ruleSPREAD
	ruleAT
	ruleLT
	ruleRT
	ruleDoubleColon
	ruleSingleColon
	rule_
	ruleEOL
)

var rul3s = [...]string{
	"Unknown",
	"Start",
	"Statement",
	"UseStmt",
	"UsePath",
	"TypeAlias",
	"TypeName",
	"StructDef",
	"FieldList",
	"FieldOrSpread",
	"Field",
	"ComputedField",
	"NamedField",
	"SpreadField",
	"FieldName",
	"EnumDef",
	"EnumValueList",
	"EnumValue",
	"DispatchStmt",
	"DispatchPath",
	"DispatchKeyList",
	"DispatchKey",
	"DispatchTarget",
	"SpreadStruct",
	"Type",
	"AttributedType",
	"ConstrainedType",
	"UnionType",
	"ArrayType",
	"StructType",
	"GenericType",
	"GenericTypeParams",
	"PrimitiveType",
	"ReferenceType",
	"ComplexReference",
	"ComplexRefParam",
	"DottedStaticIndexKey",
	"StaticIndexKey",
	"LiteralType",
	"ArrayConstraint",
	"Range",
	"Attribute",
	"AttributeList",
	"AttributeItem",
	"AttributeCall",
	"AttributeParamList",
	"AttributeParam",
	"AttributePair",
	"AttributeValue",
	"ArrayLiteral",
	"Comment",
	"DocComment",
	"Identifier",
	"String",
	"Number",
	"Boolean",
	"LBRACE",
	"RBRACE",
	"LBRACKET",
	"RBRACKET",
	"LPAREN",
	"RPAREN",
	"COMMA",
	"COLON",
	"SEMICOLON",
	"EQUALS",
	"PIPE",
	"DOT",
	"SPREAD",
	"AT",
	"LT",
	"RT",
	"DoubleColon",
	"SingleColon",
	"_",
	"EOL",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type MCDocParser struct {
	Buffer string
	buffer []rune
	rules  [76]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *MCDocParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *MCDocParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *MCDocParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *MCDocParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *MCDocParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *MCDocParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *MCDocParser) Init(options ...func(*MCDocParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Start <- <(_ Statement* _ !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule_]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleStatement]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[rule_]() {
					goto l0
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !matchDot() {
						goto l4
					}
					goto l0
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
				add(ruleStart, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Statement <- <(Attribute* _ (UseStmt / TypeAlias / StructDef / EnumDef / DispatchStmt) _)> */
		func() bool {
			position5, tokenIndex5 := position, tokenIndex
			{
				position6 := position
			l7:
				{
					position8, tokenIndex8 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l8
					}
					goto l7
				l8:
					position, tokenIndex = position8, tokenIndex8
				}
				if !_rules[rule_]() {
					goto l5
				}
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[ruleUseStmt]() {
						goto l10
					}
					goto l9
				l10:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleTypeAlias]() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleStructDef]() {
						goto l12
					}
					goto l9
				l12:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleEnumDef]() {
						goto l13
					}
					goto l9
				l13:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleDispatchStmt]() {
						goto l5
					}
				}
			l9:
				if !_rules[rule_]() {
					goto l5
				}
				add(ruleStatement, position6)
			}
			return true
		l5:
			position, tokenIndex = position5, tokenIndex5
			return false
		},
		/* 2 UseStmt <- <('u' 's' 'e' _ UsePath)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if buffer[position] != rune('u') {
					goto l14
				}
				position++
				if buffer[position] != rune('s') {
					goto l14
				}
				position++
				if buffer[position] != rune('e') {
					goto l14
				}
				position++
				if !_rules[rule_]() {
					goto l14
				}
				if !_rules[ruleUsePath]() {
					goto l14
				}
				add(ruleUseStmt, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 3 UsePath <- <((DoubleColon Identifier (DoubleColon Identifier)*) / (Identifier ((DoubleColon Identifier) / (SingleColon Identifier))*))> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				{
					position18, tokenIndex18 := position, tokenIndex
					if !_rules[ruleDoubleColon]() {
						goto l19
					}
					if !_rules[ruleIdentifier]() {
						goto l19
					}
				l20:
					{
						position21, tokenIndex21 := position, tokenIndex
						if !_rules[ruleDoubleColon]() {
							goto l21
						}
						if !_rules[ruleIdentifier]() {
							goto l21
						}
						goto l20
					l21:
						position, tokenIndex = position21, tokenIndex21
					}
					goto l18
				l19:
					position, tokenIndex = position18, tokenIndex18
					if !_rules[ruleIdentifier]() {
						goto l16
					}
				l22:
					{
						position23, tokenIndex23 := position, tokenIndex
						{
							position24, tokenIndex24 := position, tokenIndex
							if !_rules[ruleDoubleColon]() {
								goto l25
							}
							if !_rules[ruleIdentifier]() {
								goto l25
							}
							goto l24
						l25:
							position, tokenIndex = position24, tokenIndex24
							if !_rules[ruleSingleColon]() {
								goto l23
							}
							if !_rules[ruleIdentifier]() {
								goto l23
							}
						}
					l24:
						goto l22
					l23:
						position, tokenIndex = position23, tokenIndex23
					}
				}
			l18:
				add(ruleUsePath, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 4 TypeAlias <- <('t' 'y' 'p' 'e' _ TypeName _ EQUALS Type)> */
		func() bool {
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				if buffer[position] != rune('t') {
					goto l26
				}
				position++
				if buffer[position] != rune('y') {
					goto l26
				}
				position++
				if buffer[position] != rune('p') {
					goto l26
				}
				position++
				if buffer[position] != rune('e') {
					goto l26
				}
				position++
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleTypeName]() {
					goto l26
				}
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleEQUALS]() {
					goto l26
				}
				if !_rules[ruleType]() {
					goto l26
				}
				add(ruleTypeAlias, position27)
			}
			return true
		l26:
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 5 TypeName <- <(GenericType / Identifier)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				{
					position30, tokenIndex30 := position, tokenIndex
					if !_rules[ruleGenericType]() {
						goto l31
					}
					goto l30
				l31:
					position, tokenIndex = position30, tokenIndex30
					if !_rules[ruleIdentifier]() {
						goto l28
					}
				}
			l30:
				add(ruleTypeName, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 6 StructDef <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier _ LBRACE FieldList? RBRACE)> */
		func() bool {
			position32, tokenIndex32 := position, tokenIndex
			{
				position33 := position
				if buffer[position] != rune('s') {
					goto l32
				}
				position++
				if buffer[position] != rune('t') {
					goto l32
				}
				position++
				if buffer[position] != rune('r') {
					goto l32
				}
				position++
				if buffer[position] != rune('u') {
					goto l32
				}
				position++
				if buffer[position] != rune('c') {
					goto l32
				}
				position++
				if buffer[position] != rune('t') {
					goto l32
				}
				position++
				if !_rules[rule_]() {
					goto l32
				}
				if !_rules[ruleIdentifier]() {
					goto l32
				}
				if !_rules[rule_]() {
					goto l32
				}
				if !_rules[ruleLBRACE]() {
					goto l32
				}
				{
					position34, tokenIndex34 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l34
					}
					goto l35
				l34:
					position, tokenIndex = position34, tokenIndex34
				}
			l35:
				if !_rules[ruleRBRACE]() {
					goto l32
				}
				add(ruleStructDef, position33)
			}
			return true
		l32:
			position, tokenIndex = position32, tokenIndex32
			return false
		},
		/* 7 FieldList <- <(FieldOrSpread (COMMA FieldOrSpread)* COMMA?)> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				if !_rules[ruleFieldOrSpread]() {
					goto l36
				}
			l38:
				{
					position39, tokenIndex39 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l39
					}
					if !_rules[ruleFieldOrSpread]() {
						goto l39
					}
					goto l38
				l39:
					position, tokenIndex = position39, tokenIndex39
				}
				{
					position40, tokenIndex40 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l40
					}
					goto l41
				l40:
					position, tokenIndex = position40, tokenIndex40
				}
			l41:
				add(ruleFieldList, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 8 FieldOrSpread <- <(SpreadField / Field)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				{
					position44, tokenIndex44 := position, tokenIndex
					if !_rules[ruleSpreadField]() {
						goto l45
					}
					goto l44
				l45:
					position, tokenIndex = position44, tokenIndex44
					if !_rules[ruleField]() {
						goto l42
					}
				}
			l44:
				add(ruleFieldOrSpread, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 9 Field <- <(Attribute* _ (ComputedField / NamedField))> */
		func() bool {
			position46, tokenIndex46 := position, tokenIndex
			{
				position47 := position
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l49
					}
					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				if !_rules[rule_]() {
					goto l46
				}
				{
					position50, tokenIndex50 := position, tokenIndex
					if !_rules[ruleComputedField]() {
						goto l51
					}
					goto l50
				l51:
					position, tokenIndex = position50, tokenIndex50
					if !_rules[ruleNamedField]() {
						goto l46
					}
				}
			l50:
				add(ruleField, position47)
			}
			return true
		l46:
			position, tokenIndex = position46, tokenIndex46
			return false
		},
		/* 10 ComputedField <- <(LBRACKET Type RBRACKET COLON Type)> */
		func() bool {
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
				if !_rules[ruleLBRACKET]() {
					goto l52
				}
				if !_rules[ruleType]() {
					goto l52
				}
				if !_rules[ruleRBRACKET]() {
					goto l52
				}
				if !_rules[ruleCOLON]() {
					goto l52
				}
				if !_rules[ruleType]() {
					goto l52
				}
				add(ruleComputedField, position53)
			}
			return true
		l52:
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 11 NamedField <- <(FieldName COLON Type)> */
		func() bool {
			position54, tokenIndex54 := position, tokenIndex
			{
				position55 := position
				if !_rules[ruleFieldName]() {
					goto l54
				}
				if !_rules[ruleCOLON]() {
					goto l54
				}
				if !_rules[ruleType]() {
					goto l54
				}
				add(ruleNamedField, position55)
			}
			return true
		l54:
			position, tokenIndex = position54, tokenIndex54
			return false
		},
		/* 12 SpreadField <- <(Attribute* _ SPREAD Type)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
			l58:
				{
					position59, tokenIndex59 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l59
					}
					goto l58
				l59:
					position, tokenIndex = position59, tokenIndex59
				}
				if !_rules[rule_]() {
					goto l56
				}
				if !_rules[ruleSPREAD]() {
					goto l56
				}
				if !_rules[ruleType]() {
					goto l56
				}
				add(ruleSpreadField, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 13 FieldName <- <(Identifier '?'? _)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if !_rules[ruleIdentifier]() {
					goto l60
				}
				{
					position62, tokenIndex62 := position, tokenIndex
					if buffer[position] != rune('?') {
						goto l62
					}
					position++
					goto l63
				l62:
					position, tokenIndex = position62, tokenIndex62
				}
			l63:
				if !_rules[rule_]() {
					goto l60
				}
				add(ruleFieldName, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 14 EnumDef <- <('e' 'n' 'u' 'm' _ LPAREN Type RPAREN Identifier _ LBRACE EnumValueList? RBRACE)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if buffer[position] != rune('e') {
					goto l64
				}
				position++
				if buffer[position] != rune('n') {
					goto l64
				}
				position++
				if buffer[position] != rune('u') {
					goto l64
				}
				position++
				if buffer[position] != rune('m') {
					goto l64
				}
				position++
				if !_rules[rule_]() {
					goto l64
				}
				if !_rules[ruleLPAREN]() {
					goto l64
				}
				if !_rules[ruleType]() {
					goto l64
				}
				if !_rules[ruleRPAREN]() {
					goto l64
				}
				if !_rules[ruleIdentifier]() {
					goto l64
				}
				if !_rules[rule_]() {
					goto l64
				}
				if !_rules[ruleLBRACE]() {
					goto l64
				}
				{
					position66, tokenIndex66 := position, tokenIndex
					if !_rules[ruleEnumValueList]() {
						goto l66
					}
					goto l67
				l66:
					position, tokenIndex = position66, tokenIndex66
				}
			l67:
				if !_rules[ruleRBRACE]() {
					goto l64
				}
				add(ruleEnumDef, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 15 EnumValueList <- <(EnumValue (COMMA EnumValue)* COMMA?)> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				if !_rules[ruleEnumValue]() {
					goto l68
				}
			l70:
				{
					position71, tokenIndex71 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l71
					}
					if !_rules[ruleEnumValue]() {
						goto l71
					}
					goto l70
				l71:
					position, tokenIndex = position71, tokenIndex71
				}
				{
					position72, tokenIndex72 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l72
					}
					goto l73
				l72:
					position, tokenIndex = position72, tokenIndex72
				}
			l73:
				add(ruleEnumValueList, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 16 EnumValue <- <(Attribute* _ Identifier _ EQUALS String)> */
		func() bool {
			position74, tokenIndex74 := position, tokenIndex
			{
				position75 := position
			l76:
				{
					position77, tokenIndex77 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l77
					}
					goto l76
				l77:
					position, tokenIndex = position77, tokenIndex77
				}
				if !_rules[rule_]() {
					goto l74
				}
				if !_rules[ruleIdentifier]() {
					goto l74
				}
				if !_rules[rule_]() {
					goto l74
				}
				if !_rules[ruleEQUALS]() {
					goto l74
				}
				if !_rules[ruleString]() {
					goto l74
				}
				add(ruleEnumValue, position75)
			}
			return true
		l74:
			position, tokenIndex = position74, tokenIndex74
			return false
		},
		/* 17 DispatchStmt <- <('d' 'i' 's' 'p' 'a' 't' 'c' 'h' _ DispatchPath _ ('t' 'o') _ DispatchTarget)> */
		func() bool {
			position78, tokenIndex78 := position, tokenIndex
			{
				position79 := position
				if buffer[position] != rune('d') {
					goto l78
				}
				position++
				if buffer[position] != rune('i') {
					goto l78
				}
				position++
				if buffer[position] != rune('s') {
					goto l78
				}
				position++
				if buffer[position] != rune('p') {
					goto l78
				}
				position++
				if buffer[position] != rune('a') {
					goto l78
				}
				position++
				if buffer[position] != rune('t') {
					goto l78
				}
				position++
				if buffer[position] != rune('c') {
					goto l78
				}
				position++
				if buffer[position] != rune('h') {
					goto l78
				}
				position++
				if !_rules[rule_]() {
					goto l78
				}
				if !_rules[ruleDispatchPath]() {
					goto l78
				}
				if !_rules[rule_]() {
					goto l78
				}
				if buffer[position] != rune('t') {
					goto l78
				}
				position++
				if buffer[position] != rune('o') {
					goto l78
				}
				position++
				if !_rules[rule_]() {
					goto l78
				}
				if !_rules[ruleDispatchTarget]() {
					goto l78
				}
				add(ruleDispatchStmt, position79)
			}
			return true
		l78:
			position, tokenIndex = position78, tokenIndex78
			return false
		},
		/* 18 DispatchPath <- <('m' 'i' 'n' 'e' 'c' 'r' 'a' 'f' 't' ':' Identifier LBRACKET DispatchKeyList RBRACKET (LT GenericTypeParams RT)?)> */
		func() bool {
			position80, tokenIndex80 := position, tokenIndex
			{
				position81 := position
				if buffer[position] != rune('m') {
					goto l80
				}
				position++
				if buffer[position] != rune('i') {
					goto l80
				}
				position++
				if buffer[position] != rune('n') {
					goto l80
				}
				position++
				if buffer[position] != rune('e') {
					goto l80
				}
				position++
				if buffer[position] != rune('c') {
					goto l80
				}
				position++
				if buffer[position] != rune('r') {
					goto l80
				}
				position++
				if buffer[position] != rune('a') {
					goto l80
				}
				position++
				if buffer[position] != rune('f') {
					goto l80
				}
				position++
				if buffer[position] != rune('t') {
					goto l80
				}
				position++
				if buffer[position] != rune(':') {
					goto l80
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l80
				}
				if !_rules[ruleLBRACKET]() {
					goto l80
				}
				if !_rules[ruleDispatchKeyList]() {
					goto l80
				}
				if !_rules[ruleRBRACKET]() {
					goto l80
				}
				{
					position82, tokenIndex82 := position, tokenIndex
					if !_rules[ruleLT]() {
						goto l82
					}
					if !_rules[ruleGenericTypeParams]() {
						goto l82
					}
					if !_rules[ruleRT]() {
						goto l82
					}
					goto l83
				l82:
					position, tokenIndex = position82, tokenIndex82
				}
			l83:
				add(ruleDispatchPath, position81)
			}
			return true
		l80:
			position, tokenIndex = position80, tokenIndex80
			return false
		},
		/* 19 DispatchKeyList <- <(DispatchKey (COMMA DispatchKey)* COMMA?)> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				if !_rules[ruleDispatchKey]() {
					goto l84
				}
			l86:
				{
					position87, tokenIndex87 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l87
					}
					if !_rules[ruleDispatchKey]() {
						goto l87
					}
					goto l86
				l87:
					position, tokenIndex = position87, tokenIndex87
				}
				{
					position88, tokenIndex88 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l88
					}
					goto l89
				l88:
					position, tokenIndex = position88, tokenIndex88
				}
			l89:
				add(ruleDispatchKeyList, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 20 DispatchKey <- <(StaticIndexKey / String / Identifier)> */
		func() bool {
			position90, tokenIndex90 := position, tokenIndex
			{
				position91 := position
				{
					position92, tokenIndex92 := position, tokenIndex
					if !_rules[ruleStaticIndexKey]() {
						goto l93
					}
					goto l92
				l93:
					position, tokenIndex = position92, tokenIndex92
					if !_rules[ruleString]() {
						goto l94
					}
					goto l92
				l94:
					position, tokenIndex = position92, tokenIndex92
					if !_rules[ruleIdentifier]() {
						goto l90
					}
				}
			l92:
				add(ruleDispatchKey, position91)
			}
			return true
		l90:
			position, tokenIndex = position90, tokenIndex90
			return false
		},
		/* 21 DispatchTarget <- <(('s' 't' 'r' 'u' 'c' 't' _ Identifier _ LBRACE FieldList? RBRACE) / Type)> */
		func() bool {
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				{
					position97, tokenIndex97 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l98
					}
					position++
					if buffer[position] != rune('t') {
						goto l98
					}
					position++
					if buffer[position] != rune('r') {
						goto l98
					}
					position++
					if buffer[position] != rune('u') {
						goto l98
					}
					position++
					if buffer[position] != rune('c') {
						goto l98
					}
					position++
					if buffer[position] != rune('t') {
						goto l98
					}
					position++
					if !_rules[rule_]() {
						goto l98
					}
					if !_rules[ruleIdentifier]() {
						goto l98
					}
					if !_rules[rule_]() {
						goto l98
					}
					if !_rules[ruleLBRACE]() {
						goto l98
					}
					{
						position99, tokenIndex99 := position, tokenIndex
						if !_rules[ruleFieldList]() {
							goto l99
						}
						goto l100
					l99:
						position, tokenIndex = position99, tokenIndex99
					}
				l100:
					if !_rules[ruleRBRACE]() {
						goto l98
					}
					goto l97
				l98:
					position, tokenIndex = position97, tokenIndex97
					if !_rules[ruleType]() {
						goto l95
					}
				}
			l97:
				add(ruleDispatchTarget, position96)
			}
			return true
		l95:
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 22 SpreadStruct <- <(SPREAD ('s' 't' 'r' 'u' 'c' 't') _ Identifier _ LBRACE FieldList? RBRACE)> */
		nil,
		/* 23 Type <- <(UnionType / AttributedType / ArrayType / StructType / ConstrainedType / GenericType / PrimitiveType / ReferenceType / LiteralType)> */
		func() bool {
			position102, tokenIndex102 := position, tokenIndex
			{
				position103 := position
				{
					position104, tokenIndex104 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l105
					}
					goto l104
				l105:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleAttributedType]() {
						goto l106
					}
					goto l104
				l106:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleArrayType]() {
						goto l107
					}
					goto l104
				l107:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleStructType]() {
						goto l108
					}
					goto l104
				l108:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleConstrainedType]() {
						goto l109
					}
					goto l104
				l109:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleGenericType]() {
						goto l110
					}
					goto l104
				l110:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[rulePrimitiveType]() {
						goto l111
					}
					goto l104
				l111:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleReferenceType]() {
						goto l112
					}
					goto l104
				l112:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleLiteralType]() {
						goto l102
					}
				}
			l104:
				add(ruleType, position103)
			}
			return true
		l102:
			position, tokenIndex = position102, tokenIndex102
			return false
		},
		/* 24 AttributedType <- <(Attribute+ _ (UnionType / ArrayType / ConstrainedType / StructType / GenericType / PrimitiveType / ReferenceType / LiteralType))> */
		func() bool {
			position113, tokenIndex113 := position, tokenIndex
			{
				position114 := position
				if !_rules[ruleAttribute]() {
					goto l113
				}
			l115:
				{
					position116, tokenIndex116 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l116
					}
					goto l115
				l116:
					position, tokenIndex = position116, tokenIndex116
				}
				if !_rules[rule_]() {
					goto l113
				}
				{
					position117, tokenIndex117 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l118
					}
					goto l117
				l118:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleArrayType]() {
						goto l119
					}
					goto l117
				l119:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleConstrainedType]() {
						goto l120
					}
					goto l117
				l120:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleStructType]() {
						goto l121
					}
					goto l117
				l121:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleGenericType]() {
						goto l122
					}
					goto l117
				l122:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[rulePrimitiveType]() {
						goto l123
					}
					goto l117
				l123:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleReferenceType]() {
						goto l124
					}
					goto l117
				l124:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleLiteralType]() {
						goto l113
					}
				}
			l117:
				add(ruleAttributedType, position114)
			}
			return true
		l113:
			position, tokenIndex = position113, tokenIndex113
			return false
		},
		/* 25 ConstrainedType <- <((PrimitiveType / ReferenceType / LiteralType) ArrayConstraint)> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				{
					position127, tokenIndex127 := position, tokenIndex
					if !_rules[rulePrimitiveType]() {
						goto l128
					}
					goto l127
				l128:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleReferenceType]() {
						goto l129
					}
					goto l127
				l129:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleLiteralType]() {
						goto l125
					}
				}
			l127:
				if !_rules[ruleArrayConstraint]() {
					goto l125
				}
				add(ruleConstrainedType, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 26 UnionType <- <(LPAREN Type (PIPE Type)* PIPE? RPAREN)> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				if !_rules[ruleLPAREN]() {
					goto l130
				}
				if !_rules[ruleType]() {
					goto l130
				}
			l132:
				{
					position133, tokenIndex133 := position, tokenIndex
					if !_rules[rulePIPE]() {
						goto l133
					}
					if !_rules[ruleType]() {
						goto l133
					}
					goto l132
				l133:
					position, tokenIndex = position133, tokenIndex133
				}
				{
					position134, tokenIndex134 := position, tokenIndex
					if !_rules[rulePIPE]() {
						goto l134
					}
					goto l135
				l134:
					position, tokenIndex = position134, tokenIndex134
				}
			l135:
				if !_rules[ruleRPAREN]() {
					goto l130
				}
				add(ruleUnionType, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 27 ArrayType <- <(LBRACKET Type RBRACKET ArrayConstraint?)> */
		func() bool {
			position136, tokenIndex136 := position, tokenIndex
			{
				position137 := position
				if !_rules[ruleLBRACKET]() {
					goto l136
				}
				if !_rules[ruleType]() {
					goto l136
				}
				if !_rules[ruleRBRACKET]() {
					goto l136
				}
				{
					position138, tokenIndex138 := position, tokenIndex
					if !_rules[ruleArrayConstraint]() {
						goto l138
					}
					goto l139
				l138:
					position, tokenIndex = position138, tokenIndex138
				}
			l139:
				add(ruleArrayType, position137)
			}
			return true
		l136:
			position, tokenIndex = position136, tokenIndex136
			return false
		},
		/* 28 StructType <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier? _ LBRACE FieldList? RBRACE)> */
		func() bool {
			position140, tokenIndex140 := position, tokenIndex
			{
				position141 := position
				if buffer[position] != rune('s') {
					goto l140
				}
				position++
				if buffer[position] != rune('t') {
					goto l140
				}
				position++
				if buffer[position] != rune('r') {
					goto l140
				}
				position++
				if buffer[position] != rune('u') {
					goto l140
				}
				position++
				if buffer[position] != rune('c') {
					goto l140
				}
				position++
				if buffer[position] != rune('t') {
					goto l140
				}
				position++
				if !_rules[rule_]() {
					goto l140
				}
				{
					position142, tokenIndex142 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l142
					}
					goto l143
				l142:
					position, tokenIndex = position142, tokenIndex142
				}
			l143:
				if !_rules[rule_]() {
					goto l140
				}
				if !_rules[ruleLBRACE]() {
					goto l140
				}
				{
					position144, tokenIndex144 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l144
					}
					goto l145
				l144:
					position, tokenIndex = position144, tokenIndex144
				}
			l145:
				if !_rules[ruleRBRACE]() {
					goto l140
				}
				add(ruleStructType, position141)
			}
			return true
		l140:
			position, tokenIndex = position140, tokenIndex140
			return false
		},
		/* 29 GenericType <- <(Identifier LT GenericTypeParams RT)> */
		func() bool {
			position146, tokenIndex146 := position, tokenIndex
			{
				position147 := position
				if !_rules[ruleIdentifier]() {
					goto l146
				}
				if !_rules[ruleLT]() {
					goto l146
				}
				if !_rules[ruleGenericTypeParams]() {
					goto l146
				}
				if !_rules[ruleRT]() {
					goto l146
				}
				add(ruleGenericType, position147)
			}
			return true
		l146:
			position, tokenIndex = position146, tokenIndex146
			return false
		},
		/* 30 GenericTypeParams <- <(Type (COMMA Type)*)> */
		func() bool {
			position148, tokenIndex148 := position, tokenIndex
			{
				position149 := position
				if !_rules[ruleType]() {
					goto l148
				}
			l150:
				{
					position151, tokenIndex151 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l151
					}
					if !_rules[ruleType]() {
						goto l151
					}
					goto l150
				l151:
					position, tokenIndex = position151, tokenIndex151
				}
				add(ruleGenericTypeParams, position149)
			}
			return true
		l148:
			position, tokenIndex = position148, tokenIndex148
			return false
		},
		/* 31 PrimitiveType <- <((('s' 't' 'r' 'i' 'n' 'g') / ('d' 'o' 'u' 'b' 'l' 'e') / ('f' 'l' 'o' 'a' 't') / ('i' 'n' 't') / ('b' 'o' 'o' 'l' 'e' 'a' 'n') / ('a' 'n' 'y')) _)> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				{
					position154, tokenIndex154 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l155
					}
					position++
					if buffer[position] != rune('t') {
						goto l155
					}
					position++
					if buffer[position] != rune('r') {
						goto l155
					}
					position++
					if buffer[position] != rune('i') {
						goto l155
					}
					position++
					if buffer[position] != rune('n') {
						goto l155
					}
					position++
					if buffer[position] != rune('g') {
						goto l155
					}
					position++
					goto l154
				l155:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('d') {
						goto l156
					}
					position++
					if buffer[position] != rune('o') {
						goto l156
					}
					position++
					if buffer[position] != rune('u') {
						goto l156
					}
					position++
					if buffer[position] != rune('b') {
						goto l156
					}
					position++
					if buffer[position] != rune('l') {
						goto l156
					}
					position++
					if buffer[position] != rune('e') {
						goto l156
					}
					position++
					goto l154
				l156:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('f') {
						goto l157
					}
					position++
					if buffer[position] != rune('l') {
						goto l157
					}
					position++
					if buffer[position] != rune('o') {
						goto l157
					}
					position++
					if buffer[position] != rune('a') {
						goto l157
					}
					position++
					if buffer[position] != rune('t') {
						goto l157
					}
					position++
					goto l154
				l157:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('i') {
						goto l158
					}
					position++
					if buffer[position] != rune('n') {
						goto l158
					}
					position++
					if buffer[position] != rune('t') {
						goto l158
					}
					position++
					goto l154
				l158:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('b') {
						goto l159
					}
					position++
					if buffer[position] != rune('o') {
						goto l159
					}
					position++
					if buffer[position] != rune('o') {
						goto l159
					}
					position++
					if buffer[position] != rune('l') {
						goto l159
					}
					position++
					if buffer[position] != rune('e') {
						goto l159
					}
					position++
					if buffer[position] != rune('a') {
						goto l159
					}
					position++
					if buffer[position] != rune('n') {
						goto l159
					}
					position++
					goto l154
				l159:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('a') {
						goto l152
					}
					position++
					if buffer[position] != rune('n') {
						goto l152
					}
					position++
					if buffer[position] != rune('y') {
						goto l152
					}
					position++
				}
			l154:
				if !_rules[rule_]() {
					goto l152
				}
				add(rulePrimitiveType, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
		/* 32 ReferenceType <- <(ComplexReference / Identifier)> */
		func() bool {
			position160, tokenIndex160 := position, tokenIndex
			{
				position161 := position
				{
					position162, tokenIndex162 := position, tokenIndex
					if !_rules[ruleComplexReference]() {
						goto l163
					}
					goto l162
				l163:
					position, tokenIndex = position162, tokenIndex162
					if !_rules[ruleIdentifier]() {
						goto l160
					}
				}
			l162:
				add(ruleReferenceType, position161)
			}
			return true
		l160:
			position, tokenIndex = position160, tokenIndex160
			return false
		},
		/* 33 ComplexReference <- <(Identifier COLON Identifier ((LBRACKET LBRACKET ComplexRefParam RBRACKET RBRACKET) / (LBRACKET ComplexRefParam RBRACKET)) (LT GenericTypeParams RT)?)> */
		func() bool {
			position164, tokenIndex164 := position, tokenIndex
			{
				position165 := position
				if !_rules[ruleIdentifier]() {
					goto l164
				}
				if !_rules[ruleCOLON]() {
					goto l164
				}
				if !_rules[ruleIdentifier]() {
					goto l164
				}
				{
					position166, tokenIndex166 := position, tokenIndex
					if !_rules[ruleLBRACKET]() {
						goto l167
					}
					if !_rules[ruleLBRACKET]() {
						goto l167
					}
					if !_rules[ruleComplexRefParam]() {
						goto l167
					}
					if !_rules[ruleRBRACKET]() {
						goto l167
					}
					if !_rules[ruleRBRACKET]() {
						goto l167
					}
					goto l166
				l167:
					position, tokenIndex = position166, tokenIndex166
					if !_rules[ruleLBRACKET]() {
						goto l164
					}
					if !_rules[ruleComplexRefParam]() {
						goto l164
					}
					if !_rules[ruleRBRACKET]() {
						goto l164
					}
				}
			l166:
				{
					position168, tokenIndex168 := position, tokenIndex
					if !_rules[ruleLT]() {
						goto l168
					}
					if !_rules[ruleGenericTypeParams]() {
						goto l168
					}
					if !_rules[ruleRT]() {
						goto l168
					}
					goto l169
				l168:
					position, tokenIndex = position168, tokenIndex168
				}
			l169:
				add(ruleComplexReference, position165)
			}
			return true
		l164:
			position, tokenIndex = position164, tokenIndex164
			return false
		},
		/* 34 ComplexRefParam <- <(DottedStaticIndexKey / StaticIndexKey / String / Identifier)> */
		func() bool {
			position170, tokenIndex170 := position, tokenIndex
			{
				position171 := position
				{
					position172, tokenIndex172 := position, tokenIndex
					if !_rules[ruleDottedStaticIndexKey]() {
						goto l173
					}
					goto l172
				l173:
					position, tokenIndex = position172, tokenIndex172
					if !_rules[ruleStaticIndexKey]() {
						goto l174
					}
					goto l172
				l174:
					position, tokenIndex = position172, tokenIndex172
					if !_rules[ruleString]() {
						goto l175
					}
					goto l172
				l175:
					position, tokenIndex = position172, tokenIndex172
					if !_rules[ruleIdentifier]() {
						goto l170
					}
				}
			l172:
				add(ruleComplexRefParam, position171)
			}
			return true
		l170:
			position, tokenIndex = position170, tokenIndex170
			return false
		},
		/* 35 DottedStaticIndexKey <- <(StaticIndexKey '.' Identifier)> */
		func() bool {
			position176, tokenIndex176 := position, tokenIndex
			{
				position177 := position
				if !_rules[ruleStaticIndexKey]() {
					goto l176
				}
				if buffer[position] != rune('.') {
					goto l176
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l176
				}
				add(ruleDottedStaticIndexKey, position177)
			}
			return true
		l176:
			position, tokenIndex = position176, tokenIndex176
			return false
		},
		/* 36 StaticIndexKey <- <((('%' 'f' 'a' 'l' 'l' 'b' 'a' 'c' 'k') / ('%' 'k' 'e' 'y') / ('%' 'p' 'a' 'r' 'e' 'n' 't') / ('%' 'n' 'o' 'n' 'e') / ('%' 'u' 'n' 'k' 'n' 'o' 'w' 'n')) _)> */
		func() bool {
			position178, tokenIndex178 := position, tokenIndex
			{
				position179 := position
				{
					position180, tokenIndex180 := position, tokenIndex
					if buffer[position] != rune('%') {
						goto l181
					}
					position++
					if buffer[position] != rune('f') {
						goto l181
					}
					position++
					if buffer[position] != rune('a') {
						goto l181
					}
					position++
					if buffer[position] != rune('l') {
						goto l181
					}
					position++
					if buffer[position] != rune('l') {
						goto l181
					}
					position++
					if buffer[position] != rune('b') {
						goto l181
					}
					position++
					if buffer[position] != rune('a') {
						goto l181
					}
					position++
					if buffer[position] != rune('c') {
						goto l181
					}
					position++
					if buffer[position] != rune('k') {
						goto l181
					}
					position++
					goto l180
				l181:
					position, tokenIndex = position180, tokenIndex180
					if buffer[position] != rune('%') {
						goto l182
					}
					position++
					if buffer[position] != rune('k') {
						goto l182
					}
					position++
					if buffer[position] != rune('e') {
						goto l182
					}
					position++
					if buffer[position] != rune('y') {
						goto l182
					}
					position++
					goto l180
				l182:
					position, tokenIndex = position180, tokenIndex180
					if buffer[position] != rune('%') {
						goto l183
					}
					position++
					if buffer[position] != rune('p') {
						goto l183
					}
					position++
					if buffer[position] != rune('a') {
						goto l183
					}
					position++
					if buffer[position] != rune('r') {
						goto l183
					}
					position++
					if buffer[position] != rune('e') {
						goto l183
					}
					position++
					if buffer[position] != rune('n') {
						goto l183
					}
					position++
					if buffer[position] != rune('t') {
						goto l183
					}
					position++
					goto l180
				l183:
					position, tokenIndex = position180, tokenIndex180
					if buffer[position] != rune('%') {
						goto l184
					}
					position++
					if buffer[position] != rune('n') {
						goto l184
					}
					position++
					if buffer[position] != rune('o') {
						goto l184
					}
					position++
					if buffer[position] != rune('n') {
						goto l184
					}
					position++
					if buffer[position] != rune('e') {
						goto l184
					}
					position++
					goto l180
				l184:
					position, tokenIndex = position180, tokenIndex180
					if buffer[position] != rune('%') {
						goto l178
					}
					position++
					if buffer[position] != rune('u') {
						goto l178
					}
					position++
					if buffer[position] != rune('n') {
						goto l178
					}
					position++
					if buffer[position] != rune('k') {
						goto l178
					}
					position++
					if buffer[position] != rune('n') {
						goto l178
					}
					position++
					if buffer[position] != rune('o') {
						goto l178
					}
					position++
					if buffer[position] != rune('w') {
						goto l178
					}
					position++
					if buffer[position] != rune('n') {
						goto l178
					}
					position++
				}
			l180:
				if !_rules[rule_]() {
					goto l178
				}
				add(ruleStaticIndexKey, position179)
			}
			return true
		l178:
			position, tokenIndex = position178, tokenIndex178
			return false
		},
		/* 37 LiteralType <- <(String / Number / Boolean)> */
		func() bool {
			position185, tokenIndex185 := position, tokenIndex
			{
				position186 := position
				{
					position187, tokenIndex187 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l188
					}
					goto l187
				l188:
					position, tokenIndex = position187, tokenIndex187
					if !_rules[ruleNumber]() {
						goto l189
					}
					goto l187
				l189:
					position, tokenIndex = position187, tokenIndex187
					if !_rules[ruleBoolean]() {
						goto l185
					}
				}
			l187:
				add(ruleLiteralType, position186)
			}
			return true
		l185:
			position, tokenIndex = position185, tokenIndex185
			return false
		},
		/* 38 ArrayConstraint <- <(AT (Range / Number))> */
		func() bool {
			position190, tokenIndex190 := position, tokenIndex
			{
				position191 := position
				if !_rules[ruleAT]() {
					goto l190
				}
				{
					position192, tokenIndex192 := position, tokenIndex
					if !_rules[ruleRange]() {
						goto l193
					}
					goto l192
				l193:
					position, tokenIndex = position192, tokenIndex192
					if !_rules[ruleNumber]() {
						goto l190
					}
				}
			l192:
				add(ruleArrayConstraint, position191)
			}
			return true
		l190:
			position, tokenIndex = position190, tokenIndex190
			return false
		},
		/* 39 Range <- <((Number ('.' '.') Number?) / ('.' '.' Number))> */
		func() bool {
			position194, tokenIndex194 := position, tokenIndex
			{
				position195 := position
				{
					position196, tokenIndex196 := position, tokenIndex
					if !_rules[ruleNumber]() {
						goto l197
					}
					if buffer[position] != rune('.') {
						goto l197
					}
					position++
					if buffer[position] != rune('.') {
						goto l197
					}
					position++
					{
						position198, tokenIndex198 := position, tokenIndex
						if !_rules[ruleNumber]() {
							goto l198
						}
						goto l199
					l198:
						position, tokenIndex = position198, tokenIndex198
					}
				l199:
					goto l196
				l197:
					position, tokenIndex = position196, tokenIndex196
					if buffer[position] != rune('.') {
						goto l194
					}
					position++
					if buffer[position] != rune('.') {
						goto l194
					}
					position++
					if !_rules[ruleNumber]() {
						goto l194
					}
				}
			l196:
				add(ruleRange, position195)
			}
			return true
		l194:
			position, tokenIndex = position194, tokenIndex194
			return false
		},
		/* 40 Attribute <- <('#' LBRACKET AttributeList RBRACKET)> */
		func() bool {
			position200, tokenIndex200 := position, tokenIndex
			{
				position201 := position
				if buffer[position] != rune('#') {
					goto l200
				}
				position++
				if !_rules[ruleLBRACKET]() {
					goto l200
				}
				if !_rules[ruleAttributeList]() {
					goto l200
				}
				if !_rules[ruleRBRACKET]() {
					goto l200
				}
				add(ruleAttribute, position201)
			}
			return true
		l200:
			position, tokenIndex = position200, tokenIndex200
			return false
		},
		/* 41 AttributeList <- <(AttributeItem (COMMA AttributeItem)*)> */
		func() bool {
			position202, tokenIndex202 := position, tokenIndex
			{
				position203 := position
				if !_rules[ruleAttributeItem]() {
					goto l202
				}
			l204:
				{
					position205, tokenIndex205 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l205
					}
					if !_rules[ruleAttributeItem]() {
						goto l205
					}
					goto l204
				l205:
					position, tokenIndex = position205, tokenIndex205
				}
				add(ruleAttributeList, position203)
			}
			return true
		l202:
			position, tokenIndex = position202, tokenIndex202
			return false
		},
		/* 42 AttributeItem <- <(AttributePair / AttributeCall / Identifier)> */
		func() bool {
			position206, tokenIndex206 := position, tokenIndex
			{
				position207 := position
				{
					position208, tokenIndex208 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l209
					}
					goto l208
				l209:
					position, tokenIndex = position208, tokenIndex208
					if !_rules[ruleAttributeCall]() {
						goto l210
					}
					goto l208
				l210:
					position, tokenIndex = position208, tokenIndex208
					if !_rules[ruleIdentifier]() {
						goto l206
					}
				}
			l208:
				add(ruleAttributeItem, position207)
			}
			return true
		l206:
			position, tokenIndex = position206, tokenIndex206
			return false
		},
		/* 43 AttributeCall <- <(Identifier LPAREN AttributeParamList? RPAREN)> */
		func() bool {
			position211, tokenIndex211 := position, tokenIndex
			{
				position212 := position
				if !_rules[ruleIdentifier]() {
					goto l211
				}
				if !_rules[ruleLPAREN]() {
					goto l211
				}
				{
					position213, tokenIndex213 := position, tokenIndex
					if !_rules[ruleAttributeParamList]() {
						goto l213
					}
					goto l214
				l213:
					position, tokenIndex = position213, tokenIndex213
				}
			l214:
				if !_rules[ruleRPAREN]() {
					goto l211
				}
				add(ruleAttributeCall, position212)
			}
			return true
		l211:
			position, tokenIndex = position211, tokenIndex211
			return false
		},
		/* 44 AttributeParamList <- <(AttributeParam (COMMA AttributeParam)*)> */
		func() bool {
			position215, tokenIndex215 := position, tokenIndex
			{
				position216 := position
				if !_rules[ruleAttributeParam]() {
					goto l215
				}
			l217:
				{
					position218, tokenIndex218 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l218
					}
					if !_rules[ruleAttributeParam]() {
						goto l218
					}
					goto l217
				l218:
					position, tokenIndex = position218, tokenIndex218
				}
				add(ruleAttributeParamList, position216)
			}
			return true
		l215:
			position, tokenIndex = position215, tokenIndex215
			return false
		},
		/* 45 AttributeParam <- <(AttributePair / AttributeValue)> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				{
					position221, tokenIndex221 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l222
					}
					goto l221
				l222:
					position, tokenIndex = position221, tokenIndex221
					if !_rules[ruleAttributeValue]() {
						goto l219
					}
				}
			l221:
				add(ruleAttributeParam, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 46 AttributePair <- <(Identifier EQUALS AttributeValue)> */
		func() bool {
			position223, tokenIndex223 := position, tokenIndex
			{
				position224 := position
				if !_rules[ruleIdentifier]() {
					goto l223
				}
				if !_rules[ruleEQUALS]() {
					goto l223
				}
				if !_rules[ruleAttributeValue]() {
					goto l223
				}
				add(ruleAttributePair, position224)
			}
			return true
		l223:
			position, tokenIndex = position223, tokenIndex223
			return false
		},
		/* 47 AttributeValue <- <(ArrayLiteral / String / Number / Boolean / Identifier)> */
		func() bool {
			position225, tokenIndex225 := position, tokenIndex
			{
				position226 := position
				{
					position227, tokenIndex227 := position, tokenIndex
					if !_rules[ruleArrayLiteral]() {
						goto l228
					}
					goto l227
				l228:
					position, tokenIndex = position227, tokenIndex227
					if !_rules[ruleString]() {
						goto l229
					}
					goto l227
				l229:
					position, tokenIndex = position227, tokenIndex227
					if !_rules[ruleNumber]() {
						goto l230
					}
					goto l227
				l230:
					position, tokenIndex = position227, tokenIndex227
					if !_rules[ruleBoolean]() {
						goto l231
					}
					goto l227
				l231:
					position, tokenIndex = position227, tokenIndex227
					if !_rules[ruleIdentifier]() {
						goto l225
					}
				}
			l227:
				add(ruleAttributeValue, position226)
			}
			return true
		l225:
			position, tokenIndex = position225, tokenIndex225
			return false
		},
		/* 48 ArrayLiteral <- <(LBRACKET (AttributeValue (COMMA AttributeValue)*)? RBRACKET)> */
		func() bool {
			position232, tokenIndex232 := position, tokenIndex
			{
				position233 := position
				if !_rules[ruleLBRACKET]() {
					goto l232
				}
				{
					position234, tokenIndex234 := position, tokenIndex
					if !_rules[ruleAttributeValue]() {
						goto l234
					}
				l236:
					{
						position237, tokenIndex237 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l237
						}
						if !_rules[ruleAttributeValue]() {
							goto l237
						}
						goto l236
					l237:
						position, tokenIndex = position237, tokenIndex237
					}
					goto l235
				l234:
					position, tokenIndex = position234, tokenIndex234
				}
			l235:
				if !_rules[ruleRBRACKET]() {
					goto l232
				}
				add(ruleArrayLiteral, position233)
			}
			return true
		l232:
			position, tokenIndex = position232, tokenIndex232
			return false
		},
		/* 49 Comment <- <('/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position238, tokenIndex238 := position, tokenIndex
			{
				position239 := position
				if buffer[position] != rune('/') {
					goto l238
				}
				position++
				if buffer[position] != rune('/') {
					goto l238
				}
				position++
			l240:
				{
					position241, tokenIndex241 := position, tokenIndex
					{
						position242, tokenIndex242 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l242
						}
						goto l241
					l242:
						position, tokenIndex = position242, tokenIndex242
					}
					if !matchDot() {
						goto l241
					}
					goto l240
				l241:
					position, tokenIndex = position241, tokenIndex241
				}
				{
					position243, tokenIndex243 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l244
					}
					goto l243
				l244:
					position, tokenIndex = position243, tokenIndex243
					{
						position245, tokenIndex245 := position, tokenIndex
						if !matchDot() {
							goto l245
						}
						goto l238
					l245:
						position, tokenIndex = position245, tokenIndex245
					}
				}
			l243:
				add(ruleComment, position239)
			}
			return true
		l238:
			position, tokenIndex = position238, tokenIndex238
			return false
		},
		/* 50 DocComment <- <('/' '/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position246, tokenIndex246 := position, tokenIndex
			{
				position247 := position
				if buffer[position] != rune('/') {
					goto l246
				}
				position++
				if buffer[position] != rune('/') {
					goto l246
				}
				position++
				if buffer[position] != rune('/') {
					goto l246
				}
				position++
			l248:
				{
					position249, tokenIndex249 := position, tokenIndex
					{
						position250, tokenIndex250 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l250
						}
						goto l249
					l250:
						position, tokenIndex = position250, tokenIndex250
					}
					if !matchDot() {
						goto l249
					}
					goto l248
				l249:
					position, tokenIndex = position249, tokenIndex249
				}
				{
					position251, tokenIndex251 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l252
					}
					goto l251
				l252:
					position, tokenIndex = position251, tokenIndex251
					{
						position253, tokenIndex253 := position, tokenIndex
						if !matchDot() {
							goto l253
						}
						goto l246
					l253:
						position, tokenIndex = position253, tokenIndex253
					}
				}
			l251:
				add(ruleDocComment, position247)
			}
			return true
		l246:
			position, tokenIndex = position246, tokenIndex246
			return false
		},
		/* 51 Identifier <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')* _)> */
		func() bool {
			position254, tokenIndex254 := position, tokenIndex
			{
				position255 := position
				{
					position256, tokenIndex256 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l257
					}
					position++
					goto l256
				l257:
					position, tokenIndex = position256, tokenIndex256
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l258
					}
					position++
					goto l256
				l258:
					position, tokenIndex = position256, tokenIndex256
					if buffer[position] != rune('_') {
						goto l254
					}
					position++
				}
			l256:
			l259:
				{
					position260, tokenIndex260 := position, tokenIndex
					{
						position261, tokenIndex261 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l262
						}
						position++
						goto l261
					l262:
						position, tokenIndex = position261, tokenIndex261
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l263
						}
						position++
						goto l261
					l263:
						position, tokenIndex = position261, tokenIndex261
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l264
						}
						position++
						goto l261
					l264:
						position, tokenIndex = position261, tokenIndex261
						if buffer[position] != rune('_') {
							goto l260
						}
						position++
					}
				l261:
					goto l259
				l260:
					position, tokenIndex = position260, tokenIndex260
				}
				if !_rules[rule_]() {
					goto l254
				}
				add(ruleIdentifier, position255)
			}
			return true
		l254:
			position, tokenIndex = position254, tokenIndex254
			return false
		},
		/* 52 String <- <('"' (!'"' .)* '"' _)> */
		func() bool {
			position265, tokenIndex265 := position, tokenIndex
			{
				position266 := position
				if buffer[position] != rune('"') {
					goto l265
				}
				position++
			l267:
				{
					position268, tokenIndex268 := position, tokenIndex
					{
						position269, tokenIndex269 := position, tokenIndex
						if buffer[position] != rune('"') {
							goto l269
						}
						position++
						goto l268
					l269:
						position, tokenIndex = position269, tokenIndex269
					}
					if !matchDot() {
						goto l268
					}
					goto l267
				l268:
					position, tokenIndex = position268, tokenIndex268
				}
				if buffer[position] != rune('"') {
					goto l265
				}
				position++
				if !_rules[rule_]() {
					goto l265
				}
				add(ruleString, position266)
			}
			return true
		l265:
			position, tokenIndex = position265, tokenIndex265
			return false
		},
		/* 53 Number <- <('-'? [0-9]+ ('.' [0-9]+)? _)> */
		func() bool {
			position270, tokenIndex270 := position, tokenIndex
			{
				position271 := position
				{
					position272, tokenIndex272 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l272
					}
					position++
					goto l273
				l272:
					position, tokenIndex = position272, tokenIndex272
				}
			l273:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l270
				}
				position++
			l274:
				{
					position275, tokenIndex275 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l275
					}
					position++
					goto l274
				l275:
					position, tokenIndex = position275, tokenIndex275
				}
				{
					position276, tokenIndex276 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l276
					}
					position++
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l276
					}
					position++
				l278:
					{
						position279, tokenIndex279 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l279
						}
						position++
						goto l278
					l279:
						position, tokenIndex = position279, tokenIndex279
					}
					goto l277
				l276:
					position, tokenIndex = position276, tokenIndex276
				}
			l277:
				if !_rules[rule_]() {
					goto l270
				}
				add(ruleNumber, position271)
			}
			return true
		l270:
			position, tokenIndex = position270, tokenIndex270
			return false
		},
		/* 54 Boolean <- <((('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e')) _)> */
		func() bool {
			position280, tokenIndex280 := position, tokenIndex
			{
				position281 := position
				{
					position282, tokenIndex282 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l283
					}
					position++
					if buffer[position] != rune('r') {
						goto l283
					}
					position++
					if buffer[position] != rune('u') {
						goto l283
					}
					position++
					if buffer[position] != rune('e') {
						goto l283
					}
					position++
					goto l282
				l283:
					position, tokenIndex = position282, tokenIndex282
					if buffer[position] != rune('f') {
						goto l280
					}
					position++
					if buffer[position] != rune('a') {
						goto l280
					}
					position++
					if buffer[position] != rune('l') {
						goto l280
					}
					position++
					if buffer[position] != rune('s') {
						goto l280
					}
					position++
					if buffer[position] != rune('e') {
						goto l280
					}
					position++
				}
			l282:
				if !_rules[rule_]() {
					goto l280
				}
				add(ruleBoolean, position281)
			}
			return true
		l280:
			position, tokenIndex = position280, tokenIndex280
			return false
		},
		/* 55 LBRACE <- <('{' _)> */
		func() bool {
			position284, tokenIndex284 := position, tokenIndex
			{
				position285 := position
				if buffer[position] != rune('{') {
					goto l284
				}
				position++
				if !_rules[rule_]() {
					goto l284
				}
				add(ruleLBRACE, position285)
			}
			return true
		l284:
			position, tokenIndex = position284, tokenIndex284
			return false
		},
		/* 56 RBRACE <- <('}' _)> */
		func() bool {
			position286, tokenIndex286 := position, tokenIndex
			{
				position287 := position
				if buffer[position] != rune('}') {
					goto l286
				}
				position++
				if !_rules[rule_]() {
					goto l286
				}
				add(ruleRBRACE, position287)
			}
			return true
		l286:
			position, tokenIndex = position286, tokenIndex286
			return false
		},
		/* 57 LBRACKET <- <('[' _)> */
		func() bool {
			position288, tokenIndex288 := position, tokenIndex
			{
				position289 := position
				if buffer[position] != rune('[') {
					goto l288
				}
				position++
				if !_rules[rule_]() {
					goto l288
				}
				add(ruleLBRACKET, position289)
			}
			return true
		l288:
			position, tokenIndex = position288, tokenIndex288
			return false
		},
		/* 58 RBRACKET <- <(']' _)> */
		func() bool {
			position290, tokenIndex290 := position, tokenIndex
			{
				position291 := position
				if buffer[position] != rune(']') {
					goto l290
				}
				position++
				if !_rules[rule_]() {
					goto l290
				}
				add(ruleRBRACKET, position291)
			}
			return true
		l290:
			position, tokenIndex = position290, tokenIndex290
			return false
		},
		/* 59 LPAREN <- <('(' _)> */
		func() bool {
			position292, tokenIndex292 := position, tokenIndex
			{
				position293 := position
				if buffer[position] != rune('(') {
					goto l292
				}
				position++
				if !_rules[rule_]() {
					goto l292
				}
				add(ruleLPAREN, position293)
			}
			return true
		l292:
			position, tokenIndex = position292, tokenIndex292
			return false
		},
		/* 60 RPAREN <- <(')' _)> */
		func() bool {
			position294, tokenIndex294 := position, tokenIndex
			{
				position295 := position
				if buffer[position] != rune(')') {
					goto l294
				}
				position++
				if !_rules[rule_]() {
					goto l294
				}
				add(ruleRPAREN, position295)
			}
			return true
		l294:
			position, tokenIndex = position294, tokenIndex294
			return false
		},
		/* 61 COMMA <- <(',' _)> */
		func() bool {
			position296, tokenIndex296 := position, tokenIndex
			{
				position297 := position
				if buffer[position] != rune(',') {
					goto l296
				}
				position++
				if !_rules[rule_]() {
					goto l296
				}
				add(ruleCOMMA, position297)
			}
			return true
		l296:
			position, tokenIndex = position296, tokenIndex296
			return false
		},
		/* 62 COLON <- <(':' _)> */
		func() bool {
			position298, tokenIndex298 := position, tokenIndex
			{
				position299 := position
				if buffer[position] != rune(':') {
					goto l298
				}
				position++
				if !_rules[rule_]() {
					goto l298
				}
				add(ruleCOLON, position299)
			}
			return true
		l298:
			position, tokenIndex = position298, tokenIndex298
			return false
		},
		/* 63 SEMICOLON <- <(';' _)> */
		nil,
		/* 64 EQUALS <- <('=' _)> */
		func() bool {
			position301, tokenIndex301 := position, tokenIndex
			{
				position302 := position
				if buffer[position] != rune('=') {
					goto l301
				}
				position++
				if !_rules[rule_]() {
					goto l301
				}
				add(ruleEQUALS, position302)
			}
			return true
		l301:
			position, tokenIndex = position301, tokenIndex301
			return false
		},
		/* 65 PIPE <- <('|' _)> */
		func() bool {
			position303, tokenIndex303 := position, tokenIndex
			{
				position304 := position
				if buffer[position] != rune('|') {
					goto l303
				}
				position++
				if !_rules[rule_]() {
					goto l303
				}
				add(rulePIPE, position304)
			}
			return true
		l303:
			position, tokenIndex = position303, tokenIndex303
			return false
		},
		/* 66 DOT <- <('.' _)> */
		nil,
		/* 67 SPREAD <- <('.' '.' '.' _)> */
		func() bool {
			position306, tokenIndex306 := position, tokenIndex
			{
				position307 := position
				if buffer[position] != rune('.') {
					goto l306
				}
				position++
				if buffer[position] != rune('.') {
					goto l306
				}
				position++
				if buffer[position] != rune('.') {
					goto l306
				}
				position++
				if !_rules[rule_]() {
					goto l306
				}
				add(ruleSPREAD, position307)
			}
			return true
		l306:
			position, tokenIndex = position306, tokenIndex306
			return false
		},
		/* 68 AT <- <('@' _)> */
		func() bool {
			position308, tokenIndex308 := position, tokenIndex
			{
				position309 := position
				if buffer[position] != rune('@') {
					goto l308
				}
				position++
				if !_rules[rule_]() {
					goto l308
				}
				add(ruleAT, position309)
			}
			return true
		l308:
			position, tokenIndex = position308, tokenIndex308
			return false
		},
		/* 69 LT <- <('<' _)> */
		func() bool {
			position310, tokenIndex310 := position, tokenIndex
			{
				position311 := position
				if buffer[position] != rune('<') {
					goto l310
				}
				position++
				if !_rules[rule_]() {
					goto l310
				}
				add(ruleLT, position311)
			}
			return true
		l310:
			position, tokenIndex = position310, tokenIndex310
			return false
		},
		/* 70 RT <- <('>' _)> */
		func() bool {
			position312, tokenIndex312 := position, tokenIndex
			{
				position313 := position
				if buffer[position] != rune('>') {
					goto l312
				}
				position++
				if !_rules[rule_]() {
					goto l312
				}
				add(ruleRT, position313)
			}
			return true
		l312:
			position, tokenIndex = position312, tokenIndex312
			return false
		},
		/* 71 DoubleColon <- <(':' ':' _)> */
		func() bool {
			position314, tokenIndex314 := position, tokenIndex
			{
				position315 := position
				if buffer[position] != rune(':') {
					goto l314
				}
				position++
				if buffer[position] != rune(':') {
					goto l314
				}
				position++
				if !_rules[rule_]() {
					goto l314
				}
				add(ruleDoubleColon, position315)
			}
			return true
		l314:
			position, tokenIndex = position314, tokenIndex314
			return false
		},
		/* 72 SingleColon <- <(':' _)> */
		func() bool {
			position316, tokenIndex316 := position, tokenIndex
			{
				position317 := position
				if buffer[position] != rune(':') {
					goto l316
				}
				position++
				if !_rules[rule_]() {
					goto l316
				}
				add(ruleSingleColon, position317)
			}
			return true
		l316:
			position, tokenIndex = position316, tokenIndex316
			return false
		},
		/* 73 _ <- <(' ' / '\t' / '\r' / '\n' / Comment / DocComment)*> */
		func() bool {
			{
				position319 := position
			l320:
				{
					position321, tokenIndex321 := position, tokenIndex
					{
						position322, tokenIndex322 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l323
						}
						position++
						goto l322
					l323:
						position, tokenIndex = position322, tokenIndex322
						if buffer[position] != rune('\t') {
							goto l324
						}
						position++
						goto l322
					l324:
						position, tokenIndex = position322, tokenIndex322
						if buffer[position] != rune('\r') {
							goto l325
						}
						position++
						goto l322
					l325:
						position, tokenIndex = position322, tokenIndex322
						if buffer[position] != rune('\n') {
							goto l326
						}
						position++
						goto l322
					l326:
						position, tokenIndex = position322, tokenIndex322
						if !_rules[ruleComment]() {
							goto l327
						}
						goto l322
					l327:
						position, tokenIndex = position322, tokenIndex322
						if !_rules[ruleDocComment]() {
							goto l321
						}
					}
				l322:
					goto l320
				l321:
					position, tokenIndex = position321, tokenIndex321
				}
				add(rule_, position319)
			}
			return true
		},
		/* 74 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position328, tokenIndex328 := position, tokenIndex
			{
				position329 := position
				{
					position330, tokenIndex330 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l331
					}
					position++
					if buffer[position] != rune('\n') {
						goto l331
					}
					position++
					goto l330
				l331:
					position, tokenIndex = position330, tokenIndex330
					if buffer[position] != rune('\n') {
						goto l332
					}
					position++
					goto l330
				l332:
					position, tokenIndex = position330, tokenIndex330
					if buffer[position] != rune('\r') {
						goto l328
					}
					position++
				}
			l330:
				add(ruleEOL, position329)
			}
			return true
		l328:
			position, tokenIndex = position328, tokenIndex328
			return false
		},
	}
	p.rules = _rules
	return nil
}
