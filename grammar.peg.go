package main

// Code generated by peg grammar.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleStart
	ruleStatement
	ruleUseStmt
	rulePath
	rulePathSegment
	ruleTypeAlias
	ruleTypeName
	ruleStructDef
	ruleFieldList
	ruleFieldOrSpread
	ruleField
	ruleComputedField
	ruleNamedField
	ruleSpreadField
	ruleFieldName
	ruleEnumDef
	ruleEnumValueList
	ruleEnumValue
	ruleDispatchStmt
	ruleDispatchPath
	ruleDispatchKeyList
	ruleDispatchKey
	ruleDispatchTarget
	ruleSpreadStruct
	ruleType
	ruleAttributedType
	ruleConstrainedType
	ruleUnionType
	ruleArrayType
	ruleStructType
	ruleGenericType
	ruleGenericTypeParams
	rulePrimitiveType
	ruleReferenceType
	ruleComplexReference
	ruleResourcePath
	ruleComplexRefParam
	ruleDottedPath
	ruleStaticIndexKey
	ruleLiteralType
	ruleArrayConstraint
	ruleRange
	ruleRangeOperator
	ruleAttribute
	ruleAttributeList
	ruleAttributeItem
	ruleAttributeCallWithEquals
	ruleAttributeCall
	ruleAttributeParamList
	ruleAttributeParam
	ruleAttributePair
	ruleAttributeValue
	ruleArrayLiteral
	ruleComment
	ruleDocComment
	ruleIdentifier
	ruleString
	ruleNumber
	ruleBoolean
	ruleLBRACE
	ruleRBRACE
	ruleLBRACKET
	ruleRBRACKET
	ruleLPAREN
	ruleRPAREN
	ruleCOMMA
	ruleCOLON
	ruleSEMICOLON
	ruleEQUALS
	rulePIPE
	ruleDOT
	ruleSPREAD
	ruleAT
	ruleLT
	ruleRT
	ruleDOTDOT
	ruleQUESTION
	ruleDoubleColon
	ruleSingleColon
	rule_
	ruleEOL
)

var rul3s = [...]string{
	"Unknown",
	"Start",
	"Statement",
	"UseStmt",
	"Path",
	"PathSegment",
	"TypeAlias",
	"TypeName",
	"StructDef",
	"FieldList",
	"FieldOrSpread",
	"Field",
	"ComputedField",
	"NamedField",
	"SpreadField",
	"FieldName",
	"EnumDef",
	"EnumValueList",
	"EnumValue",
	"DispatchStmt",
	"DispatchPath",
	"DispatchKeyList",
	"DispatchKey",
	"DispatchTarget",
	"SpreadStruct",
	"Type",
	"AttributedType",
	"ConstrainedType",
	"UnionType",
	"ArrayType",
	"StructType",
	"GenericType",
	"GenericTypeParams",
	"PrimitiveType",
	"ReferenceType",
	"ComplexReference",
	"ResourcePath",
	"ComplexRefParam",
	"DottedPath",
	"StaticIndexKey",
	"LiteralType",
	"ArrayConstraint",
	"Range",
	"RangeOperator",
	"Attribute",
	"AttributeList",
	"AttributeItem",
	"AttributeCallWithEquals",
	"AttributeCall",
	"AttributeParamList",
	"AttributeParam",
	"AttributePair",
	"AttributeValue",
	"ArrayLiteral",
	"Comment",
	"DocComment",
	"Identifier",
	"String",
	"Number",
	"Boolean",
	"LBRACE",
	"RBRACE",
	"LBRACKET",
	"RBRACKET",
	"LPAREN",
	"RPAREN",
	"COMMA",
	"COLON",
	"SEMICOLON",
	"EQUALS",
	"PIPE",
	"DOT",
	"SPREAD",
	"AT",
	"LT",
	"RT",
	"DOTDOT",
	"QUESTION",
	"DoubleColon",
	"SingleColon",
	"_",
	"EOL",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type MCDocParser struct {
	Buffer string
	buffer []rune
	rules  [82]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *MCDocParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *MCDocParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *MCDocParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *MCDocParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *MCDocParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *MCDocParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *MCDocParser) Init(options ...func(*MCDocParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Start <- <(_ Statement* _ !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule_]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleStatement]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[rule_]() {
					goto l0
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !matchDot() {
						goto l4
					}
					goto l0
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
				add(ruleStart, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Statement <- <(Attribute* _ (UseStmt / TypeAlias / StructDef / EnumDef / DispatchStmt) _)> */
		func() bool {
			position5, tokenIndex5 := position, tokenIndex
			{
				position6 := position
			l7:
				{
					position8, tokenIndex8 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l8
					}
					goto l7
				l8:
					position, tokenIndex = position8, tokenIndex8
				}
				if !_rules[rule_]() {
					goto l5
				}
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[ruleUseStmt]() {
						goto l10
					}
					goto l9
				l10:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleTypeAlias]() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleStructDef]() {
						goto l12
					}
					goto l9
				l12:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleEnumDef]() {
						goto l13
					}
					goto l9
				l13:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleDispatchStmt]() {
						goto l5
					}
				}
			l9:
				if !_rules[rule_]() {
					goto l5
				}
				add(ruleStatement, position6)
			}
			return true
		l5:
			position, tokenIndex = position5, tokenIndex5
			return false
		},
		/* 2 UseStmt <- <('u' 's' 'e' _ Path)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if buffer[position] != rune('u') {
					goto l14
				}
				position++
				if buffer[position] != rune('s') {
					goto l14
				}
				position++
				if buffer[position] != rune('e') {
					goto l14
				}
				position++
				if !_rules[rule_]() {
					goto l14
				}
				if !_rules[rulePath]() {
					goto l14
				}
				add(ruleUseStmt, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 3 Path <- <(DoubleColon? PathSegment (DoubleColon PathSegment)*)> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				{
					position18, tokenIndex18 := position, tokenIndex
					if !_rules[ruleDoubleColon]() {
						goto l18
					}
					goto l19
				l18:
					position, tokenIndex = position18, tokenIndex18
				}
			l19:
				if !_rules[rulePathSegment]() {
					goto l16
				}
			l20:
				{
					position21, tokenIndex21 := position, tokenIndex
					if !_rules[ruleDoubleColon]() {
						goto l21
					}
					if !_rules[rulePathSegment]() {
						goto l21
					}
					goto l20
				l21:
					position, tokenIndex = position21, tokenIndex21
				}
				add(rulePath, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 4 PathSegment <- <(('s' 'u' 'p' 'e' 'r') / Identifier)> */
		func() bool {
			position22, tokenIndex22 := position, tokenIndex
			{
				position23 := position
				{
					position24, tokenIndex24 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l25
					}
					position++
					if buffer[position] != rune('u') {
						goto l25
					}
					position++
					if buffer[position] != rune('p') {
						goto l25
					}
					position++
					if buffer[position] != rune('e') {
						goto l25
					}
					position++
					if buffer[position] != rune('r') {
						goto l25
					}
					position++
					goto l24
				l25:
					position, tokenIndex = position24, tokenIndex24
					if !_rules[ruleIdentifier]() {
						goto l22
					}
				}
			l24:
				add(rulePathSegment, position23)
			}
			return true
		l22:
			position, tokenIndex = position22, tokenIndex22
			return false
		},
		/* 5 TypeAlias <- <('t' 'y' 'p' 'e' _ TypeName _ EQUALS Type)> */
		func() bool {
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				if buffer[position] != rune('t') {
					goto l26
				}
				position++
				if buffer[position] != rune('y') {
					goto l26
				}
				position++
				if buffer[position] != rune('p') {
					goto l26
				}
				position++
				if buffer[position] != rune('e') {
					goto l26
				}
				position++
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleTypeName]() {
					goto l26
				}
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleEQUALS]() {
					goto l26
				}
				if !_rules[ruleType]() {
					goto l26
				}
				add(ruleTypeAlias, position27)
			}
			return true
		l26:
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 6 TypeName <- <(GenericType / Identifier)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				{
					position30, tokenIndex30 := position, tokenIndex
					if !_rules[ruleGenericType]() {
						goto l31
					}
					goto l30
				l31:
					position, tokenIndex = position30, tokenIndex30
					if !_rules[ruleIdentifier]() {
						goto l28
					}
				}
			l30:
				add(ruleTypeName, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 7 StructDef <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier _ LBRACE FieldList? RBRACE)> */
		func() bool {
			position32, tokenIndex32 := position, tokenIndex
			{
				position33 := position
				if buffer[position] != rune('s') {
					goto l32
				}
				position++
				if buffer[position] != rune('t') {
					goto l32
				}
				position++
				if buffer[position] != rune('r') {
					goto l32
				}
				position++
				if buffer[position] != rune('u') {
					goto l32
				}
				position++
				if buffer[position] != rune('c') {
					goto l32
				}
				position++
				if buffer[position] != rune('t') {
					goto l32
				}
				position++
				if !_rules[rule_]() {
					goto l32
				}
				if !_rules[ruleIdentifier]() {
					goto l32
				}
				if !_rules[rule_]() {
					goto l32
				}
				if !_rules[ruleLBRACE]() {
					goto l32
				}
				{
					position34, tokenIndex34 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l34
					}
					goto l35
				l34:
					position, tokenIndex = position34, tokenIndex34
				}
			l35:
				if !_rules[ruleRBRACE]() {
					goto l32
				}
				add(ruleStructDef, position33)
			}
			return true
		l32:
			position, tokenIndex = position32, tokenIndex32
			return false
		},
		/* 8 FieldList <- <(FieldOrSpread (COMMA FieldOrSpread)* COMMA?)> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				if !_rules[ruleFieldOrSpread]() {
					goto l36
				}
			l38:
				{
					position39, tokenIndex39 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l39
					}
					if !_rules[ruleFieldOrSpread]() {
						goto l39
					}
					goto l38
				l39:
					position, tokenIndex = position39, tokenIndex39
				}
				{
					position40, tokenIndex40 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l40
					}
					goto l41
				l40:
					position, tokenIndex = position40, tokenIndex40
				}
			l41:
				add(ruleFieldList, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 9 FieldOrSpread <- <(SpreadField / Field)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				{
					position44, tokenIndex44 := position, tokenIndex
					if !_rules[ruleSpreadField]() {
						goto l45
					}
					goto l44
				l45:
					position, tokenIndex = position44, tokenIndex44
					if !_rules[ruleField]() {
						goto l42
					}
				}
			l44:
				add(ruleFieldOrSpread, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 10 Field <- <(Attribute* _ (ComputedField / NamedField))> */
		func() bool {
			position46, tokenIndex46 := position, tokenIndex
			{
				position47 := position
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l49
					}
					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				if !_rules[rule_]() {
					goto l46
				}
				{
					position50, tokenIndex50 := position, tokenIndex
					if !_rules[ruleComputedField]() {
						goto l51
					}
					goto l50
				l51:
					position, tokenIndex = position50, tokenIndex50
					if !_rules[ruleNamedField]() {
						goto l46
					}
				}
			l50:
				add(ruleField, position47)
			}
			return true
		l46:
			position, tokenIndex = position46, tokenIndex46
			return false
		},
		/* 11 ComputedField <- <(LBRACKET Type RBRACKET QUESTION? COLON Type)> */
		func() bool {
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
				if !_rules[ruleLBRACKET]() {
					goto l52
				}
				if !_rules[ruleType]() {
					goto l52
				}
				if !_rules[ruleRBRACKET]() {
					goto l52
				}
				{
					position54, tokenIndex54 := position, tokenIndex
					if !_rules[ruleQUESTION]() {
						goto l54
					}
					goto l55
				l54:
					position, tokenIndex = position54, tokenIndex54
				}
			l55:
				if !_rules[ruleCOLON]() {
					goto l52
				}
				if !_rules[ruleType]() {
					goto l52
				}
				add(ruleComputedField, position53)
			}
			return true
		l52:
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 12 NamedField <- <(FieldName COLON Type)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if !_rules[ruleFieldName]() {
					goto l56
				}
				if !_rules[ruleCOLON]() {
					goto l56
				}
				if !_rules[ruleType]() {
					goto l56
				}
				add(ruleNamedField, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 13 SpreadField <- <(Attribute* _ SPREAD Type)> */
		func() bool {
			position58, tokenIndex58 := position, tokenIndex
			{
				position59 := position
			l60:
				{
					position61, tokenIndex61 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l61
					}
					goto l60
				l61:
					position, tokenIndex = position61, tokenIndex61
				}
				if !_rules[rule_]() {
					goto l58
				}
				if !_rules[ruleSPREAD]() {
					goto l58
				}
				if !_rules[ruleType]() {
					goto l58
				}
				add(ruleSpreadField, position59)
			}
			return true
		l58:
			position, tokenIndex = position58, tokenIndex58
			return false
		},
		/* 14 FieldName <- <(Identifier QUESTION?)> */
		func() bool {
			position62, tokenIndex62 := position, tokenIndex
			{
				position63 := position
				if !_rules[ruleIdentifier]() {
					goto l62
				}
				{
					position64, tokenIndex64 := position, tokenIndex
					if !_rules[ruleQUESTION]() {
						goto l64
					}
					goto l65
				l64:
					position, tokenIndex = position64, tokenIndex64
				}
			l65:
				add(ruleFieldName, position63)
			}
			return true
		l62:
			position, tokenIndex = position62, tokenIndex62
			return false
		},
		/* 15 EnumDef <- <('e' 'n' 'u' 'm' _ LPAREN Type RPAREN Identifier _ LBRACE EnumValueList? RBRACE)> */
		func() bool {
			position66, tokenIndex66 := position, tokenIndex
			{
				position67 := position
				if buffer[position] != rune('e') {
					goto l66
				}
				position++
				if buffer[position] != rune('n') {
					goto l66
				}
				position++
				if buffer[position] != rune('u') {
					goto l66
				}
				position++
				if buffer[position] != rune('m') {
					goto l66
				}
				position++
				if !_rules[rule_]() {
					goto l66
				}
				if !_rules[ruleLPAREN]() {
					goto l66
				}
				if !_rules[ruleType]() {
					goto l66
				}
				if !_rules[ruleRPAREN]() {
					goto l66
				}
				if !_rules[ruleIdentifier]() {
					goto l66
				}
				if !_rules[rule_]() {
					goto l66
				}
				if !_rules[ruleLBRACE]() {
					goto l66
				}
				{
					position68, tokenIndex68 := position, tokenIndex
					if !_rules[ruleEnumValueList]() {
						goto l68
					}
					goto l69
				l68:
					position, tokenIndex = position68, tokenIndex68
				}
			l69:
				if !_rules[ruleRBRACE]() {
					goto l66
				}
				add(ruleEnumDef, position67)
			}
			return true
		l66:
			position, tokenIndex = position66, tokenIndex66
			return false
		},
		/* 16 EnumValueList <- <(EnumValue (COMMA EnumValue)* COMMA?)> */
		func() bool {
			position70, tokenIndex70 := position, tokenIndex
			{
				position71 := position
				if !_rules[ruleEnumValue]() {
					goto l70
				}
			l72:
				{
					position73, tokenIndex73 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l73
					}
					if !_rules[ruleEnumValue]() {
						goto l73
					}
					goto l72
				l73:
					position, tokenIndex = position73, tokenIndex73
				}
				{
					position74, tokenIndex74 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l74
					}
					goto l75
				l74:
					position, tokenIndex = position74, tokenIndex74
				}
			l75:
				add(ruleEnumValueList, position71)
			}
			return true
		l70:
			position, tokenIndex = position70, tokenIndex70
			return false
		},
		/* 17 EnumValue <- <(Attribute* _ Identifier _ EQUALS String)> */
		func() bool {
			position76, tokenIndex76 := position, tokenIndex
			{
				position77 := position
			l78:
				{
					position79, tokenIndex79 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l79
					}
					goto l78
				l79:
					position, tokenIndex = position79, tokenIndex79
				}
				if !_rules[rule_]() {
					goto l76
				}
				if !_rules[ruleIdentifier]() {
					goto l76
				}
				if !_rules[rule_]() {
					goto l76
				}
				if !_rules[ruleEQUALS]() {
					goto l76
				}
				if !_rules[ruleString]() {
					goto l76
				}
				add(ruleEnumValue, position77)
			}
			return true
		l76:
			position, tokenIndex = position76, tokenIndex76
			return false
		},
		/* 18 DispatchStmt <- <('d' 'i' 's' 'p' 'a' 't' 'c' 'h' _ DispatchPath _ ('t' 'o') _ DispatchTarget)> */
		func() bool {
			position80, tokenIndex80 := position, tokenIndex
			{
				position81 := position
				if buffer[position] != rune('d') {
					goto l80
				}
				position++
				if buffer[position] != rune('i') {
					goto l80
				}
				position++
				if buffer[position] != rune('s') {
					goto l80
				}
				position++
				if buffer[position] != rune('p') {
					goto l80
				}
				position++
				if buffer[position] != rune('a') {
					goto l80
				}
				position++
				if buffer[position] != rune('t') {
					goto l80
				}
				position++
				if buffer[position] != rune('c') {
					goto l80
				}
				position++
				if buffer[position] != rune('h') {
					goto l80
				}
				position++
				if !_rules[rule_]() {
					goto l80
				}
				if !_rules[ruleDispatchPath]() {
					goto l80
				}
				if !_rules[rule_]() {
					goto l80
				}
				if buffer[position] != rune('t') {
					goto l80
				}
				position++
				if buffer[position] != rune('o') {
					goto l80
				}
				position++
				if !_rules[rule_]() {
					goto l80
				}
				if !_rules[ruleDispatchTarget]() {
					goto l80
				}
				add(ruleDispatchStmt, position81)
			}
			return true
		l80:
			position, tokenIndex = position80, tokenIndex80
			return false
		},
		/* 19 DispatchPath <- <(Identifier COLON ResourcePath LBRACKET DispatchKeyList RBRACKET (LT GenericTypeParams RT)?)> */
		func() bool {
			position82, tokenIndex82 := position, tokenIndex
			{
				position83 := position
				if !_rules[ruleIdentifier]() {
					goto l82
				}
				if !_rules[ruleCOLON]() {
					goto l82
				}
				if !_rules[ruleResourcePath]() {
					goto l82
				}
				if !_rules[ruleLBRACKET]() {
					goto l82
				}
				if !_rules[ruleDispatchKeyList]() {
					goto l82
				}
				if !_rules[ruleRBRACKET]() {
					goto l82
				}
				{
					position84, tokenIndex84 := position, tokenIndex
					if !_rules[ruleLT]() {
						goto l84
					}
					if !_rules[ruleGenericTypeParams]() {
						goto l84
					}
					if !_rules[ruleRT]() {
						goto l84
					}
					goto l85
				l84:
					position, tokenIndex = position84, tokenIndex84
				}
			l85:
				add(ruleDispatchPath, position83)
			}
			return true
		l82:
			position, tokenIndex = position82, tokenIndex82
			return false
		},
		/* 20 DispatchKeyList <- <(DispatchKey (COMMA DispatchKey)* COMMA?)> */
		func() bool {
			position86, tokenIndex86 := position, tokenIndex
			{
				position87 := position
				if !_rules[ruleDispatchKey]() {
					goto l86
				}
			l88:
				{
					position89, tokenIndex89 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l89
					}
					if !_rules[ruleDispatchKey]() {
						goto l89
					}
					goto l88
				l89:
					position, tokenIndex = position89, tokenIndex89
				}
				{
					position90, tokenIndex90 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l90
					}
					goto l91
				l90:
					position, tokenIndex = position90, tokenIndex90
				}
			l91:
				add(ruleDispatchKeyList, position87)
			}
			return true
		l86:
			position, tokenIndex = position86, tokenIndex86
			return false
		},
		/* 21 DispatchKey <- <(StaticIndexKey / String / Identifier)> */
		func() bool {
			position92, tokenIndex92 := position, tokenIndex
			{
				position93 := position
				{
					position94, tokenIndex94 := position, tokenIndex
					if !_rules[ruleStaticIndexKey]() {
						goto l95
					}
					goto l94
				l95:
					position, tokenIndex = position94, tokenIndex94
					if !_rules[ruleString]() {
						goto l96
					}
					goto l94
				l96:
					position, tokenIndex = position94, tokenIndex94
					if !_rules[ruleIdentifier]() {
						goto l92
					}
				}
			l94:
				add(ruleDispatchKey, position93)
			}
			return true
		l92:
			position, tokenIndex = position92, tokenIndex92
			return false
		},
		/* 22 DispatchTarget <- <(('s' 't' 'r' 'u' 'c' 't' _ Identifier _ LBRACE FieldList? RBRACE) / Type)> */
		func() bool {
			position97, tokenIndex97 := position, tokenIndex
			{
				position98 := position
				{
					position99, tokenIndex99 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l100
					}
					position++
					if buffer[position] != rune('t') {
						goto l100
					}
					position++
					if buffer[position] != rune('r') {
						goto l100
					}
					position++
					if buffer[position] != rune('u') {
						goto l100
					}
					position++
					if buffer[position] != rune('c') {
						goto l100
					}
					position++
					if buffer[position] != rune('t') {
						goto l100
					}
					position++
					if !_rules[rule_]() {
						goto l100
					}
					if !_rules[ruleIdentifier]() {
						goto l100
					}
					if !_rules[rule_]() {
						goto l100
					}
					if !_rules[ruleLBRACE]() {
						goto l100
					}
					{
						position101, tokenIndex101 := position, tokenIndex
						if !_rules[ruleFieldList]() {
							goto l101
						}
						goto l102
					l101:
						position, tokenIndex = position101, tokenIndex101
					}
				l102:
					if !_rules[ruleRBRACE]() {
						goto l100
					}
					goto l99
				l100:
					position, tokenIndex = position99, tokenIndex99
					if !_rules[ruleType]() {
						goto l97
					}
				}
			l99:
				add(ruleDispatchTarget, position98)
			}
			return true
		l97:
			position, tokenIndex = position97, tokenIndex97
			return false
		},
		/* 23 SpreadStruct <- <(SPREAD ('s' 't' 'r' 'u' 'c' 't') _ Identifier _ LBRACE FieldList? RBRACE)> */
		nil,
		/* 24 Type <- <(UnionType / AttributedType / ArrayType / StructType / ConstrainedType / GenericType / PrimitiveType / ReferenceType / LiteralType)> */
		func() bool {
			position104, tokenIndex104 := position, tokenIndex
			{
				position105 := position
				{
					position106, tokenIndex106 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l107
					}
					goto l106
				l107:
					position, tokenIndex = position106, tokenIndex106
					if !_rules[ruleAttributedType]() {
						goto l108
					}
					goto l106
				l108:
					position, tokenIndex = position106, tokenIndex106
					if !_rules[ruleArrayType]() {
						goto l109
					}
					goto l106
				l109:
					position, tokenIndex = position106, tokenIndex106
					if !_rules[ruleStructType]() {
						goto l110
					}
					goto l106
				l110:
					position, tokenIndex = position106, tokenIndex106
					if !_rules[ruleConstrainedType]() {
						goto l111
					}
					goto l106
				l111:
					position, tokenIndex = position106, tokenIndex106
					if !_rules[ruleGenericType]() {
						goto l112
					}
					goto l106
				l112:
					position, tokenIndex = position106, tokenIndex106
					if !_rules[rulePrimitiveType]() {
						goto l113
					}
					goto l106
				l113:
					position, tokenIndex = position106, tokenIndex106
					if !_rules[ruleReferenceType]() {
						goto l114
					}
					goto l106
				l114:
					position, tokenIndex = position106, tokenIndex106
					if !_rules[ruleLiteralType]() {
						goto l104
					}
				}
			l106:
				add(ruleType, position105)
			}
			return true
		l104:
			position, tokenIndex = position104, tokenIndex104
			return false
		},
		/* 25 AttributedType <- <(Attribute+ _ (UnionType / ArrayType / ConstrainedType / StructType / GenericType / PrimitiveType / ReferenceType / LiteralType))> */
		func() bool {
			position115, tokenIndex115 := position, tokenIndex
			{
				position116 := position
				if !_rules[ruleAttribute]() {
					goto l115
				}
			l117:
				{
					position118, tokenIndex118 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l118
					}
					goto l117
				l118:
					position, tokenIndex = position118, tokenIndex118
				}
				if !_rules[rule_]() {
					goto l115
				}
				{
					position119, tokenIndex119 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l120
					}
					goto l119
				l120:
					position, tokenIndex = position119, tokenIndex119
					if !_rules[ruleArrayType]() {
						goto l121
					}
					goto l119
				l121:
					position, tokenIndex = position119, tokenIndex119
					if !_rules[ruleConstrainedType]() {
						goto l122
					}
					goto l119
				l122:
					position, tokenIndex = position119, tokenIndex119
					if !_rules[ruleStructType]() {
						goto l123
					}
					goto l119
				l123:
					position, tokenIndex = position119, tokenIndex119
					if !_rules[ruleGenericType]() {
						goto l124
					}
					goto l119
				l124:
					position, tokenIndex = position119, tokenIndex119
					if !_rules[rulePrimitiveType]() {
						goto l125
					}
					goto l119
				l125:
					position, tokenIndex = position119, tokenIndex119
					if !_rules[ruleReferenceType]() {
						goto l126
					}
					goto l119
				l126:
					position, tokenIndex = position119, tokenIndex119
					if !_rules[ruleLiteralType]() {
						goto l115
					}
				}
			l119:
				add(ruleAttributedType, position116)
			}
			return true
		l115:
			position, tokenIndex = position115, tokenIndex115
			return false
		},
		/* 26 ConstrainedType <- <((PrimitiveType / ReferenceType / LiteralType) ArrayConstraint)> */
		func() bool {
			position127, tokenIndex127 := position, tokenIndex
			{
				position128 := position
				{
					position129, tokenIndex129 := position, tokenIndex
					if !_rules[rulePrimitiveType]() {
						goto l130
					}
					goto l129
				l130:
					position, tokenIndex = position129, tokenIndex129
					if !_rules[ruleReferenceType]() {
						goto l131
					}
					goto l129
				l131:
					position, tokenIndex = position129, tokenIndex129
					if !_rules[ruleLiteralType]() {
						goto l127
					}
				}
			l129:
				if !_rules[ruleArrayConstraint]() {
					goto l127
				}
				add(ruleConstrainedType, position128)
			}
			return true
		l127:
			position, tokenIndex = position127, tokenIndex127
			return false
		},
		/* 27 UnionType <- <(LPAREN Type (PIPE Type)* PIPE? RPAREN)> */
		func() bool {
			position132, tokenIndex132 := position, tokenIndex
			{
				position133 := position
				if !_rules[ruleLPAREN]() {
					goto l132
				}
				if !_rules[ruleType]() {
					goto l132
				}
			l134:
				{
					position135, tokenIndex135 := position, tokenIndex
					if !_rules[rulePIPE]() {
						goto l135
					}
					if !_rules[ruleType]() {
						goto l135
					}
					goto l134
				l135:
					position, tokenIndex = position135, tokenIndex135
				}
				{
					position136, tokenIndex136 := position, tokenIndex
					if !_rules[rulePIPE]() {
						goto l136
					}
					goto l137
				l136:
					position, tokenIndex = position136, tokenIndex136
				}
			l137:
				if !_rules[ruleRPAREN]() {
					goto l132
				}
				add(ruleUnionType, position133)
			}
			return true
		l132:
			position, tokenIndex = position132, tokenIndex132
			return false
		},
		/* 28 ArrayType <- <((LBRACKET Type RBRACKET ArrayConstraint?) / (PrimitiveType LBRACKET RBRACKET) / (ReferenceType LBRACKET RBRACKET))> */
		func() bool {
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				{
					position140, tokenIndex140 := position, tokenIndex
					if !_rules[ruleLBRACKET]() {
						goto l141
					}
					if !_rules[ruleType]() {
						goto l141
					}
					if !_rules[ruleRBRACKET]() {
						goto l141
					}
					{
						position142, tokenIndex142 := position, tokenIndex
						if !_rules[ruleArrayConstraint]() {
							goto l142
						}
						goto l143
					l142:
						position, tokenIndex = position142, tokenIndex142
					}
				l143:
					goto l140
				l141:
					position, tokenIndex = position140, tokenIndex140
					if !_rules[rulePrimitiveType]() {
						goto l144
					}
					if !_rules[ruleLBRACKET]() {
						goto l144
					}
					if !_rules[ruleRBRACKET]() {
						goto l144
					}
					goto l140
				l144:
					position, tokenIndex = position140, tokenIndex140
					if !_rules[ruleReferenceType]() {
						goto l138
					}
					if !_rules[ruleLBRACKET]() {
						goto l138
					}
					if !_rules[ruleRBRACKET]() {
						goto l138
					}
				}
			l140:
				add(ruleArrayType, position139)
			}
			return true
		l138:
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 29 StructType <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier? _ LBRACE FieldList? RBRACE)> */
		func() bool {
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				if buffer[position] != rune('s') {
					goto l145
				}
				position++
				if buffer[position] != rune('t') {
					goto l145
				}
				position++
				if buffer[position] != rune('r') {
					goto l145
				}
				position++
				if buffer[position] != rune('u') {
					goto l145
				}
				position++
				if buffer[position] != rune('c') {
					goto l145
				}
				position++
				if buffer[position] != rune('t') {
					goto l145
				}
				position++
				if !_rules[rule_]() {
					goto l145
				}
				{
					position147, tokenIndex147 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l147
					}
					goto l148
				l147:
					position, tokenIndex = position147, tokenIndex147
				}
			l148:
				if !_rules[rule_]() {
					goto l145
				}
				if !_rules[ruleLBRACE]() {
					goto l145
				}
				{
					position149, tokenIndex149 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l149
					}
					goto l150
				l149:
					position, tokenIndex = position149, tokenIndex149
				}
			l150:
				if !_rules[ruleRBRACE]() {
					goto l145
				}
				add(ruleStructType, position146)
			}
			return true
		l145:
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 30 GenericType <- <(Identifier LT GenericTypeParams RT)> */
		func() bool {
			position151, tokenIndex151 := position, tokenIndex
			{
				position152 := position
				if !_rules[ruleIdentifier]() {
					goto l151
				}
				if !_rules[ruleLT]() {
					goto l151
				}
				if !_rules[ruleGenericTypeParams]() {
					goto l151
				}
				if !_rules[ruleRT]() {
					goto l151
				}
				add(ruleGenericType, position152)
			}
			return true
		l151:
			position, tokenIndex = position151, tokenIndex151
			return false
		},
		/* 31 GenericTypeParams <- <(Type (COMMA Type)*)> */
		func() bool {
			position153, tokenIndex153 := position, tokenIndex
			{
				position154 := position
				if !_rules[ruleType]() {
					goto l153
				}
			l155:
				{
					position156, tokenIndex156 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l156
					}
					if !_rules[ruleType]() {
						goto l156
					}
					goto l155
				l156:
					position, tokenIndex = position156, tokenIndex156
				}
				add(ruleGenericTypeParams, position154)
			}
			return true
		l153:
			position, tokenIndex = position153, tokenIndex153
			return false
		},
		/* 32 PrimitiveType <- <((('s' 't' 'r' 'i' 'n' 'g') / ('d' 'o' 'u' 'b' 'l' 'e') / ('f' 'l' 'o' 'a' 't') / ('i' 'n' 't') / ('b' 'o' 'o' 'l' 'e' 'a' 'n') / ('a' 'n' 'y')) _)> */
		func() bool {
			position157, tokenIndex157 := position, tokenIndex
			{
				position158 := position
				{
					position159, tokenIndex159 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l160
					}
					position++
					if buffer[position] != rune('t') {
						goto l160
					}
					position++
					if buffer[position] != rune('r') {
						goto l160
					}
					position++
					if buffer[position] != rune('i') {
						goto l160
					}
					position++
					if buffer[position] != rune('n') {
						goto l160
					}
					position++
					if buffer[position] != rune('g') {
						goto l160
					}
					position++
					goto l159
				l160:
					position, tokenIndex = position159, tokenIndex159
					if buffer[position] != rune('d') {
						goto l161
					}
					position++
					if buffer[position] != rune('o') {
						goto l161
					}
					position++
					if buffer[position] != rune('u') {
						goto l161
					}
					position++
					if buffer[position] != rune('b') {
						goto l161
					}
					position++
					if buffer[position] != rune('l') {
						goto l161
					}
					position++
					if buffer[position] != rune('e') {
						goto l161
					}
					position++
					goto l159
				l161:
					position, tokenIndex = position159, tokenIndex159
					if buffer[position] != rune('f') {
						goto l162
					}
					position++
					if buffer[position] != rune('l') {
						goto l162
					}
					position++
					if buffer[position] != rune('o') {
						goto l162
					}
					position++
					if buffer[position] != rune('a') {
						goto l162
					}
					position++
					if buffer[position] != rune('t') {
						goto l162
					}
					position++
					goto l159
				l162:
					position, tokenIndex = position159, tokenIndex159
					if buffer[position] != rune('i') {
						goto l163
					}
					position++
					if buffer[position] != rune('n') {
						goto l163
					}
					position++
					if buffer[position] != rune('t') {
						goto l163
					}
					position++
					goto l159
				l163:
					position, tokenIndex = position159, tokenIndex159
					if buffer[position] != rune('b') {
						goto l164
					}
					position++
					if buffer[position] != rune('o') {
						goto l164
					}
					position++
					if buffer[position] != rune('o') {
						goto l164
					}
					position++
					if buffer[position] != rune('l') {
						goto l164
					}
					position++
					if buffer[position] != rune('e') {
						goto l164
					}
					position++
					if buffer[position] != rune('a') {
						goto l164
					}
					position++
					if buffer[position] != rune('n') {
						goto l164
					}
					position++
					goto l159
				l164:
					position, tokenIndex = position159, tokenIndex159
					if buffer[position] != rune('a') {
						goto l157
					}
					position++
					if buffer[position] != rune('n') {
						goto l157
					}
					position++
					if buffer[position] != rune('y') {
						goto l157
					}
					position++
				}
			l159:
				if !_rules[rule_]() {
					goto l157
				}
				add(rulePrimitiveType, position158)
			}
			return true
		l157:
			position, tokenIndex = position157, tokenIndex157
			return false
		},
		/* 33 ReferenceType <- <(ComplexReference / Path / Identifier)> */
		func() bool {
			position165, tokenIndex165 := position, tokenIndex
			{
				position166 := position
				{
					position167, tokenIndex167 := position, tokenIndex
					if !_rules[ruleComplexReference]() {
						goto l168
					}
					goto l167
				l168:
					position, tokenIndex = position167, tokenIndex167
					if !_rules[rulePath]() {
						goto l169
					}
					goto l167
				l169:
					position, tokenIndex = position167, tokenIndex167
					if !_rules[ruleIdentifier]() {
						goto l165
					}
				}
			l167:
				add(ruleReferenceType, position166)
			}
			return true
		l165:
			position, tokenIndex = position165, tokenIndex165
			return false
		},
		/* 34 ComplexReference <- <(Identifier COLON ResourcePath ((LBRACKET LBRACKET ComplexRefParam RBRACKET RBRACKET) / (LBRACKET ComplexRefParam RBRACKET)) (LT GenericTypeParams RT)?)> */
		func() bool {
			position170, tokenIndex170 := position, tokenIndex
			{
				position171 := position
				if !_rules[ruleIdentifier]() {
					goto l170
				}
				if !_rules[ruleCOLON]() {
					goto l170
				}
				if !_rules[ruleResourcePath]() {
					goto l170
				}
				{
					position172, tokenIndex172 := position, tokenIndex
					if !_rules[ruleLBRACKET]() {
						goto l173
					}
					if !_rules[ruleLBRACKET]() {
						goto l173
					}
					if !_rules[ruleComplexRefParam]() {
						goto l173
					}
					if !_rules[ruleRBRACKET]() {
						goto l173
					}
					if !_rules[ruleRBRACKET]() {
						goto l173
					}
					goto l172
				l173:
					position, tokenIndex = position172, tokenIndex172
					if !_rules[ruleLBRACKET]() {
						goto l170
					}
					if !_rules[ruleComplexRefParam]() {
						goto l170
					}
					if !_rules[ruleRBRACKET]() {
						goto l170
					}
				}
			l172:
				{
					position174, tokenIndex174 := position, tokenIndex
					if !_rules[ruleLT]() {
						goto l174
					}
					if !_rules[ruleGenericTypeParams]() {
						goto l174
					}
					if !_rules[ruleRT]() {
						goto l174
					}
					goto l175
				l174:
					position, tokenIndex = position174, tokenIndex174
				}
			l175:
				add(ruleComplexReference, position171)
			}
			return true
		l170:
			position, tokenIndex = position170, tokenIndex170
			return false
		},
		/* 35 ResourcePath <- <(Identifier ('/' Identifier)*)> */
		func() bool {
			position176, tokenIndex176 := position, tokenIndex
			{
				position177 := position
				if !_rules[ruleIdentifier]() {
					goto l176
				}
			l178:
				{
					position179, tokenIndex179 := position, tokenIndex
					if buffer[position] != rune('/') {
						goto l179
					}
					position++
					if !_rules[ruleIdentifier]() {
						goto l179
					}
					goto l178
				l179:
					position, tokenIndex = position179, tokenIndex179
				}
				add(ruleResourcePath, position177)
			}
			return true
		l176:
			position, tokenIndex = position176, tokenIndex176
			return false
		},
		/* 36 ComplexRefParam <- <(DottedPath / StaticIndexKey / String / Identifier)> */
		func() bool {
			position180, tokenIndex180 := position, tokenIndex
			{
				position181 := position
				{
					position182, tokenIndex182 := position, tokenIndex
					if !_rules[ruleDottedPath]() {
						goto l183
					}
					goto l182
				l183:
					position, tokenIndex = position182, tokenIndex182
					if !_rules[ruleStaticIndexKey]() {
						goto l184
					}
					goto l182
				l184:
					position, tokenIndex = position182, tokenIndex182
					if !_rules[ruleString]() {
						goto l185
					}
					goto l182
				l185:
					position, tokenIndex = position182, tokenIndex182
					if !_rules[ruleIdentifier]() {
						goto l180
					}
				}
			l182:
				add(ruleComplexRefParam, position181)
			}
			return true
		l180:
			position, tokenIndex = position180, tokenIndex180
			return false
		},
		/* 37 DottedPath <- <((StaticIndexKey / Identifier) ('.' Identifier)+)> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				{
					position188, tokenIndex188 := position, tokenIndex
					if !_rules[ruleStaticIndexKey]() {
						goto l189
					}
					goto l188
				l189:
					position, tokenIndex = position188, tokenIndex188
					if !_rules[ruleIdentifier]() {
						goto l186
					}
				}
			l188:
				if buffer[position] != rune('.') {
					goto l186
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l186
				}
			l190:
				{
					position191, tokenIndex191 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l191
					}
					position++
					if !_rules[ruleIdentifier]() {
						goto l191
					}
					goto l190
				l191:
					position, tokenIndex = position191, tokenIndex191
				}
				add(ruleDottedPath, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 38 StaticIndexKey <- <((('%' 'f' 'a' 'l' 'l' 'b' 'a' 'c' 'k') / ('%' 'k' 'e' 'y') / ('%' 'p' 'a' 'r' 'e' 'n' 't') / ('%' 'n' 'o' 'n' 'e') / ('%' 'u' 'n' 'k' 'n' 'o' 'w' 'n')) _)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				{
					position194, tokenIndex194 := position, tokenIndex
					if buffer[position] != rune('%') {
						goto l195
					}
					position++
					if buffer[position] != rune('f') {
						goto l195
					}
					position++
					if buffer[position] != rune('a') {
						goto l195
					}
					position++
					if buffer[position] != rune('l') {
						goto l195
					}
					position++
					if buffer[position] != rune('l') {
						goto l195
					}
					position++
					if buffer[position] != rune('b') {
						goto l195
					}
					position++
					if buffer[position] != rune('a') {
						goto l195
					}
					position++
					if buffer[position] != rune('c') {
						goto l195
					}
					position++
					if buffer[position] != rune('k') {
						goto l195
					}
					position++
					goto l194
				l195:
					position, tokenIndex = position194, tokenIndex194
					if buffer[position] != rune('%') {
						goto l196
					}
					position++
					if buffer[position] != rune('k') {
						goto l196
					}
					position++
					if buffer[position] != rune('e') {
						goto l196
					}
					position++
					if buffer[position] != rune('y') {
						goto l196
					}
					position++
					goto l194
				l196:
					position, tokenIndex = position194, tokenIndex194
					if buffer[position] != rune('%') {
						goto l197
					}
					position++
					if buffer[position] != rune('p') {
						goto l197
					}
					position++
					if buffer[position] != rune('a') {
						goto l197
					}
					position++
					if buffer[position] != rune('r') {
						goto l197
					}
					position++
					if buffer[position] != rune('e') {
						goto l197
					}
					position++
					if buffer[position] != rune('n') {
						goto l197
					}
					position++
					if buffer[position] != rune('t') {
						goto l197
					}
					position++
					goto l194
				l197:
					position, tokenIndex = position194, tokenIndex194
					if buffer[position] != rune('%') {
						goto l198
					}
					position++
					if buffer[position] != rune('n') {
						goto l198
					}
					position++
					if buffer[position] != rune('o') {
						goto l198
					}
					position++
					if buffer[position] != rune('n') {
						goto l198
					}
					position++
					if buffer[position] != rune('e') {
						goto l198
					}
					position++
					goto l194
				l198:
					position, tokenIndex = position194, tokenIndex194
					if buffer[position] != rune('%') {
						goto l192
					}
					position++
					if buffer[position] != rune('u') {
						goto l192
					}
					position++
					if buffer[position] != rune('n') {
						goto l192
					}
					position++
					if buffer[position] != rune('k') {
						goto l192
					}
					position++
					if buffer[position] != rune('n') {
						goto l192
					}
					position++
					if buffer[position] != rune('o') {
						goto l192
					}
					position++
					if buffer[position] != rune('w') {
						goto l192
					}
					position++
					if buffer[position] != rune('n') {
						goto l192
					}
					position++
				}
			l194:
				if !_rules[rule_]() {
					goto l192
				}
				add(ruleStaticIndexKey, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 39 LiteralType <- <(String / Number / Boolean)> */
		func() bool {
			position199, tokenIndex199 := position, tokenIndex
			{
				position200 := position
				{
					position201, tokenIndex201 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l202
					}
					goto l201
				l202:
					position, tokenIndex = position201, tokenIndex201
					if !_rules[ruleNumber]() {
						goto l203
					}
					goto l201
				l203:
					position, tokenIndex = position201, tokenIndex201
					if !_rules[ruleBoolean]() {
						goto l199
					}
				}
			l201:
				add(ruleLiteralType, position200)
			}
			return true
		l199:
			position, tokenIndex = position199, tokenIndex199
			return false
		},
		/* 40 ArrayConstraint <- <(AT (Range / Number))> */
		func() bool {
			position204, tokenIndex204 := position, tokenIndex
			{
				position205 := position
				if !_rules[ruleAT]() {
					goto l204
				}
				{
					position206, tokenIndex206 := position, tokenIndex
					if !_rules[ruleRange]() {
						goto l207
					}
					goto l206
				l207:
					position, tokenIndex = position206, tokenIndex206
					if !_rules[ruleNumber]() {
						goto l204
					}
				}
			l206:
				add(ruleArrayConstraint, position205)
			}
			return true
		l204:
			position, tokenIndex = position204, tokenIndex204
			return false
		},
		/* 41 Range <- <((Number RangeOperator Number) / (Number RangeOperator) / (RangeOperator Number))> */
		func() bool {
			position208, tokenIndex208 := position, tokenIndex
			{
				position209 := position
				{
					position210, tokenIndex210 := position, tokenIndex
					if !_rules[ruleNumber]() {
						goto l211
					}
					if !_rules[ruleRangeOperator]() {
						goto l211
					}
					if !_rules[ruleNumber]() {
						goto l211
					}
					goto l210
				l211:
					position, tokenIndex = position210, tokenIndex210
					if !_rules[ruleNumber]() {
						goto l212
					}
					if !_rules[ruleRangeOperator]() {
						goto l212
					}
					goto l210
				l212:
					position, tokenIndex = position210, tokenIndex210
					if !_rules[ruleRangeOperator]() {
						goto l208
					}
					if !_rules[ruleNumber]() {
						goto l208
					}
				}
			l210:
				add(ruleRange, position209)
			}
			return true
		l208:
			position, tokenIndex = position208, tokenIndex208
			return false
		},
		/* 42 RangeOperator <- <(LT? DOTDOT LT?)> */
		func() bool {
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				{
					position215, tokenIndex215 := position, tokenIndex
					if !_rules[ruleLT]() {
						goto l215
					}
					goto l216
				l215:
					position, tokenIndex = position215, tokenIndex215
				}
			l216:
				if !_rules[ruleDOTDOT]() {
					goto l213
				}
				{
					position217, tokenIndex217 := position, tokenIndex
					if !_rules[ruleLT]() {
						goto l217
					}
					goto l218
				l217:
					position, tokenIndex = position217, tokenIndex217
				}
			l218:
				add(ruleRangeOperator, position214)
			}
			return true
		l213:
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 43 Attribute <- <('#' LBRACKET AttributeList RBRACKET)> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if buffer[position] != rune('#') {
					goto l219
				}
				position++
				if !_rules[ruleLBRACKET]() {
					goto l219
				}
				if !_rules[ruleAttributeList]() {
					goto l219
				}
				if !_rules[ruleRBRACKET]() {
					goto l219
				}
				add(ruleAttribute, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 44 AttributeList <- <(AttributeItem (COMMA AttributeItem)*)> */
		func() bool {
			position221, tokenIndex221 := position, tokenIndex
			{
				position222 := position
				if !_rules[ruleAttributeItem]() {
					goto l221
				}
			l223:
				{
					position224, tokenIndex224 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l224
					}
					if !_rules[ruleAttributeItem]() {
						goto l224
					}
					goto l223
				l224:
					position, tokenIndex = position224, tokenIndex224
				}
				add(ruleAttributeList, position222)
			}
			return true
		l221:
			position, tokenIndex = position221, tokenIndex221
			return false
		},
		/* 45 AttributeItem <- <(AttributePair / AttributeCall / AttributeCallWithEquals / Identifier)> */
		func() bool {
			position225, tokenIndex225 := position, tokenIndex
			{
				position226 := position
				{
					position227, tokenIndex227 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l228
					}
					goto l227
				l228:
					position, tokenIndex = position227, tokenIndex227
					if !_rules[ruleAttributeCall]() {
						goto l229
					}
					goto l227
				l229:
					position, tokenIndex = position227, tokenIndex227
					if !_rules[ruleAttributeCallWithEquals]() {
						goto l230
					}
					goto l227
				l230:
					position, tokenIndex = position227, tokenIndex227
					if !_rules[ruleIdentifier]() {
						goto l225
					}
				}
			l227:
				add(ruleAttributeItem, position226)
			}
			return true
		l225:
			position, tokenIndex = position225, tokenIndex225
			return false
		},
		/* 46 AttributeCallWithEquals <- <(Identifier EQUALS LPAREN AttributeParamList? RPAREN)> */
		func() bool {
			position231, tokenIndex231 := position, tokenIndex
			{
				position232 := position
				if !_rules[ruleIdentifier]() {
					goto l231
				}
				if !_rules[ruleEQUALS]() {
					goto l231
				}
				if !_rules[ruleLPAREN]() {
					goto l231
				}
				{
					position233, tokenIndex233 := position, tokenIndex
					if !_rules[ruleAttributeParamList]() {
						goto l233
					}
					goto l234
				l233:
					position, tokenIndex = position233, tokenIndex233
				}
			l234:
				if !_rules[ruleRPAREN]() {
					goto l231
				}
				add(ruleAttributeCallWithEquals, position232)
			}
			return true
		l231:
			position, tokenIndex = position231, tokenIndex231
			return false
		},
		/* 47 AttributeCall <- <(Identifier LPAREN AttributeParamList? RPAREN)> */
		func() bool {
			position235, tokenIndex235 := position, tokenIndex
			{
				position236 := position
				if !_rules[ruleIdentifier]() {
					goto l235
				}
				if !_rules[ruleLPAREN]() {
					goto l235
				}
				{
					position237, tokenIndex237 := position, tokenIndex
					if !_rules[ruleAttributeParamList]() {
						goto l237
					}
					goto l238
				l237:
					position, tokenIndex = position237, tokenIndex237
				}
			l238:
				if !_rules[ruleRPAREN]() {
					goto l235
				}
				add(ruleAttributeCall, position236)
			}
			return true
		l235:
			position, tokenIndex = position235, tokenIndex235
			return false
		},
		/* 48 AttributeParamList <- <(AttributeParam (COMMA AttributeParam)*)> */
		func() bool {
			position239, tokenIndex239 := position, tokenIndex
			{
				position240 := position
				if !_rules[ruleAttributeParam]() {
					goto l239
				}
			l241:
				{
					position242, tokenIndex242 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l242
					}
					if !_rules[ruleAttributeParam]() {
						goto l242
					}
					goto l241
				l242:
					position, tokenIndex = position242, tokenIndex242
				}
				add(ruleAttributeParamList, position240)
			}
			return true
		l239:
			position, tokenIndex = position239, tokenIndex239
			return false
		},
		/* 49 AttributeParam <- <(AttributePair / AttributeValue)> */
		func() bool {
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position245, tokenIndex245 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l246
					}
					goto l245
				l246:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruleAttributeValue]() {
						goto l243
					}
				}
			l245:
				add(ruleAttributeParam, position244)
			}
			return true
		l243:
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 50 AttributePair <- <(Identifier EQUALS AttributeValue)> */
		func() bool {
			position247, tokenIndex247 := position, tokenIndex
			{
				position248 := position
				if !_rules[ruleIdentifier]() {
					goto l247
				}
				if !_rules[ruleEQUALS]() {
					goto l247
				}
				if !_rules[ruleAttributeValue]() {
					goto l247
				}
				add(ruleAttributePair, position248)
			}
			return true
		l247:
			position, tokenIndex = position247, tokenIndex247
			return false
		},
		/* 51 AttributeValue <- <(ArrayLiteral / ComplexReference / String / Number / Boolean / Identifier)> */
		func() bool {
			position249, tokenIndex249 := position, tokenIndex
			{
				position250 := position
				{
					position251, tokenIndex251 := position, tokenIndex
					if !_rules[ruleArrayLiteral]() {
						goto l252
					}
					goto l251
				l252:
					position, tokenIndex = position251, tokenIndex251
					if !_rules[ruleComplexReference]() {
						goto l253
					}
					goto l251
				l253:
					position, tokenIndex = position251, tokenIndex251
					if !_rules[ruleString]() {
						goto l254
					}
					goto l251
				l254:
					position, tokenIndex = position251, tokenIndex251
					if !_rules[ruleNumber]() {
						goto l255
					}
					goto l251
				l255:
					position, tokenIndex = position251, tokenIndex251
					if !_rules[ruleBoolean]() {
						goto l256
					}
					goto l251
				l256:
					position, tokenIndex = position251, tokenIndex251
					if !_rules[ruleIdentifier]() {
						goto l249
					}
				}
			l251:
				add(ruleAttributeValue, position250)
			}
			return true
		l249:
			position, tokenIndex = position249, tokenIndex249
			return false
		},
		/* 52 ArrayLiteral <- <(LBRACKET (AttributeValue (COMMA AttributeValue)*)? RBRACKET)> */
		func() bool {
			position257, tokenIndex257 := position, tokenIndex
			{
				position258 := position
				if !_rules[ruleLBRACKET]() {
					goto l257
				}
				{
					position259, tokenIndex259 := position, tokenIndex
					if !_rules[ruleAttributeValue]() {
						goto l259
					}
				l261:
					{
						position262, tokenIndex262 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l262
						}
						if !_rules[ruleAttributeValue]() {
							goto l262
						}
						goto l261
					l262:
						position, tokenIndex = position262, tokenIndex262
					}
					goto l260
				l259:
					position, tokenIndex = position259, tokenIndex259
				}
			l260:
				if !_rules[ruleRBRACKET]() {
					goto l257
				}
				add(ruleArrayLiteral, position258)
			}
			return true
		l257:
			position, tokenIndex = position257, tokenIndex257
			return false
		},
		/* 53 Comment <- <('/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position263, tokenIndex263 := position, tokenIndex
			{
				position264 := position
				if buffer[position] != rune('/') {
					goto l263
				}
				position++
				if buffer[position] != rune('/') {
					goto l263
				}
				position++
			l265:
				{
					position266, tokenIndex266 := position, tokenIndex
					{
						position267, tokenIndex267 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l267
						}
						goto l266
					l267:
						position, tokenIndex = position267, tokenIndex267
					}
					if !matchDot() {
						goto l266
					}
					goto l265
				l266:
					position, tokenIndex = position266, tokenIndex266
				}
				{
					position268, tokenIndex268 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l269
					}
					goto l268
				l269:
					position, tokenIndex = position268, tokenIndex268
					{
						position270, tokenIndex270 := position, tokenIndex
						if !matchDot() {
							goto l270
						}
						goto l263
					l270:
						position, tokenIndex = position270, tokenIndex270
					}
				}
			l268:
				add(ruleComment, position264)
			}
			return true
		l263:
			position, tokenIndex = position263, tokenIndex263
			return false
		},
		/* 54 DocComment <- <('/' '/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position271, tokenIndex271 := position, tokenIndex
			{
				position272 := position
				if buffer[position] != rune('/') {
					goto l271
				}
				position++
				if buffer[position] != rune('/') {
					goto l271
				}
				position++
				if buffer[position] != rune('/') {
					goto l271
				}
				position++
			l273:
				{
					position274, tokenIndex274 := position, tokenIndex
					{
						position275, tokenIndex275 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l275
						}
						goto l274
					l275:
						position, tokenIndex = position275, tokenIndex275
					}
					if !matchDot() {
						goto l274
					}
					goto l273
				l274:
					position, tokenIndex = position274, tokenIndex274
				}
				{
					position276, tokenIndex276 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l277
					}
					goto l276
				l277:
					position, tokenIndex = position276, tokenIndex276
					{
						position278, tokenIndex278 := position, tokenIndex
						if !matchDot() {
							goto l278
						}
						goto l271
					l278:
						position, tokenIndex = position278, tokenIndex278
					}
				}
			l276:
				add(ruleDocComment, position272)
			}
			return true
		l271:
			position, tokenIndex = position271, tokenIndex271
			return false
		},
		/* 55 Identifier <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')* _)> */
		func() bool {
			position279, tokenIndex279 := position, tokenIndex
			{
				position280 := position
				{
					position281, tokenIndex281 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l282
					}
					position++
					goto l281
				l282:
					position, tokenIndex = position281, tokenIndex281
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l283
					}
					position++
					goto l281
				l283:
					position, tokenIndex = position281, tokenIndex281
					if buffer[position] != rune('_') {
						goto l279
					}
					position++
				}
			l281:
			l284:
				{
					position285, tokenIndex285 := position, tokenIndex
					{
						position286, tokenIndex286 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l287
						}
						position++
						goto l286
					l287:
						position, tokenIndex = position286, tokenIndex286
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l288
						}
						position++
						goto l286
					l288:
						position, tokenIndex = position286, tokenIndex286
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l289
						}
						position++
						goto l286
					l289:
						position, tokenIndex = position286, tokenIndex286
						if buffer[position] != rune('_') {
							goto l285
						}
						position++
					}
				l286:
					goto l284
				l285:
					position, tokenIndex = position285, tokenIndex285
				}
				if !_rules[rule_]() {
					goto l279
				}
				add(ruleIdentifier, position280)
			}
			return true
		l279:
			position, tokenIndex = position279, tokenIndex279
			return false
		},
		/* 56 String <- <('"' (!'"' .)* '"' _)> */
		func() bool {
			position290, tokenIndex290 := position, tokenIndex
			{
				position291 := position
				if buffer[position] != rune('"') {
					goto l290
				}
				position++
			l292:
				{
					position293, tokenIndex293 := position, tokenIndex
					{
						position294, tokenIndex294 := position, tokenIndex
						if buffer[position] != rune('"') {
							goto l294
						}
						position++
						goto l293
					l294:
						position, tokenIndex = position294, tokenIndex294
					}
					if !matchDot() {
						goto l293
					}
					goto l292
				l293:
					position, tokenIndex = position293, tokenIndex293
				}
				if buffer[position] != rune('"') {
					goto l290
				}
				position++
				if !_rules[rule_]() {
					goto l290
				}
				add(ruleString, position291)
			}
			return true
		l290:
			position, tokenIndex = position290, tokenIndex290
			return false
		},
		/* 57 Number <- <('-'? [0-9]+ ('.' [0-9]+)? _)> */
		func() bool {
			position295, tokenIndex295 := position, tokenIndex
			{
				position296 := position
				{
					position297, tokenIndex297 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l297
					}
					position++
					goto l298
				l297:
					position, tokenIndex = position297, tokenIndex297
				}
			l298:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l295
				}
				position++
			l299:
				{
					position300, tokenIndex300 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l300
					}
					position++
					goto l299
				l300:
					position, tokenIndex = position300, tokenIndex300
				}
				{
					position301, tokenIndex301 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l301
					}
					position++
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l301
					}
					position++
				l303:
					{
						position304, tokenIndex304 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l304
						}
						position++
						goto l303
					l304:
						position, tokenIndex = position304, tokenIndex304
					}
					goto l302
				l301:
					position, tokenIndex = position301, tokenIndex301
				}
			l302:
				if !_rules[rule_]() {
					goto l295
				}
				add(ruleNumber, position296)
			}
			return true
		l295:
			position, tokenIndex = position295, tokenIndex295
			return false
		},
		/* 58 Boolean <- <((('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e')) _)> */
		func() bool {
			position305, tokenIndex305 := position, tokenIndex
			{
				position306 := position
				{
					position307, tokenIndex307 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l308
					}
					position++
					if buffer[position] != rune('r') {
						goto l308
					}
					position++
					if buffer[position] != rune('u') {
						goto l308
					}
					position++
					if buffer[position] != rune('e') {
						goto l308
					}
					position++
					goto l307
				l308:
					position, tokenIndex = position307, tokenIndex307
					if buffer[position] != rune('f') {
						goto l305
					}
					position++
					if buffer[position] != rune('a') {
						goto l305
					}
					position++
					if buffer[position] != rune('l') {
						goto l305
					}
					position++
					if buffer[position] != rune('s') {
						goto l305
					}
					position++
					if buffer[position] != rune('e') {
						goto l305
					}
					position++
				}
			l307:
				if !_rules[rule_]() {
					goto l305
				}
				add(ruleBoolean, position306)
			}
			return true
		l305:
			position, tokenIndex = position305, tokenIndex305
			return false
		},
		/* 59 LBRACE <- <('{' _)> */
		func() bool {
			position309, tokenIndex309 := position, tokenIndex
			{
				position310 := position
				if buffer[position] != rune('{') {
					goto l309
				}
				position++
				if !_rules[rule_]() {
					goto l309
				}
				add(ruleLBRACE, position310)
			}
			return true
		l309:
			position, tokenIndex = position309, tokenIndex309
			return false
		},
		/* 60 RBRACE <- <('}' _)> */
		func() bool {
			position311, tokenIndex311 := position, tokenIndex
			{
				position312 := position
				if buffer[position] != rune('}') {
					goto l311
				}
				position++
				if !_rules[rule_]() {
					goto l311
				}
				add(ruleRBRACE, position312)
			}
			return true
		l311:
			position, tokenIndex = position311, tokenIndex311
			return false
		},
		/* 61 LBRACKET <- <('[' _)> */
		func() bool {
			position313, tokenIndex313 := position, tokenIndex
			{
				position314 := position
				if buffer[position] != rune('[') {
					goto l313
				}
				position++
				if !_rules[rule_]() {
					goto l313
				}
				add(ruleLBRACKET, position314)
			}
			return true
		l313:
			position, tokenIndex = position313, tokenIndex313
			return false
		},
		/* 62 RBRACKET <- <(']' _)> */
		func() bool {
			position315, tokenIndex315 := position, tokenIndex
			{
				position316 := position
				if buffer[position] != rune(']') {
					goto l315
				}
				position++
				if !_rules[rule_]() {
					goto l315
				}
				add(ruleRBRACKET, position316)
			}
			return true
		l315:
			position, tokenIndex = position315, tokenIndex315
			return false
		},
		/* 63 LPAREN <- <('(' _)> */
		func() bool {
			position317, tokenIndex317 := position, tokenIndex
			{
				position318 := position
				if buffer[position] != rune('(') {
					goto l317
				}
				position++
				if !_rules[rule_]() {
					goto l317
				}
				add(ruleLPAREN, position318)
			}
			return true
		l317:
			position, tokenIndex = position317, tokenIndex317
			return false
		},
		/* 64 RPAREN <- <(')' _)> */
		func() bool {
			position319, tokenIndex319 := position, tokenIndex
			{
				position320 := position
				if buffer[position] != rune(')') {
					goto l319
				}
				position++
				if !_rules[rule_]() {
					goto l319
				}
				add(ruleRPAREN, position320)
			}
			return true
		l319:
			position, tokenIndex = position319, tokenIndex319
			return false
		},
		/* 65 COMMA <- <(',' _)> */
		func() bool {
			position321, tokenIndex321 := position, tokenIndex
			{
				position322 := position
				if buffer[position] != rune(',') {
					goto l321
				}
				position++
				if !_rules[rule_]() {
					goto l321
				}
				add(ruleCOMMA, position322)
			}
			return true
		l321:
			position, tokenIndex = position321, tokenIndex321
			return false
		},
		/* 66 COLON <- <(':' _)> */
		func() bool {
			position323, tokenIndex323 := position, tokenIndex
			{
				position324 := position
				if buffer[position] != rune(':') {
					goto l323
				}
				position++
				if !_rules[rule_]() {
					goto l323
				}
				add(ruleCOLON, position324)
			}
			return true
		l323:
			position, tokenIndex = position323, tokenIndex323
			return false
		},
		/* 67 SEMICOLON <- <(';' _)> */
		nil,
		/* 68 EQUALS <- <('=' _)> */
		func() bool {
			position326, tokenIndex326 := position, tokenIndex
			{
				position327 := position
				if buffer[position] != rune('=') {
					goto l326
				}
				position++
				if !_rules[rule_]() {
					goto l326
				}
				add(ruleEQUALS, position327)
			}
			return true
		l326:
			position, tokenIndex = position326, tokenIndex326
			return false
		},
		/* 69 PIPE <- <('|' _)> */
		func() bool {
			position328, tokenIndex328 := position, tokenIndex
			{
				position329 := position
				if buffer[position] != rune('|') {
					goto l328
				}
				position++
				if !_rules[rule_]() {
					goto l328
				}
				add(rulePIPE, position329)
			}
			return true
		l328:
			position, tokenIndex = position328, tokenIndex328
			return false
		},
		/* 70 DOT <- <('.' _)> */
		nil,
		/* 71 SPREAD <- <('.' '.' '.' _)> */
		func() bool {
			position331, tokenIndex331 := position, tokenIndex
			{
				position332 := position
				if buffer[position] != rune('.') {
					goto l331
				}
				position++
				if buffer[position] != rune('.') {
					goto l331
				}
				position++
				if buffer[position] != rune('.') {
					goto l331
				}
				position++
				if !_rules[rule_]() {
					goto l331
				}
				add(ruleSPREAD, position332)
			}
			return true
		l331:
			position, tokenIndex = position331, tokenIndex331
			return false
		},
		/* 72 AT <- <('@' _)> */
		func() bool {
			position333, tokenIndex333 := position, tokenIndex
			{
				position334 := position
				if buffer[position] != rune('@') {
					goto l333
				}
				position++
				if !_rules[rule_]() {
					goto l333
				}
				add(ruleAT, position334)
			}
			return true
		l333:
			position, tokenIndex = position333, tokenIndex333
			return false
		},
		/* 73 LT <- <('<' _)> */
		func() bool {
			position335, tokenIndex335 := position, tokenIndex
			{
				position336 := position
				if buffer[position] != rune('<') {
					goto l335
				}
				position++
				if !_rules[rule_]() {
					goto l335
				}
				add(ruleLT, position336)
			}
			return true
		l335:
			position, tokenIndex = position335, tokenIndex335
			return false
		},
		/* 74 RT <- <('>' _)> */
		func() bool {
			position337, tokenIndex337 := position, tokenIndex
			{
				position338 := position
				if buffer[position] != rune('>') {
					goto l337
				}
				position++
				if !_rules[rule_]() {
					goto l337
				}
				add(ruleRT, position338)
			}
			return true
		l337:
			position, tokenIndex = position337, tokenIndex337
			return false
		},
		/* 75 DOTDOT <- <('.' '.' _)> */
		func() bool {
			position339, tokenIndex339 := position, tokenIndex
			{
				position340 := position
				if buffer[position] != rune('.') {
					goto l339
				}
				position++
				if buffer[position] != rune('.') {
					goto l339
				}
				position++
				if !_rules[rule_]() {
					goto l339
				}
				add(ruleDOTDOT, position340)
			}
			return true
		l339:
			position, tokenIndex = position339, tokenIndex339
			return false
		},
		/* 76 QUESTION <- <('?' _)> */
		func() bool {
			position341, tokenIndex341 := position, tokenIndex
			{
				position342 := position
				if buffer[position] != rune('?') {
					goto l341
				}
				position++
				if !_rules[rule_]() {
					goto l341
				}
				add(ruleQUESTION, position342)
			}
			return true
		l341:
			position, tokenIndex = position341, tokenIndex341
			return false
		},
		/* 77 DoubleColon <- <(':' ':' _)> */
		func() bool {
			position343, tokenIndex343 := position, tokenIndex
			{
				position344 := position
				if buffer[position] != rune(':') {
					goto l343
				}
				position++
				if buffer[position] != rune(':') {
					goto l343
				}
				position++
				if !_rules[rule_]() {
					goto l343
				}
				add(ruleDoubleColon, position344)
			}
			return true
		l343:
			position, tokenIndex = position343, tokenIndex343
			return false
		},
		/* 78 SingleColon <- <(':' _)> */
		nil,
		/* 79 _ <- <(' ' / '\t' / '\r' / '\n' / Comment / DocComment)*> */
		func() bool {
			{
				position347 := position
			l348:
				{
					position349, tokenIndex349 := position, tokenIndex
					{
						position350, tokenIndex350 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l351
						}
						position++
						goto l350
					l351:
						position, tokenIndex = position350, tokenIndex350
						if buffer[position] != rune('\t') {
							goto l352
						}
						position++
						goto l350
					l352:
						position, tokenIndex = position350, tokenIndex350
						if buffer[position] != rune('\r') {
							goto l353
						}
						position++
						goto l350
					l353:
						position, tokenIndex = position350, tokenIndex350
						if buffer[position] != rune('\n') {
							goto l354
						}
						position++
						goto l350
					l354:
						position, tokenIndex = position350, tokenIndex350
						if !_rules[ruleComment]() {
							goto l355
						}
						goto l350
					l355:
						position, tokenIndex = position350, tokenIndex350
						if !_rules[ruleDocComment]() {
							goto l349
						}
					}
				l350:
					goto l348
				l349:
					position, tokenIndex = position349, tokenIndex349
				}
				add(rule_, position347)
			}
			return true
		},
		/* 80 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position356, tokenIndex356 := position, tokenIndex
			{
				position357 := position
				{
					position358, tokenIndex358 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l359
					}
					position++
					if buffer[position] != rune('\n') {
						goto l359
					}
					position++
					goto l358
				l359:
					position, tokenIndex = position358, tokenIndex358
					if buffer[position] != rune('\n') {
						goto l360
					}
					position++
					goto l358
				l360:
					position, tokenIndex = position358, tokenIndex358
					if buffer[position] != rune('\r') {
						goto l356
					}
					position++
				}
			l358:
				add(ruleEOL, position357)
			}
			return true
		l356:
			position, tokenIndex = position356, tokenIndex356
			return false
		},
	}
	p.rules = _rules
	return nil
}
