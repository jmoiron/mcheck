package main

// Code generated by peg grammar.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleStart
	ruleStatement
	ruleUseStmt
	ruleUsePath
	ruleTypeAlias
	ruleTypeName
	ruleStructDef
	ruleFieldList
	ruleFieldOrSpread
	ruleField
	ruleComputedField
	ruleNamedField
	ruleSpreadField
	ruleFieldName
	ruleEnumDef
	ruleEnumValueList
	ruleEnumValue
	ruleDispatchStmt
	ruleDispatchPath
	ruleDispatchKeyList
	ruleDispatchKey
	ruleDispatchTarget
	ruleSpreadStruct
	ruleType
	ruleAttributedType
	ruleConstrainedType
	ruleUnionType
	ruleArrayType
	ruleStructType
	ruleGenericType
	ruleGenericTypeParams
	rulePrimitiveType
	ruleReferenceType
	ruleComplexReference
	ruleResourcePath
	ruleComplexRefParam
	ruleDottedPath
	ruleStaticIndexKey
	ruleLiteralType
	ruleArrayConstraint
	ruleRange
	ruleAttribute
	ruleAttributeList
	ruleAttributeItem
	ruleAttributeCallWithEquals
	ruleAttributeCall
	ruleAttributeParamList
	ruleAttributeParam
	ruleAttributePair
	ruleAttributeValue
	ruleArrayLiteral
	ruleComment
	ruleDocComment
	ruleIdentifier
	ruleString
	ruleNumber
	ruleBoolean
	ruleLBRACE
	ruleRBRACE
	ruleLBRACKET
	ruleRBRACKET
	ruleLPAREN
	ruleRPAREN
	ruleCOMMA
	ruleCOLON
	ruleSEMICOLON
	ruleEQUALS
	rulePIPE
	ruleDOT
	ruleSPREAD
	ruleAT
	ruleLT
	ruleRT
	ruleDOTDOT
	ruleDoubleColon
	ruleSingleColon
	rule_
	ruleEOL
)

var rul3s = [...]string{
	"Unknown",
	"Start",
	"Statement",
	"UseStmt",
	"UsePath",
	"TypeAlias",
	"TypeName",
	"StructDef",
	"FieldList",
	"FieldOrSpread",
	"Field",
	"ComputedField",
	"NamedField",
	"SpreadField",
	"FieldName",
	"EnumDef",
	"EnumValueList",
	"EnumValue",
	"DispatchStmt",
	"DispatchPath",
	"DispatchKeyList",
	"DispatchKey",
	"DispatchTarget",
	"SpreadStruct",
	"Type",
	"AttributedType",
	"ConstrainedType",
	"UnionType",
	"ArrayType",
	"StructType",
	"GenericType",
	"GenericTypeParams",
	"PrimitiveType",
	"ReferenceType",
	"ComplexReference",
	"ResourcePath",
	"ComplexRefParam",
	"DottedPath",
	"StaticIndexKey",
	"LiteralType",
	"ArrayConstraint",
	"Range",
	"Attribute",
	"AttributeList",
	"AttributeItem",
	"AttributeCallWithEquals",
	"AttributeCall",
	"AttributeParamList",
	"AttributeParam",
	"AttributePair",
	"AttributeValue",
	"ArrayLiteral",
	"Comment",
	"DocComment",
	"Identifier",
	"String",
	"Number",
	"Boolean",
	"LBRACE",
	"RBRACE",
	"LBRACKET",
	"RBRACKET",
	"LPAREN",
	"RPAREN",
	"COMMA",
	"COLON",
	"SEMICOLON",
	"EQUALS",
	"PIPE",
	"DOT",
	"SPREAD",
	"AT",
	"LT",
	"RT",
	"DOTDOT",
	"DoubleColon",
	"SingleColon",
	"_",
	"EOL",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type MCDocParser struct {
	Buffer string
	buffer []rune
	rules  [79]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *MCDocParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *MCDocParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *MCDocParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *MCDocParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *MCDocParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *MCDocParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *MCDocParser) Init(options ...func(*MCDocParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Start <- <(_ Statement* _ !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule_]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleStatement]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[rule_]() {
					goto l0
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !matchDot() {
						goto l4
					}
					goto l0
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
				add(ruleStart, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Statement <- <(Attribute* _ (UseStmt / TypeAlias / StructDef / EnumDef / DispatchStmt) _)> */
		func() bool {
			position5, tokenIndex5 := position, tokenIndex
			{
				position6 := position
			l7:
				{
					position8, tokenIndex8 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l8
					}
					goto l7
				l8:
					position, tokenIndex = position8, tokenIndex8
				}
				if !_rules[rule_]() {
					goto l5
				}
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[ruleUseStmt]() {
						goto l10
					}
					goto l9
				l10:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleTypeAlias]() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleStructDef]() {
						goto l12
					}
					goto l9
				l12:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleEnumDef]() {
						goto l13
					}
					goto l9
				l13:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleDispatchStmt]() {
						goto l5
					}
				}
			l9:
				if !_rules[rule_]() {
					goto l5
				}
				add(ruleStatement, position6)
			}
			return true
		l5:
			position, tokenIndex = position5, tokenIndex5
			return false
		},
		/* 2 UseStmt <- <('u' 's' 'e' _ UsePath)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if buffer[position] != rune('u') {
					goto l14
				}
				position++
				if buffer[position] != rune('s') {
					goto l14
				}
				position++
				if buffer[position] != rune('e') {
					goto l14
				}
				position++
				if !_rules[rule_]() {
					goto l14
				}
				if !_rules[ruleUsePath]() {
					goto l14
				}
				add(ruleUseStmt, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 3 UsePath <- <((DoubleColon Identifier (DoubleColon Identifier)*) / (Identifier ((DoubleColon Identifier) / (SingleColon Identifier))*))> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				{
					position18, tokenIndex18 := position, tokenIndex
					if !_rules[ruleDoubleColon]() {
						goto l19
					}
					if !_rules[ruleIdentifier]() {
						goto l19
					}
				l20:
					{
						position21, tokenIndex21 := position, tokenIndex
						if !_rules[ruleDoubleColon]() {
							goto l21
						}
						if !_rules[ruleIdentifier]() {
							goto l21
						}
						goto l20
					l21:
						position, tokenIndex = position21, tokenIndex21
					}
					goto l18
				l19:
					position, tokenIndex = position18, tokenIndex18
					if !_rules[ruleIdentifier]() {
						goto l16
					}
				l22:
					{
						position23, tokenIndex23 := position, tokenIndex
						{
							position24, tokenIndex24 := position, tokenIndex
							if !_rules[ruleDoubleColon]() {
								goto l25
							}
							if !_rules[ruleIdentifier]() {
								goto l25
							}
							goto l24
						l25:
							position, tokenIndex = position24, tokenIndex24
							if !_rules[ruleSingleColon]() {
								goto l23
							}
							if !_rules[ruleIdentifier]() {
								goto l23
							}
						}
					l24:
						goto l22
					l23:
						position, tokenIndex = position23, tokenIndex23
					}
				}
			l18:
				add(ruleUsePath, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 4 TypeAlias <- <('t' 'y' 'p' 'e' _ TypeName _ EQUALS Type)> */
		func() bool {
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				if buffer[position] != rune('t') {
					goto l26
				}
				position++
				if buffer[position] != rune('y') {
					goto l26
				}
				position++
				if buffer[position] != rune('p') {
					goto l26
				}
				position++
				if buffer[position] != rune('e') {
					goto l26
				}
				position++
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleTypeName]() {
					goto l26
				}
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleEQUALS]() {
					goto l26
				}
				if !_rules[ruleType]() {
					goto l26
				}
				add(ruleTypeAlias, position27)
			}
			return true
		l26:
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 5 TypeName <- <(GenericType / Identifier)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				{
					position30, tokenIndex30 := position, tokenIndex
					if !_rules[ruleGenericType]() {
						goto l31
					}
					goto l30
				l31:
					position, tokenIndex = position30, tokenIndex30
					if !_rules[ruleIdentifier]() {
						goto l28
					}
				}
			l30:
				add(ruleTypeName, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 6 StructDef <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier _ LBRACE FieldList? RBRACE)> */
		func() bool {
			position32, tokenIndex32 := position, tokenIndex
			{
				position33 := position
				if buffer[position] != rune('s') {
					goto l32
				}
				position++
				if buffer[position] != rune('t') {
					goto l32
				}
				position++
				if buffer[position] != rune('r') {
					goto l32
				}
				position++
				if buffer[position] != rune('u') {
					goto l32
				}
				position++
				if buffer[position] != rune('c') {
					goto l32
				}
				position++
				if buffer[position] != rune('t') {
					goto l32
				}
				position++
				if !_rules[rule_]() {
					goto l32
				}
				if !_rules[ruleIdentifier]() {
					goto l32
				}
				if !_rules[rule_]() {
					goto l32
				}
				if !_rules[ruleLBRACE]() {
					goto l32
				}
				{
					position34, tokenIndex34 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l34
					}
					goto l35
				l34:
					position, tokenIndex = position34, tokenIndex34
				}
			l35:
				if !_rules[ruleRBRACE]() {
					goto l32
				}
				add(ruleStructDef, position33)
			}
			return true
		l32:
			position, tokenIndex = position32, tokenIndex32
			return false
		},
		/* 7 FieldList <- <(FieldOrSpread (COMMA FieldOrSpread)* COMMA?)> */
		func() bool {
			position36, tokenIndex36 := position, tokenIndex
			{
				position37 := position
				if !_rules[ruleFieldOrSpread]() {
					goto l36
				}
			l38:
				{
					position39, tokenIndex39 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l39
					}
					if !_rules[ruleFieldOrSpread]() {
						goto l39
					}
					goto l38
				l39:
					position, tokenIndex = position39, tokenIndex39
				}
				{
					position40, tokenIndex40 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l40
					}
					goto l41
				l40:
					position, tokenIndex = position40, tokenIndex40
				}
			l41:
				add(ruleFieldList, position37)
			}
			return true
		l36:
			position, tokenIndex = position36, tokenIndex36
			return false
		},
		/* 8 FieldOrSpread <- <(SpreadField / Field)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				{
					position44, tokenIndex44 := position, tokenIndex
					if !_rules[ruleSpreadField]() {
						goto l45
					}
					goto l44
				l45:
					position, tokenIndex = position44, tokenIndex44
					if !_rules[ruleField]() {
						goto l42
					}
				}
			l44:
				add(ruleFieldOrSpread, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 9 Field <- <(Attribute* _ (ComputedField / NamedField))> */
		func() bool {
			position46, tokenIndex46 := position, tokenIndex
			{
				position47 := position
			l48:
				{
					position49, tokenIndex49 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l49
					}
					goto l48
				l49:
					position, tokenIndex = position49, tokenIndex49
				}
				if !_rules[rule_]() {
					goto l46
				}
				{
					position50, tokenIndex50 := position, tokenIndex
					if !_rules[ruleComputedField]() {
						goto l51
					}
					goto l50
				l51:
					position, tokenIndex = position50, tokenIndex50
					if !_rules[ruleNamedField]() {
						goto l46
					}
				}
			l50:
				add(ruleField, position47)
			}
			return true
		l46:
			position, tokenIndex = position46, tokenIndex46
			return false
		},
		/* 10 ComputedField <- <(LBRACKET Type RBRACKET COLON Type)> */
		func() bool {
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
				if !_rules[ruleLBRACKET]() {
					goto l52
				}
				if !_rules[ruleType]() {
					goto l52
				}
				if !_rules[ruleRBRACKET]() {
					goto l52
				}
				if !_rules[ruleCOLON]() {
					goto l52
				}
				if !_rules[ruleType]() {
					goto l52
				}
				add(ruleComputedField, position53)
			}
			return true
		l52:
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 11 NamedField <- <(FieldName COLON Type)> */
		func() bool {
			position54, tokenIndex54 := position, tokenIndex
			{
				position55 := position
				if !_rules[ruleFieldName]() {
					goto l54
				}
				if !_rules[ruleCOLON]() {
					goto l54
				}
				if !_rules[ruleType]() {
					goto l54
				}
				add(ruleNamedField, position55)
			}
			return true
		l54:
			position, tokenIndex = position54, tokenIndex54
			return false
		},
		/* 12 SpreadField <- <(Attribute* _ SPREAD Type)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
			l58:
				{
					position59, tokenIndex59 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l59
					}
					goto l58
				l59:
					position, tokenIndex = position59, tokenIndex59
				}
				if !_rules[rule_]() {
					goto l56
				}
				if !_rules[ruleSPREAD]() {
					goto l56
				}
				if !_rules[ruleType]() {
					goto l56
				}
				add(ruleSpreadField, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 13 FieldName <- <(Identifier '?'? _)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if !_rules[ruleIdentifier]() {
					goto l60
				}
				{
					position62, tokenIndex62 := position, tokenIndex
					if buffer[position] != rune('?') {
						goto l62
					}
					position++
					goto l63
				l62:
					position, tokenIndex = position62, tokenIndex62
				}
			l63:
				if !_rules[rule_]() {
					goto l60
				}
				add(ruleFieldName, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 14 EnumDef <- <('e' 'n' 'u' 'm' _ LPAREN Type RPAREN Identifier _ LBRACE EnumValueList? RBRACE)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if buffer[position] != rune('e') {
					goto l64
				}
				position++
				if buffer[position] != rune('n') {
					goto l64
				}
				position++
				if buffer[position] != rune('u') {
					goto l64
				}
				position++
				if buffer[position] != rune('m') {
					goto l64
				}
				position++
				if !_rules[rule_]() {
					goto l64
				}
				if !_rules[ruleLPAREN]() {
					goto l64
				}
				if !_rules[ruleType]() {
					goto l64
				}
				if !_rules[ruleRPAREN]() {
					goto l64
				}
				if !_rules[ruleIdentifier]() {
					goto l64
				}
				if !_rules[rule_]() {
					goto l64
				}
				if !_rules[ruleLBRACE]() {
					goto l64
				}
				{
					position66, tokenIndex66 := position, tokenIndex
					if !_rules[ruleEnumValueList]() {
						goto l66
					}
					goto l67
				l66:
					position, tokenIndex = position66, tokenIndex66
				}
			l67:
				if !_rules[ruleRBRACE]() {
					goto l64
				}
				add(ruleEnumDef, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 15 EnumValueList <- <(EnumValue (COMMA EnumValue)* COMMA?)> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				if !_rules[ruleEnumValue]() {
					goto l68
				}
			l70:
				{
					position71, tokenIndex71 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l71
					}
					if !_rules[ruleEnumValue]() {
						goto l71
					}
					goto l70
				l71:
					position, tokenIndex = position71, tokenIndex71
				}
				{
					position72, tokenIndex72 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l72
					}
					goto l73
				l72:
					position, tokenIndex = position72, tokenIndex72
				}
			l73:
				add(ruleEnumValueList, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 16 EnumValue <- <(Attribute* _ Identifier _ EQUALS String)> */
		func() bool {
			position74, tokenIndex74 := position, tokenIndex
			{
				position75 := position
			l76:
				{
					position77, tokenIndex77 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l77
					}
					goto l76
				l77:
					position, tokenIndex = position77, tokenIndex77
				}
				if !_rules[rule_]() {
					goto l74
				}
				if !_rules[ruleIdentifier]() {
					goto l74
				}
				if !_rules[rule_]() {
					goto l74
				}
				if !_rules[ruleEQUALS]() {
					goto l74
				}
				if !_rules[ruleString]() {
					goto l74
				}
				add(ruleEnumValue, position75)
			}
			return true
		l74:
			position, tokenIndex = position74, tokenIndex74
			return false
		},
		/* 17 DispatchStmt <- <('d' 'i' 's' 'p' 'a' 't' 'c' 'h' _ DispatchPath _ ('t' 'o') _ DispatchTarget)> */
		func() bool {
			position78, tokenIndex78 := position, tokenIndex
			{
				position79 := position
				if buffer[position] != rune('d') {
					goto l78
				}
				position++
				if buffer[position] != rune('i') {
					goto l78
				}
				position++
				if buffer[position] != rune('s') {
					goto l78
				}
				position++
				if buffer[position] != rune('p') {
					goto l78
				}
				position++
				if buffer[position] != rune('a') {
					goto l78
				}
				position++
				if buffer[position] != rune('t') {
					goto l78
				}
				position++
				if buffer[position] != rune('c') {
					goto l78
				}
				position++
				if buffer[position] != rune('h') {
					goto l78
				}
				position++
				if !_rules[rule_]() {
					goto l78
				}
				if !_rules[ruleDispatchPath]() {
					goto l78
				}
				if !_rules[rule_]() {
					goto l78
				}
				if buffer[position] != rune('t') {
					goto l78
				}
				position++
				if buffer[position] != rune('o') {
					goto l78
				}
				position++
				if !_rules[rule_]() {
					goto l78
				}
				if !_rules[ruleDispatchTarget]() {
					goto l78
				}
				add(ruleDispatchStmt, position79)
			}
			return true
		l78:
			position, tokenIndex = position78, tokenIndex78
			return false
		},
		/* 18 DispatchPath <- <('m' 'i' 'n' 'e' 'c' 'r' 'a' 'f' 't' ':' ResourcePath LBRACKET DispatchKeyList RBRACKET (LT GenericTypeParams RT)?)> */
		func() bool {
			position80, tokenIndex80 := position, tokenIndex
			{
				position81 := position
				if buffer[position] != rune('m') {
					goto l80
				}
				position++
				if buffer[position] != rune('i') {
					goto l80
				}
				position++
				if buffer[position] != rune('n') {
					goto l80
				}
				position++
				if buffer[position] != rune('e') {
					goto l80
				}
				position++
				if buffer[position] != rune('c') {
					goto l80
				}
				position++
				if buffer[position] != rune('r') {
					goto l80
				}
				position++
				if buffer[position] != rune('a') {
					goto l80
				}
				position++
				if buffer[position] != rune('f') {
					goto l80
				}
				position++
				if buffer[position] != rune('t') {
					goto l80
				}
				position++
				if buffer[position] != rune(':') {
					goto l80
				}
				position++
				if !_rules[ruleResourcePath]() {
					goto l80
				}
				if !_rules[ruleLBRACKET]() {
					goto l80
				}
				if !_rules[ruleDispatchKeyList]() {
					goto l80
				}
				if !_rules[ruleRBRACKET]() {
					goto l80
				}
				{
					position82, tokenIndex82 := position, tokenIndex
					if !_rules[ruleLT]() {
						goto l82
					}
					if !_rules[ruleGenericTypeParams]() {
						goto l82
					}
					if !_rules[ruleRT]() {
						goto l82
					}
					goto l83
				l82:
					position, tokenIndex = position82, tokenIndex82
				}
			l83:
				add(ruleDispatchPath, position81)
			}
			return true
		l80:
			position, tokenIndex = position80, tokenIndex80
			return false
		},
		/* 19 DispatchKeyList <- <(DispatchKey (COMMA DispatchKey)* COMMA?)> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				if !_rules[ruleDispatchKey]() {
					goto l84
				}
			l86:
				{
					position87, tokenIndex87 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l87
					}
					if !_rules[ruleDispatchKey]() {
						goto l87
					}
					goto l86
				l87:
					position, tokenIndex = position87, tokenIndex87
				}
				{
					position88, tokenIndex88 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l88
					}
					goto l89
				l88:
					position, tokenIndex = position88, tokenIndex88
				}
			l89:
				add(ruleDispatchKeyList, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 20 DispatchKey <- <(StaticIndexKey / String / Identifier)> */
		func() bool {
			position90, tokenIndex90 := position, tokenIndex
			{
				position91 := position
				{
					position92, tokenIndex92 := position, tokenIndex
					if !_rules[ruleStaticIndexKey]() {
						goto l93
					}
					goto l92
				l93:
					position, tokenIndex = position92, tokenIndex92
					if !_rules[ruleString]() {
						goto l94
					}
					goto l92
				l94:
					position, tokenIndex = position92, tokenIndex92
					if !_rules[ruleIdentifier]() {
						goto l90
					}
				}
			l92:
				add(ruleDispatchKey, position91)
			}
			return true
		l90:
			position, tokenIndex = position90, tokenIndex90
			return false
		},
		/* 21 DispatchTarget <- <(('s' 't' 'r' 'u' 'c' 't' _ Identifier _ LBRACE FieldList? RBRACE) / Type)> */
		func() bool {
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				{
					position97, tokenIndex97 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l98
					}
					position++
					if buffer[position] != rune('t') {
						goto l98
					}
					position++
					if buffer[position] != rune('r') {
						goto l98
					}
					position++
					if buffer[position] != rune('u') {
						goto l98
					}
					position++
					if buffer[position] != rune('c') {
						goto l98
					}
					position++
					if buffer[position] != rune('t') {
						goto l98
					}
					position++
					if !_rules[rule_]() {
						goto l98
					}
					if !_rules[ruleIdentifier]() {
						goto l98
					}
					if !_rules[rule_]() {
						goto l98
					}
					if !_rules[ruleLBRACE]() {
						goto l98
					}
					{
						position99, tokenIndex99 := position, tokenIndex
						if !_rules[ruleFieldList]() {
							goto l99
						}
						goto l100
					l99:
						position, tokenIndex = position99, tokenIndex99
					}
				l100:
					if !_rules[ruleRBRACE]() {
						goto l98
					}
					goto l97
				l98:
					position, tokenIndex = position97, tokenIndex97
					if !_rules[ruleType]() {
						goto l95
					}
				}
			l97:
				add(ruleDispatchTarget, position96)
			}
			return true
		l95:
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 22 SpreadStruct <- <(SPREAD ('s' 't' 'r' 'u' 'c' 't') _ Identifier _ LBRACE FieldList? RBRACE)> */
		nil,
		/* 23 Type <- <(UnionType / AttributedType / ArrayType / StructType / ConstrainedType / GenericType / PrimitiveType / ReferenceType / LiteralType)> */
		func() bool {
			position102, tokenIndex102 := position, tokenIndex
			{
				position103 := position
				{
					position104, tokenIndex104 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l105
					}
					goto l104
				l105:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleAttributedType]() {
						goto l106
					}
					goto l104
				l106:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleArrayType]() {
						goto l107
					}
					goto l104
				l107:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleStructType]() {
						goto l108
					}
					goto l104
				l108:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleConstrainedType]() {
						goto l109
					}
					goto l104
				l109:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleGenericType]() {
						goto l110
					}
					goto l104
				l110:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[rulePrimitiveType]() {
						goto l111
					}
					goto l104
				l111:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleReferenceType]() {
						goto l112
					}
					goto l104
				l112:
					position, tokenIndex = position104, tokenIndex104
					if !_rules[ruleLiteralType]() {
						goto l102
					}
				}
			l104:
				add(ruleType, position103)
			}
			return true
		l102:
			position, tokenIndex = position102, tokenIndex102
			return false
		},
		/* 24 AttributedType <- <(Attribute+ _ (UnionType / ArrayType / ConstrainedType / StructType / GenericType / PrimitiveType / ReferenceType / LiteralType))> */
		func() bool {
			position113, tokenIndex113 := position, tokenIndex
			{
				position114 := position
				if !_rules[ruleAttribute]() {
					goto l113
				}
			l115:
				{
					position116, tokenIndex116 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l116
					}
					goto l115
				l116:
					position, tokenIndex = position116, tokenIndex116
				}
				if !_rules[rule_]() {
					goto l113
				}
				{
					position117, tokenIndex117 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l118
					}
					goto l117
				l118:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleArrayType]() {
						goto l119
					}
					goto l117
				l119:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleConstrainedType]() {
						goto l120
					}
					goto l117
				l120:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleStructType]() {
						goto l121
					}
					goto l117
				l121:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleGenericType]() {
						goto l122
					}
					goto l117
				l122:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[rulePrimitiveType]() {
						goto l123
					}
					goto l117
				l123:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleReferenceType]() {
						goto l124
					}
					goto l117
				l124:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleLiteralType]() {
						goto l113
					}
				}
			l117:
				add(ruleAttributedType, position114)
			}
			return true
		l113:
			position, tokenIndex = position113, tokenIndex113
			return false
		},
		/* 25 ConstrainedType <- <((PrimitiveType / ReferenceType / LiteralType) ArrayConstraint)> */
		func() bool {
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				{
					position127, tokenIndex127 := position, tokenIndex
					if !_rules[rulePrimitiveType]() {
						goto l128
					}
					goto l127
				l128:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleReferenceType]() {
						goto l129
					}
					goto l127
				l129:
					position, tokenIndex = position127, tokenIndex127
					if !_rules[ruleLiteralType]() {
						goto l125
					}
				}
			l127:
				if !_rules[ruleArrayConstraint]() {
					goto l125
				}
				add(ruleConstrainedType, position126)
			}
			return true
		l125:
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 26 UnionType <- <(LPAREN Type (PIPE Type)* PIPE? RPAREN)> */
		func() bool {
			position130, tokenIndex130 := position, tokenIndex
			{
				position131 := position
				if !_rules[ruleLPAREN]() {
					goto l130
				}
				if !_rules[ruleType]() {
					goto l130
				}
			l132:
				{
					position133, tokenIndex133 := position, tokenIndex
					if !_rules[rulePIPE]() {
						goto l133
					}
					if !_rules[ruleType]() {
						goto l133
					}
					goto l132
				l133:
					position, tokenIndex = position133, tokenIndex133
				}
				{
					position134, tokenIndex134 := position, tokenIndex
					if !_rules[rulePIPE]() {
						goto l134
					}
					goto l135
				l134:
					position, tokenIndex = position134, tokenIndex134
				}
			l135:
				if !_rules[ruleRPAREN]() {
					goto l130
				}
				add(ruleUnionType, position131)
			}
			return true
		l130:
			position, tokenIndex = position130, tokenIndex130
			return false
		},
		/* 27 ArrayType <- <(LBRACKET Type RBRACKET ArrayConstraint?)> */
		func() bool {
			position136, tokenIndex136 := position, tokenIndex
			{
				position137 := position
				if !_rules[ruleLBRACKET]() {
					goto l136
				}
				if !_rules[ruleType]() {
					goto l136
				}
				if !_rules[ruleRBRACKET]() {
					goto l136
				}
				{
					position138, tokenIndex138 := position, tokenIndex
					if !_rules[ruleArrayConstraint]() {
						goto l138
					}
					goto l139
				l138:
					position, tokenIndex = position138, tokenIndex138
				}
			l139:
				add(ruleArrayType, position137)
			}
			return true
		l136:
			position, tokenIndex = position136, tokenIndex136
			return false
		},
		/* 28 StructType <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier? _ LBRACE FieldList? RBRACE)> */
		func() bool {
			position140, tokenIndex140 := position, tokenIndex
			{
				position141 := position
				if buffer[position] != rune('s') {
					goto l140
				}
				position++
				if buffer[position] != rune('t') {
					goto l140
				}
				position++
				if buffer[position] != rune('r') {
					goto l140
				}
				position++
				if buffer[position] != rune('u') {
					goto l140
				}
				position++
				if buffer[position] != rune('c') {
					goto l140
				}
				position++
				if buffer[position] != rune('t') {
					goto l140
				}
				position++
				if !_rules[rule_]() {
					goto l140
				}
				{
					position142, tokenIndex142 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l142
					}
					goto l143
				l142:
					position, tokenIndex = position142, tokenIndex142
				}
			l143:
				if !_rules[rule_]() {
					goto l140
				}
				if !_rules[ruleLBRACE]() {
					goto l140
				}
				{
					position144, tokenIndex144 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l144
					}
					goto l145
				l144:
					position, tokenIndex = position144, tokenIndex144
				}
			l145:
				if !_rules[ruleRBRACE]() {
					goto l140
				}
				add(ruleStructType, position141)
			}
			return true
		l140:
			position, tokenIndex = position140, tokenIndex140
			return false
		},
		/* 29 GenericType <- <(Identifier LT GenericTypeParams RT)> */
		func() bool {
			position146, tokenIndex146 := position, tokenIndex
			{
				position147 := position
				if !_rules[ruleIdentifier]() {
					goto l146
				}
				if !_rules[ruleLT]() {
					goto l146
				}
				if !_rules[ruleGenericTypeParams]() {
					goto l146
				}
				if !_rules[ruleRT]() {
					goto l146
				}
				add(ruleGenericType, position147)
			}
			return true
		l146:
			position, tokenIndex = position146, tokenIndex146
			return false
		},
		/* 30 GenericTypeParams <- <(Type (COMMA Type)*)> */
		func() bool {
			position148, tokenIndex148 := position, tokenIndex
			{
				position149 := position
				if !_rules[ruleType]() {
					goto l148
				}
			l150:
				{
					position151, tokenIndex151 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l151
					}
					if !_rules[ruleType]() {
						goto l151
					}
					goto l150
				l151:
					position, tokenIndex = position151, tokenIndex151
				}
				add(ruleGenericTypeParams, position149)
			}
			return true
		l148:
			position, tokenIndex = position148, tokenIndex148
			return false
		},
		/* 31 PrimitiveType <- <((('s' 't' 'r' 'i' 'n' 'g') / ('d' 'o' 'u' 'b' 'l' 'e') / ('f' 'l' 'o' 'a' 't') / ('i' 'n' 't') / ('b' 'o' 'o' 'l' 'e' 'a' 'n') / ('a' 'n' 'y')) _)> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				{
					position154, tokenIndex154 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l155
					}
					position++
					if buffer[position] != rune('t') {
						goto l155
					}
					position++
					if buffer[position] != rune('r') {
						goto l155
					}
					position++
					if buffer[position] != rune('i') {
						goto l155
					}
					position++
					if buffer[position] != rune('n') {
						goto l155
					}
					position++
					if buffer[position] != rune('g') {
						goto l155
					}
					position++
					goto l154
				l155:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('d') {
						goto l156
					}
					position++
					if buffer[position] != rune('o') {
						goto l156
					}
					position++
					if buffer[position] != rune('u') {
						goto l156
					}
					position++
					if buffer[position] != rune('b') {
						goto l156
					}
					position++
					if buffer[position] != rune('l') {
						goto l156
					}
					position++
					if buffer[position] != rune('e') {
						goto l156
					}
					position++
					goto l154
				l156:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('f') {
						goto l157
					}
					position++
					if buffer[position] != rune('l') {
						goto l157
					}
					position++
					if buffer[position] != rune('o') {
						goto l157
					}
					position++
					if buffer[position] != rune('a') {
						goto l157
					}
					position++
					if buffer[position] != rune('t') {
						goto l157
					}
					position++
					goto l154
				l157:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('i') {
						goto l158
					}
					position++
					if buffer[position] != rune('n') {
						goto l158
					}
					position++
					if buffer[position] != rune('t') {
						goto l158
					}
					position++
					goto l154
				l158:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('b') {
						goto l159
					}
					position++
					if buffer[position] != rune('o') {
						goto l159
					}
					position++
					if buffer[position] != rune('o') {
						goto l159
					}
					position++
					if buffer[position] != rune('l') {
						goto l159
					}
					position++
					if buffer[position] != rune('e') {
						goto l159
					}
					position++
					if buffer[position] != rune('a') {
						goto l159
					}
					position++
					if buffer[position] != rune('n') {
						goto l159
					}
					position++
					goto l154
				l159:
					position, tokenIndex = position154, tokenIndex154
					if buffer[position] != rune('a') {
						goto l152
					}
					position++
					if buffer[position] != rune('n') {
						goto l152
					}
					position++
					if buffer[position] != rune('y') {
						goto l152
					}
					position++
				}
			l154:
				if !_rules[rule_]() {
					goto l152
				}
				add(rulePrimitiveType, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
		/* 32 ReferenceType <- <(ComplexReference / Identifier)> */
		func() bool {
			position160, tokenIndex160 := position, tokenIndex
			{
				position161 := position
				{
					position162, tokenIndex162 := position, tokenIndex
					if !_rules[ruleComplexReference]() {
						goto l163
					}
					goto l162
				l163:
					position, tokenIndex = position162, tokenIndex162
					if !_rules[ruleIdentifier]() {
						goto l160
					}
				}
			l162:
				add(ruleReferenceType, position161)
			}
			return true
		l160:
			position, tokenIndex = position160, tokenIndex160
			return false
		},
		/* 33 ComplexReference <- <(Identifier COLON ResourcePath ((LBRACKET LBRACKET ComplexRefParam RBRACKET RBRACKET) / (LBRACKET ComplexRefParam RBRACKET)) (LT GenericTypeParams RT)?)> */
		func() bool {
			position164, tokenIndex164 := position, tokenIndex
			{
				position165 := position
				if !_rules[ruleIdentifier]() {
					goto l164
				}
				if !_rules[ruleCOLON]() {
					goto l164
				}
				if !_rules[ruleResourcePath]() {
					goto l164
				}
				{
					position166, tokenIndex166 := position, tokenIndex
					if !_rules[ruleLBRACKET]() {
						goto l167
					}
					if !_rules[ruleLBRACKET]() {
						goto l167
					}
					if !_rules[ruleComplexRefParam]() {
						goto l167
					}
					if !_rules[ruleRBRACKET]() {
						goto l167
					}
					if !_rules[ruleRBRACKET]() {
						goto l167
					}
					goto l166
				l167:
					position, tokenIndex = position166, tokenIndex166
					if !_rules[ruleLBRACKET]() {
						goto l164
					}
					if !_rules[ruleComplexRefParam]() {
						goto l164
					}
					if !_rules[ruleRBRACKET]() {
						goto l164
					}
				}
			l166:
				{
					position168, tokenIndex168 := position, tokenIndex
					if !_rules[ruleLT]() {
						goto l168
					}
					if !_rules[ruleGenericTypeParams]() {
						goto l168
					}
					if !_rules[ruleRT]() {
						goto l168
					}
					goto l169
				l168:
					position, tokenIndex = position168, tokenIndex168
				}
			l169:
				add(ruleComplexReference, position165)
			}
			return true
		l164:
			position, tokenIndex = position164, tokenIndex164
			return false
		},
		/* 34 ResourcePath <- <(Identifier ('/' Identifier)*)> */
		func() bool {
			position170, tokenIndex170 := position, tokenIndex
			{
				position171 := position
				if !_rules[ruleIdentifier]() {
					goto l170
				}
			l172:
				{
					position173, tokenIndex173 := position, tokenIndex
					if buffer[position] != rune('/') {
						goto l173
					}
					position++
					if !_rules[ruleIdentifier]() {
						goto l173
					}
					goto l172
				l173:
					position, tokenIndex = position173, tokenIndex173
				}
				add(ruleResourcePath, position171)
			}
			return true
		l170:
			position, tokenIndex = position170, tokenIndex170
			return false
		},
		/* 35 ComplexRefParam <- <(DottedPath / StaticIndexKey / String / Identifier)> */
		func() bool {
			position174, tokenIndex174 := position, tokenIndex
			{
				position175 := position
				{
					position176, tokenIndex176 := position, tokenIndex
					if !_rules[ruleDottedPath]() {
						goto l177
					}
					goto l176
				l177:
					position, tokenIndex = position176, tokenIndex176
					if !_rules[ruleStaticIndexKey]() {
						goto l178
					}
					goto l176
				l178:
					position, tokenIndex = position176, tokenIndex176
					if !_rules[ruleString]() {
						goto l179
					}
					goto l176
				l179:
					position, tokenIndex = position176, tokenIndex176
					if !_rules[ruleIdentifier]() {
						goto l174
					}
				}
			l176:
				add(ruleComplexRefParam, position175)
			}
			return true
		l174:
			position, tokenIndex = position174, tokenIndex174
			return false
		},
		/* 36 DottedPath <- <((StaticIndexKey / Identifier) ('.' Identifier)+)> */
		func() bool {
			position180, tokenIndex180 := position, tokenIndex
			{
				position181 := position
				{
					position182, tokenIndex182 := position, tokenIndex
					if !_rules[ruleStaticIndexKey]() {
						goto l183
					}
					goto l182
				l183:
					position, tokenIndex = position182, tokenIndex182
					if !_rules[ruleIdentifier]() {
						goto l180
					}
				}
			l182:
				if buffer[position] != rune('.') {
					goto l180
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l180
				}
			l184:
				{
					position185, tokenIndex185 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l185
					}
					position++
					if !_rules[ruleIdentifier]() {
						goto l185
					}
					goto l184
				l185:
					position, tokenIndex = position185, tokenIndex185
				}
				add(ruleDottedPath, position181)
			}
			return true
		l180:
			position, tokenIndex = position180, tokenIndex180
			return false
		},
		/* 37 StaticIndexKey <- <((('%' 'f' 'a' 'l' 'l' 'b' 'a' 'c' 'k') / ('%' 'k' 'e' 'y') / ('%' 'p' 'a' 'r' 'e' 'n' 't') / ('%' 'n' 'o' 'n' 'e') / ('%' 'u' 'n' 'k' 'n' 'o' 'w' 'n')) _)> */
		func() bool {
			position186, tokenIndex186 := position, tokenIndex
			{
				position187 := position
				{
					position188, tokenIndex188 := position, tokenIndex
					if buffer[position] != rune('%') {
						goto l189
					}
					position++
					if buffer[position] != rune('f') {
						goto l189
					}
					position++
					if buffer[position] != rune('a') {
						goto l189
					}
					position++
					if buffer[position] != rune('l') {
						goto l189
					}
					position++
					if buffer[position] != rune('l') {
						goto l189
					}
					position++
					if buffer[position] != rune('b') {
						goto l189
					}
					position++
					if buffer[position] != rune('a') {
						goto l189
					}
					position++
					if buffer[position] != rune('c') {
						goto l189
					}
					position++
					if buffer[position] != rune('k') {
						goto l189
					}
					position++
					goto l188
				l189:
					position, tokenIndex = position188, tokenIndex188
					if buffer[position] != rune('%') {
						goto l190
					}
					position++
					if buffer[position] != rune('k') {
						goto l190
					}
					position++
					if buffer[position] != rune('e') {
						goto l190
					}
					position++
					if buffer[position] != rune('y') {
						goto l190
					}
					position++
					goto l188
				l190:
					position, tokenIndex = position188, tokenIndex188
					if buffer[position] != rune('%') {
						goto l191
					}
					position++
					if buffer[position] != rune('p') {
						goto l191
					}
					position++
					if buffer[position] != rune('a') {
						goto l191
					}
					position++
					if buffer[position] != rune('r') {
						goto l191
					}
					position++
					if buffer[position] != rune('e') {
						goto l191
					}
					position++
					if buffer[position] != rune('n') {
						goto l191
					}
					position++
					if buffer[position] != rune('t') {
						goto l191
					}
					position++
					goto l188
				l191:
					position, tokenIndex = position188, tokenIndex188
					if buffer[position] != rune('%') {
						goto l192
					}
					position++
					if buffer[position] != rune('n') {
						goto l192
					}
					position++
					if buffer[position] != rune('o') {
						goto l192
					}
					position++
					if buffer[position] != rune('n') {
						goto l192
					}
					position++
					if buffer[position] != rune('e') {
						goto l192
					}
					position++
					goto l188
				l192:
					position, tokenIndex = position188, tokenIndex188
					if buffer[position] != rune('%') {
						goto l186
					}
					position++
					if buffer[position] != rune('u') {
						goto l186
					}
					position++
					if buffer[position] != rune('n') {
						goto l186
					}
					position++
					if buffer[position] != rune('k') {
						goto l186
					}
					position++
					if buffer[position] != rune('n') {
						goto l186
					}
					position++
					if buffer[position] != rune('o') {
						goto l186
					}
					position++
					if buffer[position] != rune('w') {
						goto l186
					}
					position++
					if buffer[position] != rune('n') {
						goto l186
					}
					position++
				}
			l188:
				if !_rules[rule_]() {
					goto l186
				}
				add(ruleStaticIndexKey, position187)
			}
			return true
		l186:
			position, tokenIndex = position186, tokenIndex186
			return false
		},
		/* 38 LiteralType <- <(String / Number / Boolean)> */
		func() bool {
			position193, tokenIndex193 := position, tokenIndex
			{
				position194 := position
				{
					position195, tokenIndex195 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l196
					}
					goto l195
				l196:
					position, tokenIndex = position195, tokenIndex195
					if !_rules[ruleNumber]() {
						goto l197
					}
					goto l195
				l197:
					position, tokenIndex = position195, tokenIndex195
					if !_rules[ruleBoolean]() {
						goto l193
					}
				}
			l195:
				add(ruleLiteralType, position194)
			}
			return true
		l193:
			position, tokenIndex = position193, tokenIndex193
			return false
		},
		/* 39 ArrayConstraint <- <(AT (Range / Number))> */
		func() bool {
			position198, tokenIndex198 := position, tokenIndex
			{
				position199 := position
				if !_rules[ruleAT]() {
					goto l198
				}
				{
					position200, tokenIndex200 := position, tokenIndex
					if !_rules[ruleRange]() {
						goto l201
					}
					goto l200
				l201:
					position, tokenIndex = position200, tokenIndex200
					if !_rules[ruleNumber]() {
						goto l198
					}
				}
			l200:
				add(ruleArrayConstraint, position199)
			}
			return true
		l198:
			position, tokenIndex = position198, tokenIndex198
			return false
		},
		/* 40 Range <- <((Number DOTDOT Number) / (Number DOTDOT) / (DOTDOT Number))> */
		func() bool {
			position202, tokenIndex202 := position, tokenIndex
			{
				position203 := position
				{
					position204, tokenIndex204 := position, tokenIndex
					if !_rules[ruleNumber]() {
						goto l205
					}
					if !_rules[ruleDOTDOT]() {
						goto l205
					}
					if !_rules[ruleNumber]() {
						goto l205
					}
					goto l204
				l205:
					position, tokenIndex = position204, tokenIndex204
					if !_rules[ruleNumber]() {
						goto l206
					}
					if !_rules[ruleDOTDOT]() {
						goto l206
					}
					goto l204
				l206:
					position, tokenIndex = position204, tokenIndex204
					if !_rules[ruleDOTDOT]() {
						goto l202
					}
					if !_rules[ruleNumber]() {
						goto l202
					}
				}
			l204:
				add(ruleRange, position203)
			}
			return true
		l202:
			position, tokenIndex = position202, tokenIndex202
			return false
		},
		/* 41 Attribute <- <('#' LBRACKET AttributeList RBRACKET)> */
		func() bool {
			position207, tokenIndex207 := position, tokenIndex
			{
				position208 := position
				if buffer[position] != rune('#') {
					goto l207
				}
				position++
				if !_rules[ruleLBRACKET]() {
					goto l207
				}
				if !_rules[ruleAttributeList]() {
					goto l207
				}
				if !_rules[ruleRBRACKET]() {
					goto l207
				}
				add(ruleAttribute, position208)
			}
			return true
		l207:
			position, tokenIndex = position207, tokenIndex207
			return false
		},
		/* 42 AttributeList <- <(AttributeItem (COMMA AttributeItem)*)> */
		func() bool {
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				if !_rules[ruleAttributeItem]() {
					goto l209
				}
			l211:
				{
					position212, tokenIndex212 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l212
					}
					if !_rules[ruleAttributeItem]() {
						goto l212
					}
					goto l211
				l212:
					position, tokenIndex = position212, tokenIndex212
				}
				add(ruleAttributeList, position210)
			}
			return true
		l209:
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 43 AttributeItem <- <(AttributePair / AttributeCall / AttributeCallWithEquals / Identifier)> */
		func() bool {
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				{
					position215, tokenIndex215 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l216
					}
					goto l215
				l216:
					position, tokenIndex = position215, tokenIndex215
					if !_rules[ruleAttributeCall]() {
						goto l217
					}
					goto l215
				l217:
					position, tokenIndex = position215, tokenIndex215
					if !_rules[ruleAttributeCallWithEquals]() {
						goto l218
					}
					goto l215
				l218:
					position, tokenIndex = position215, tokenIndex215
					if !_rules[ruleIdentifier]() {
						goto l213
					}
				}
			l215:
				add(ruleAttributeItem, position214)
			}
			return true
		l213:
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 44 AttributeCallWithEquals <- <(Identifier EQUALS LPAREN AttributeParamList? RPAREN)> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if !_rules[ruleIdentifier]() {
					goto l219
				}
				if !_rules[ruleEQUALS]() {
					goto l219
				}
				if !_rules[ruleLPAREN]() {
					goto l219
				}
				{
					position221, tokenIndex221 := position, tokenIndex
					if !_rules[ruleAttributeParamList]() {
						goto l221
					}
					goto l222
				l221:
					position, tokenIndex = position221, tokenIndex221
				}
			l222:
				if !_rules[ruleRPAREN]() {
					goto l219
				}
				add(ruleAttributeCallWithEquals, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 45 AttributeCall <- <(Identifier LPAREN AttributeParamList? RPAREN)> */
		func() bool {
			position223, tokenIndex223 := position, tokenIndex
			{
				position224 := position
				if !_rules[ruleIdentifier]() {
					goto l223
				}
				if !_rules[ruleLPAREN]() {
					goto l223
				}
				{
					position225, tokenIndex225 := position, tokenIndex
					if !_rules[ruleAttributeParamList]() {
						goto l225
					}
					goto l226
				l225:
					position, tokenIndex = position225, tokenIndex225
				}
			l226:
				if !_rules[ruleRPAREN]() {
					goto l223
				}
				add(ruleAttributeCall, position224)
			}
			return true
		l223:
			position, tokenIndex = position223, tokenIndex223
			return false
		},
		/* 46 AttributeParamList <- <(AttributeParam (COMMA AttributeParam)*)> */
		func() bool {
			position227, tokenIndex227 := position, tokenIndex
			{
				position228 := position
				if !_rules[ruleAttributeParam]() {
					goto l227
				}
			l229:
				{
					position230, tokenIndex230 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l230
					}
					if !_rules[ruleAttributeParam]() {
						goto l230
					}
					goto l229
				l230:
					position, tokenIndex = position230, tokenIndex230
				}
				add(ruleAttributeParamList, position228)
			}
			return true
		l227:
			position, tokenIndex = position227, tokenIndex227
			return false
		},
		/* 47 AttributeParam <- <(AttributePair / AttributeValue)> */
		func() bool {
			position231, tokenIndex231 := position, tokenIndex
			{
				position232 := position
				{
					position233, tokenIndex233 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l234
					}
					goto l233
				l234:
					position, tokenIndex = position233, tokenIndex233
					if !_rules[ruleAttributeValue]() {
						goto l231
					}
				}
			l233:
				add(ruleAttributeParam, position232)
			}
			return true
		l231:
			position, tokenIndex = position231, tokenIndex231
			return false
		},
		/* 48 AttributePair <- <(Identifier EQUALS AttributeValue)> */
		func() bool {
			position235, tokenIndex235 := position, tokenIndex
			{
				position236 := position
				if !_rules[ruleIdentifier]() {
					goto l235
				}
				if !_rules[ruleEQUALS]() {
					goto l235
				}
				if !_rules[ruleAttributeValue]() {
					goto l235
				}
				add(ruleAttributePair, position236)
			}
			return true
		l235:
			position, tokenIndex = position235, tokenIndex235
			return false
		},
		/* 49 AttributeValue <- <(ArrayLiteral / String / Number / Boolean / Identifier)> */
		func() bool {
			position237, tokenIndex237 := position, tokenIndex
			{
				position238 := position
				{
					position239, tokenIndex239 := position, tokenIndex
					if !_rules[ruleArrayLiteral]() {
						goto l240
					}
					goto l239
				l240:
					position, tokenIndex = position239, tokenIndex239
					if !_rules[ruleString]() {
						goto l241
					}
					goto l239
				l241:
					position, tokenIndex = position239, tokenIndex239
					if !_rules[ruleNumber]() {
						goto l242
					}
					goto l239
				l242:
					position, tokenIndex = position239, tokenIndex239
					if !_rules[ruleBoolean]() {
						goto l243
					}
					goto l239
				l243:
					position, tokenIndex = position239, tokenIndex239
					if !_rules[ruleIdentifier]() {
						goto l237
					}
				}
			l239:
				add(ruleAttributeValue, position238)
			}
			return true
		l237:
			position, tokenIndex = position237, tokenIndex237
			return false
		},
		/* 50 ArrayLiteral <- <(LBRACKET (AttributeValue (COMMA AttributeValue)*)? RBRACKET)> */
		func() bool {
			position244, tokenIndex244 := position, tokenIndex
			{
				position245 := position
				if !_rules[ruleLBRACKET]() {
					goto l244
				}
				{
					position246, tokenIndex246 := position, tokenIndex
					if !_rules[ruleAttributeValue]() {
						goto l246
					}
				l248:
					{
						position249, tokenIndex249 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l249
						}
						if !_rules[ruleAttributeValue]() {
							goto l249
						}
						goto l248
					l249:
						position, tokenIndex = position249, tokenIndex249
					}
					goto l247
				l246:
					position, tokenIndex = position246, tokenIndex246
				}
			l247:
				if !_rules[ruleRBRACKET]() {
					goto l244
				}
				add(ruleArrayLiteral, position245)
			}
			return true
		l244:
			position, tokenIndex = position244, tokenIndex244
			return false
		},
		/* 51 Comment <- <('/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position250, tokenIndex250 := position, tokenIndex
			{
				position251 := position
				if buffer[position] != rune('/') {
					goto l250
				}
				position++
				if buffer[position] != rune('/') {
					goto l250
				}
				position++
			l252:
				{
					position253, tokenIndex253 := position, tokenIndex
					{
						position254, tokenIndex254 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l254
						}
						goto l253
					l254:
						position, tokenIndex = position254, tokenIndex254
					}
					if !matchDot() {
						goto l253
					}
					goto l252
				l253:
					position, tokenIndex = position253, tokenIndex253
				}
				{
					position255, tokenIndex255 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l256
					}
					goto l255
				l256:
					position, tokenIndex = position255, tokenIndex255
					{
						position257, tokenIndex257 := position, tokenIndex
						if !matchDot() {
							goto l257
						}
						goto l250
					l257:
						position, tokenIndex = position257, tokenIndex257
					}
				}
			l255:
				add(ruleComment, position251)
			}
			return true
		l250:
			position, tokenIndex = position250, tokenIndex250
			return false
		},
		/* 52 DocComment <- <('/' '/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position258, tokenIndex258 := position, tokenIndex
			{
				position259 := position
				if buffer[position] != rune('/') {
					goto l258
				}
				position++
				if buffer[position] != rune('/') {
					goto l258
				}
				position++
				if buffer[position] != rune('/') {
					goto l258
				}
				position++
			l260:
				{
					position261, tokenIndex261 := position, tokenIndex
					{
						position262, tokenIndex262 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l262
						}
						goto l261
					l262:
						position, tokenIndex = position262, tokenIndex262
					}
					if !matchDot() {
						goto l261
					}
					goto l260
				l261:
					position, tokenIndex = position261, tokenIndex261
				}
				{
					position263, tokenIndex263 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l264
					}
					goto l263
				l264:
					position, tokenIndex = position263, tokenIndex263
					{
						position265, tokenIndex265 := position, tokenIndex
						if !matchDot() {
							goto l265
						}
						goto l258
					l265:
						position, tokenIndex = position265, tokenIndex265
					}
				}
			l263:
				add(ruleDocComment, position259)
			}
			return true
		l258:
			position, tokenIndex = position258, tokenIndex258
			return false
		},
		/* 53 Identifier <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')* _)> */
		func() bool {
			position266, tokenIndex266 := position, tokenIndex
			{
				position267 := position
				{
					position268, tokenIndex268 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l269
					}
					position++
					goto l268
				l269:
					position, tokenIndex = position268, tokenIndex268
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l270
					}
					position++
					goto l268
				l270:
					position, tokenIndex = position268, tokenIndex268
					if buffer[position] != rune('_') {
						goto l266
					}
					position++
				}
			l268:
			l271:
				{
					position272, tokenIndex272 := position, tokenIndex
					{
						position273, tokenIndex273 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l274
						}
						position++
						goto l273
					l274:
						position, tokenIndex = position273, tokenIndex273
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l275
						}
						position++
						goto l273
					l275:
						position, tokenIndex = position273, tokenIndex273
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l276
						}
						position++
						goto l273
					l276:
						position, tokenIndex = position273, tokenIndex273
						if buffer[position] != rune('_') {
							goto l272
						}
						position++
					}
				l273:
					goto l271
				l272:
					position, tokenIndex = position272, tokenIndex272
				}
				if !_rules[rule_]() {
					goto l266
				}
				add(ruleIdentifier, position267)
			}
			return true
		l266:
			position, tokenIndex = position266, tokenIndex266
			return false
		},
		/* 54 String <- <('"' (!'"' .)* '"' _)> */
		func() bool {
			position277, tokenIndex277 := position, tokenIndex
			{
				position278 := position
				if buffer[position] != rune('"') {
					goto l277
				}
				position++
			l279:
				{
					position280, tokenIndex280 := position, tokenIndex
					{
						position281, tokenIndex281 := position, tokenIndex
						if buffer[position] != rune('"') {
							goto l281
						}
						position++
						goto l280
					l281:
						position, tokenIndex = position281, tokenIndex281
					}
					if !matchDot() {
						goto l280
					}
					goto l279
				l280:
					position, tokenIndex = position280, tokenIndex280
				}
				if buffer[position] != rune('"') {
					goto l277
				}
				position++
				if !_rules[rule_]() {
					goto l277
				}
				add(ruleString, position278)
			}
			return true
		l277:
			position, tokenIndex = position277, tokenIndex277
			return false
		},
		/* 55 Number <- <('-'? [0-9]+ ('.' [0-9]+)? _)> */
		func() bool {
			position282, tokenIndex282 := position, tokenIndex
			{
				position283 := position
				{
					position284, tokenIndex284 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l284
					}
					position++
					goto l285
				l284:
					position, tokenIndex = position284, tokenIndex284
				}
			l285:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l282
				}
				position++
			l286:
				{
					position287, tokenIndex287 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l287
					}
					position++
					goto l286
				l287:
					position, tokenIndex = position287, tokenIndex287
				}
				{
					position288, tokenIndex288 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l288
					}
					position++
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l288
					}
					position++
				l290:
					{
						position291, tokenIndex291 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l291
						}
						position++
						goto l290
					l291:
						position, tokenIndex = position291, tokenIndex291
					}
					goto l289
				l288:
					position, tokenIndex = position288, tokenIndex288
				}
			l289:
				if !_rules[rule_]() {
					goto l282
				}
				add(ruleNumber, position283)
			}
			return true
		l282:
			position, tokenIndex = position282, tokenIndex282
			return false
		},
		/* 56 Boolean <- <((('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e')) _)> */
		func() bool {
			position292, tokenIndex292 := position, tokenIndex
			{
				position293 := position
				{
					position294, tokenIndex294 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l295
					}
					position++
					if buffer[position] != rune('r') {
						goto l295
					}
					position++
					if buffer[position] != rune('u') {
						goto l295
					}
					position++
					if buffer[position] != rune('e') {
						goto l295
					}
					position++
					goto l294
				l295:
					position, tokenIndex = position294, tokenIndex294
					if buffer[position] != rune('f') {
						goto l292
					}
					position++
					if buffer[position] != rune('a') {
						goto l292
					}
					position++
					if buffer[position] != rune('l') {
						goto l292
					}
					position++
					if buffer[position] != rune('s') {
						goto l292
					}
					position++
					if buffer[position] != rune('e') {
						goto l292
					}
					position++
				}
			l294:
				if !_rules[rule_]() {
					goto l292
				}
				add(ruleBoolean, position293)
			}
			return true
		l292:
			position, tokenIndex = position292, tokenIndex292
			return false
		},
		/* 57 LBRACE <- <('{' _)> */
		func() bool {
			position296, tokenIndex296 := position, tokenIndex
			{
				position297 := position
				if buffer[position] != rune('{') {
					goto l296
				}
				position++
				if !_rules[rule_]() {
					goto l296
				}
				add(ruleLBRACE, position297)
			}
			return true
		l296:
			position, tokenIndex = position296, tokenIndex296
			return false
		},
		/* 58 RBRACE <- <('}' _)> */
		func() bool {
			position298, tokenIndex298 := position, tokenIndex
			{
				position299 := position
				if buffer[position] != rune('}') {
					goto l298
				}
				position++
				if !_rules[rule_]() {
					goto l298
				}
				add(ruleRBRACE, position299)
			}
			return true
		l298:
			position, tokenIndex = position298, tokenIndex298
			return false
		},
		/* 59 LBRACKET <- <('[' _)> */
		func() bool {
			position300, tokenIndex300 := position, tokenIndex
			{
				position301 := position
				if buffer[position] != rune('[') {
					goto l300
				}
				position++
				if !_rules[rule_]() {
					goto l300
				}
				add(ruleLBRACKET, position301)
			}
			return true
		l300:
			position, tokenIndex = position300, tokenIndex300
			return false
		},
		/* 60 RBRACKET <- <(']' _)> */
		func() bool {
			position302, tokenIndex302 := position, tokenIndex
			{
				position303 := position
				if buffer[position] != rune(']') {
					goto l302
				}
				position++
				if !_rules[rule_]() {
					goto l302
				}
				add(ruleRBRACKET, position303)
			}
			return true
		l302:
			position, tokenIndex = position302, tokenIndex302
			return false
		},
		/* 61 LPAREN <- <('(' _)> */
		func() bool {
			position304, tokenIndex304 := position, tokenIndex
			{
				position305 := position
				if buffer[position] != rune('(') {
					goto l304
				}
				position++
				if !_rules[rule_]() {
					goto l304
				}
				add(ruleLPAREN, position305)
			}
			return true
		l304:
			position, tokenIndex = position304, tokenIndex304
			return false
		},
		/* 62 RPAREN <- <(')' _)> */
		func() bool {
			position306, tokenIndex306 := position, tokenIndex
			{
				position307 := position
				if buffer[position] != rune(')') {
					goto l306
				}
				position++
				if !_rules[rule_]() {
					goto l306
				}
				add(ruleRPAREN, position307)
			}
			return true
		l306:
			position, tokenIndex = position306, tokenIndex306
			return false
		},
		/* 63 COMMA <- <(',' _)> */
		func() bool {
			position308, tokenIndex308 := position, tokenIndex
			{
				position309 := position
				if buffer[position] != rune(',') {
					goto l308
				}
				position++
				if !_rules[rule_]() {
					goto l308
				}
				add(ruleCOMMA, position309)
			}
			return true
		l308:
			position, tokenIndex = position308, tokenIndex308
			return false
		},
		/* 64 COLON <- <(':' _)> */
		func() bool {
			position310, tokenIndex310 := position, tokenIndex
			{
				position311 := position
				if buffer[position] != rune(':') {
					goto l310
				}
				position++
				if !_rules[rule_]() {
					goto l310
				}
				add(ruleCOLON, position311)
			}
			return true
		l310:
			position, tokenIndex = position310, tokenIndex310
			return false
		},
		/* 65 SEMICOLON <- <(';' _)> */
		nil,
		/* 66 EQUALS <- <('=' _)> */
		func() bool {
			position313, tokenIndex313 := position, tokenIndex
			{
				position314 := position
				if buffer[position] != rune('=') {
					goto l313
				}
				position++
				if !_rules[rule_]() {
					goto l313
				}
				add(ruleEQUALS, position314)
			}
			return true
		l313:
			position, tokenIndex = position313, tokenIndex313
			return false
		},
		/* 67 PIPE <- <('|' _)> */
		func() bool {
			position315, tokenIndex315 := position, tokenIndex
			{
				position316 := position
				if buffer[position] != rune('|') {
					goto l315
				}
				position++
				if !_rules[rule_]() {
					goto l315
				}
				add(rulePIPE, position316)
			}
			return true
		l315:
			position, tokenIndex = position315, tokenIndex315
			return false
		},
		/* 68 DOT <- <('.' _)> */
		nil,
		/* 69 SPREAD <- <('.' '.' '.' _)> */
		func() bool {
			position318, tokenIndex318 := position, tokenIndex
			{
				position319 := position
				if buffer[position] != rune('.') {
					goto l318
				}
				position++
				if buffer[position] != rune('.') {
					goto l318
				}
				position++
				if buffer[position] != rune('.') {
					goto l318
				}
				position++
				if !_rules[rule_]() {
					goto l318
				}
				add(ruleSPREAD, position319)
			}
			return true
		l318:
			position, tokenIndex = position318, tokenIndex318
			return false
		},
		/* 70 AT <- <('@' _)> */
		func() bool {
			position320, tokenIndex320 := position, tokenIndex
			{
				position321 := position
				if buffer[position] != rune('@') {
					goto l320
				}
				position++
				if !_rules[rule_]() {
					goto l320
				}
				add(ruleAT, position321)
			}
			return true
		l320:
			position, tokenIndex = position320, tokenIndex320
			return false
		},
		/* 71 LT <- <('<' _)> */
		func() bool {
			position322, tokenIndex322 := position, tokenIndex
			{
				position323 := position
				if buffer[position] != rune('<') {
					goto l322
				}
				position++
				if !_rules[rule_]() {
					goto l322
				}
				add(ruleLT, position323)
			}
			return true
		l322:
			position, tokenIndex = position322, tokenIndex322
			return false
		},
		/* 72 RT <- <('>' _)> */
		func() bool {
			position324, tokenIndex324 := position, tokenIndex
			{
				position325 := position
				if buffer[position] != rune('>') {
					goto l324
				}
				position++
				if !_rules[rule_]() {
					goto l324
				}
				add(ruleRT, position325)
			}
			return true
		l324:
			position, tokenIndex = position324, tokenIndex324
			return false
		},
		/* 73 DOTDOT <- <('.' '.' _)> */
		func() bool {
			position326, tokenIndex326 := position, tokenIndex
			{
				position327 := position
				if buffer[position] != rune('.') {
					goto l326
				}
				position++
				if buffer[position] != rune('.') {
					goto l326
				}
				position++
				if !_rules[rule_]() {
					goto l326
				}
				add(ruleDOTDOT, position327)
			}
			return true
		l326:
			position, tokenIndex = position326, tokenIndex326
			return false
		},
		/* 74 DoubleColon <- <(':' ':' _)> */
		func() bool {
			position328, tokenIndex328 := position, tokenIndex
			{
				position329 := position
				if buffer[position] != rune(':') {
					goto l328
				}
				position++
				if buffer[position] != rune(':') {
					goto l328
				}
				position++
				if !_rules[rule_]() {
					goto l328
				}
				add(ruleDoubleColon, position329)
			}
			return true
		l328:
			position, tokenIndex = position328, tokenIndex328
			return false
		},
		/* 75 SingleColon <- <(':' _)> */
		func() bool {
			position330, tokenIndex330 := position, tokenIndex
			{
				position331 := position
				if buffer[position] != rune(':') {
					goto l330
				}
				position++
				if !_rules[rule_]() {
					goto l330
				}
				add(ruleSingleColon, position331)
			}
			return true
		l330:
			position, tokenIndex = position330, tokenIndex330
			return false
		},
		/* 76 _ <- <(' ' / '\t' / '\r' / '\n' / Comment / DocComment)*> */
		func() bool {
			{
				position333 := position
			l334:
				{
					position335, tokenIndex335 := position, tokenIndex
					{
						position336, tokenIndex336 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l337
						}
						position++
						goto l336
					l337:
						position, tokenIndex = position336, tokenIndex336
						if buffer[position] != rune('\t') {
							goto l338
						}
						position++
						goto l336
					l338:
						position, tokenIndex = position336, tokenIndex336
						if buffer[position] != rune('\r') {
							goto l339
						}
						position++
						goto l336
					l339:
						position, tokenIndex = position336, tokenIndex336
						if buffer[position] != rune('\n') {
							goto l340
						}
						position++
						goto l336
					l340:
						position, tokenIndex = position336, tokenIndex336
						if !_rules[ruleComment]() {
							goto l341
						}
						goto l336
					l341:
						position, tokenIndex = position336, tokenIndex336
						if !_rules[ruleDocComment]() {
							goto l335
						}
					}
				l336:
					goto l334
				l335:
					position, tokenIndex = position335, tokenIndex335
				}
				add(rule_, position333)
			}
			return true
		},
		/* 77 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position342, tokenIndex342 := position, tokenIndex
			{
				position343 := position
				{
					position344, tokenIndex344 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l345
					}
					position++
					if buffer[position] != rune('\n') {
						goto l345
					}
					position++
					goto l344
				l345:
					position, tokenIndex = position344, tokenIndex344
					if buffer[position] != rune('\n') {
						goto l346
					}
					position++
					goto l344
				l346:
					position, tokenIndex = position344, tokenIndex344
					if buffer[position] != rune('\r') {
						goto l342
					}
					position++
				}
			l344:
				add(ruleEOL, position343)
			}
			return true
		l342:
			position, tokenIndex = position342, tokenIndex342
			return false
		},
	}
	p.rules = _rules
	return nil
}
