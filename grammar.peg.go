package main

// Code generated by peg grammar.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleStart
	ruleStatement
	ruleUseStmt
	ruleUsePath
	ruleTypeAlias
	ruleStructDef
	ruleFieldList
	ruleFieldOrSpread
	ruleField
	ruleComputedField
	ruleNamedField
	ruleSpreadField
	ruleFieldName
	ruleEnumDef
	ruleEnumValueList
	ruleEnumValue
	ruleDispatchStmt
	ruleDispatchPath
	ruleDispatchKeyList
	ruleDispatchKey
	ruleDispatchTarget
	ruleSpreadStruct
	ruleType
	ruleAttributedType
	ruleConstrainedType
	ruleUnionType
	ruleArrayType
	ruleStructType
	rulePrimitiveType
	ruleReferenceType
	ruleComplexReference
	ruleComplexRefParam
	ruleStaticIndexKey
	ruleLiteralType
	ruleArrayConstraint
	ruleRange
	ruleAttribute
	ruleAttributeList
	ruleAttributeItem
	ruleAttributeCall
	ruleAttributeParamList
	ruleAttributeParam
	ruleAttributePair
	ruleAttributeValue
	ruleArrayLiteral
	ruleComment
	ruleDocComment
	ruleIdentifier
	ruleString
	ruleNumber
	ruleBoolean
	ruleLBRACE
	ruleRBRACE
	ruleLBRACKET
	ruleRBRACKET
	ruleLPAREN
	ruleRPAREN
	ruleCOMMA
	ruleCOLON
	ruleSEMICOLON
	ruleEQUALS
	rulePIPE
	ruleDOT
	ruleSPREAD
	ruleAT
	ruleDoubleColon
	ruleSingleColon
	rule_
	ruleEOL
)

var rul3s = [...]string{
	"Unknown",
	"Start",
	"Statement",
	"UseStmt",
	"UsePath",
	"TypeAlias",
	"StructDef",
	"FieldList",
	"FieldOrSpread",
	"Field",
	"ComputedField",
	"NamedField",
	"SpreadField",
	"FieldName",
	"EnumDef",
	"EnumValueList",
	"EnumValue",
	"DispatchStmt",
	"DispatchPath",
	"DispatchKeyList",
	"DispatchKey",
	"DispatchTarget",
	"SpreadStruct",
	"Type",
	"AttributedType",
	"ConstrainedType",
	"UnionType",
	"ArrayType",
	"StructType",
	"PrimitiveType",
	"ReferenceType",
	"ComplexReference",
	"ComplexRefParam",
	"StaticIndexKey",
	"LiteralType",
	"ArrayConstraint",
	"Range",
	"Attribute",
	"AttributeList",
	"AttributeItem",
	"AttributeCall",
	"AttributeParamList",
	"AttributeParam",
	"AttributePair",
	"AttributeValue",
	"ArrayLiteral",
	"Comment",
	"DocComment",
	"Identifier",
	"String",
	"Number",
	"Boolean",
	"LBRACE",
	"RBRACE",
	"LBRACKET",
	"RBRACKET",
	"LPAREN",
	"RPAREN",
	"COMMA",
	"COLON",
	"SEMICOLON",
	"EQUALS",
	"PIPE",
	"DOT",
	"SPREAD",
	"AT",
	"DoubleColon",
	"SingleColon",
	"_",
	"EOL",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type MCDocParser struct {
	Buffer string
	buffer []rune
	rules  [70]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *MCDocParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *MCDocParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *MCDocParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *MCDocParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *MCDocParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *MCDocParser) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*MCDocParser) error {
	return func(p *MCDocParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *MCDocParser) Init(options ...func(*MCDocParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Start <- <(_ Statement* _ !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[rule_]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleStatement]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if !_rules[rule_]() {
					goto l0
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !matchDot() {
						goto l4
					}
					goto l0
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
				add(ruleStart, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Statement <- <(Attribute* _ (UseStmt / TypeAlias / StructDef / EnumDef / DispatchStmt) _)> */
		func() bool {
			position5, tokenIndex5 := position, tokenIndex
			{
				position6 := position
			l7:
				{
					position8, tokenIndex8 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l8
					}
					goto l7
				l8:
					position, tokenIndex = position8, tokenIndex8
				}
				if !_rules[rule_]() {
					goto l5
				}
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[ruleUseStmt]() {
						goto l10
					}
					goto l9
				l10:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleTypeAlias]() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleStructDef]() {
						goto l12
					}
					goto l9
				l12:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleEnumDef]() {
						goto l13
					}
					goto l9
				l13:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleDispatchStmt]() {
						goto l5
					}
				}
			l9:
				if !_rules[rule_]() {
					goto l5
				}
				add(ruleStatement, position6)
			}
			return true
		l5:
			position, tokenIndex = position5, tokenIndex5
			return false
		},
		/* 2 UseStmt <- <('u' 's' 'e' _ UsePath)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if buffer[position] != rune('u') {
					goto l14
				}
				position++
				if buffer[position] != rune('s') {
					goto l14
				}
				position++
				if buffer[position] != rune('e') {
					goto l14
				}
				position++
				if !_rules[rule_]() {
					goto l14
				}
				if !_rules[ruleUsePath]() {
					goto l14
				}
				add(ruleUseStmt, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 3 UsePath <- <((DoubleColon Identifier (DoubleColon Identifier)*) / (Identifier ((DoubleColon Identifier) / (SingleColon Identifier))*))> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				{
					position18, tokenIndex18 := position, tokenIndex
					if !_rules[ruleDoubleColon]() {
						goto l19
					}
					if !_rules[ruleIdentifier]() {
						goto l19
					}
				l20:
					{
						position21, tokenIndex21 := position, tokenIndex
						if !_rules[ruleDoubleColon]() {
							goto l21
						}
						if !_rules[ruleIdentifier]() {
							goto l21
						}
						goto l20
					l21:
						position, tokenIndex = position21, tokenIndex21
					}
					goto l18
				l19:
					position, tokenIndex = position18, tokenIndex18
					if !_rules[ruleIdentifier]() {
						goto l16
					}
				l22:
					{
						position23, tokenIndex23 := position, tokenIndex
						{
							position24, tokenIndex24 := position, tokenIndex
							if !_rules[ruleDoubleColon]() {
								goto l25
							}
							if !_rules[ruleIdentifier]() {
								goto l25
							}
							goto l24
						l25:
							position, tokenIndex = position24, tokenIndex24
							if !_rules[ruleSingleColon]() {
								goto l23
							}
							if !_rules[ruleIdentifier]() {
								goto l23
							}
						}
					l24:
						goto l22
					l23:
						position, tokenIndex = position23, tokenIndex23
					}
				}
			l18:
				add(ruleUsePath, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 4 TypeAlias <- <('t' 'y' 'p' 'e' _ Identifier _ EQUALS Type)> */
		func() bool {
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				if buffer[position] != rune('t') {
					goto l26
				}
				position++
				if buffer[position] != rune('y') {
					goto l26
				}
				position++
				if buffer[position] != rune('p') {
					goto l26
				}
				position++
				if buffer[position] != rune('e') {
					goto l26
				}
				position++
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleIdentifier]() {
					goto l26
				}
				if !_rules[rule_]() {
					goto l26
				}
				if !_rules[ruleEQUALS]() {
					goto l26
				}
				if !_rules[ruleType]() {
					goto l26
				}
				add(ruleTypeAlias, position27)
			}
			return true
		l26:
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 5 StructDef <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier _ LBRACE FieldList? RBRACE)> */
		func() bool {
			position28, tokenIndex28 := position, tokenIndex
			{
				position29 := position
				if buffer[position] != rune('s') {
					goto l28
				}
				position++
				if buffer[position] != rune('t') {
					goto l28
				}
				position++
				if buffer[position] != rune('r') {
					goto l28
				}
				position++
				if buffer[position] != rune('u') {
					goto l28
				}
				position++
				if buffer[position] != rune('c') {
					goto l28
				}
				position++
				if buffer[position] != rune('t') {
					goto l28
				}
				position++
				if !_rules[rule_]() {
					goto l28
				}
				if !_rules[ruleIdentifier]() {
					goto l28
				}
				if !_rules[rule_]() {
					goto l28
				}
				if !_rules[ruleLBRACE]() {
					goto l28
				}
				{
					position30, tokenIndex30 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l30
					}
					goto l31
				l30:
					position, tokenIndex = position30, tokenIndex30
				}
			l31:
				if !_rules[ruleRBRACE]() {
					goto l28
				}
				add(ruleStructDef, position29)
			}
			return true
		l28:
			position, tokenIndex = position28, tokenIndex28
			return false
		},
		/* 6 FieldList <- <(FieldOrSpread (COMMA FieldOrSpread)* COMMA?)> */
		func() bool {
			position32, tokenIndex32 := position, tokenIndex
			{
				position33 := position
				if !_rules[ruleFieldOrSpread]() {
					goto l32
				}
			l34:
				{
					position35, tokenIndex35 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l35
					}
					if !_rules[ruleFieldOrSpread]() {
						goto l35
					}
					goto l34
				l35:
					position, tokenIndex = position35, tokenIndex35
				}
				{
					position36, tokenIndex36 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l36
					}
					goto l37
				l36:
					position, tokenIndex = position36, tokenIndex36
				}
			l37:
				add(ruleFieldList, position33)
			}
			return true
		l32:
			position, tokenIndex = position32, tokenIndex32
			return false
		},
		/* 7 FieldOrSpread <- <(SpreadField / Field)> */
		func() bool {
			position38, tokenIndex38 := position, tokenIndex
			{
				position39 := position
				{
					position40, tokenIndex40 := position, tokenIndex
					if !_rules[ruleSpreadField]() {
						goto l41
					}
					goto l40
				l41:
					position, tokenIndex = position40, tokenIndex40
					if !_rules[ruleField]() {
						goto l38
					}
				}
			l40:
				add(ruleFieldOrSpread, position39)
			}
			return true
		l38:
			position, tokenIndex = position38, tokenIndex38
			return false
		},
		/* 8 Field <- <(Attribute* _ (ComputedField / NamedField))> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
			l44:
				{
					position45, tokenIndex45 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l45
					}
					goto l44
				l45:
					position, tokenIndex = position45, tokenIndex45
				}
				if !_rules[rule_]() {
					goto l42
				}
				{
					position46, tokenIndex46 := position, tokenIndex
					if !_rules[ruleComputedField]() {
						goto l47
					}
					goto l46
				l47:
					position, tokenIndex = position46, tokenIndex46
					if !_rules[ruleNamedField]() {
						goto l42
					}
				}
			l46:
				add(ruleField, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 9 ComputedField <- <(LBRACKET Type RBRACKET COLON Type)> */
		func() bool {
			position48, tokenIndex48 := position, tokenIndex
			{
				position49 := position
				if !_rules[ruleLBRACKET]() {
					goto l48
				}
				if !_rules[ruleType]() {
					goto l48
				}
				if !_rules[ruleRBRACKET]() {
					goto l48
				}
				if !_rules[ruleCOLON]() {
					goto l48
				}
				if !_rules[ruleType]() {
					goto l48
				}
				add(ruleComputedField, position49)
			}
			return true
		l48:
			position, tokenIndex = position48, tokenIndex48
			return false
		},
		/* 10 NamedField <- <(FieldName COLON Type)> */
		func() bool {
			position50, tokenIndex50 := position, tokenIndex
			{
				position51 := position
				if !_rules[ruleFieldName]() {
					goto l50
				}
				if !_rules[ruleCOLON]() {
					goto l50
				}
				if !_rules[ruleType]() {
					goto l50
				}
				add(ruleNamedField, position51)
			}
			return true
		l50:
			position, tokenIndex = position50, tokenIndex50
			return false
		},
		/* 11 SpreadField <- <(Attribute* _ SPREAD Type)> */
		func() bool {
			position52, tokenIndex52 := position, tokenIndex
			{
				position53 := position
			l54:
				{
					position55, tokenIndex55 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l55
					}
					goto l54
				l55:
					position, tokenIndex = position55, tokenIndex55
				}
				if !_rules[rule_]() {
					goto l52
				}
				if !_rules[ruleSPREAD]() {
					goto l52
				}
				if !_rules[ruleType]() {
					goto l52
				}
				add(ruleSpreadField, position53)
			}
			return true
		l52:
			position, tokenIndex = position52, tokenIndex52
			return false
		},
		/* 12 FieldName <- <(Identifier '?'? _)> */
		func() bool {
			position56, tokenIndex56 := position, tokenIndex
			{
				position57 := position
				if !_rules[ruleIdentifier]() {
					goto l56
				}
				{
					position58, tokenIndex58 := position, tokenIndex
					if buffer[position] != rune('?') {
						goto l58
					}
					position++
					goto l59
				l58:
					position, tokenIndex = position58, tokenIndex58
				}
			l59:
				if !_rules[rule_]() {
					goto l56
				}
				add(ruleFieldName, position57)
			}
			return true
		l56:
			position, tokenIndex = position56, tokenIndex56
			return false
		},
		/* 13 EnumDef <- <('e' 'n' 'u' 'm' _ LPAREN Type RPAREN Identifier _ LBRACE EnumValueList? RBRACE)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if buffer[position] != rune('e') {
					goto l60
				}
				position++
				if buffer[position] != rune('n') {
					goto l60
				}
				position++
				if buffer[position] != rune('u') {
					goto l60
				}
				position++
				if buffer[position] != rune('m') {
					goto l60
				}
				position++
				if !_rules[rule_]() {
					goto l60
				}
				if !_rules[ruleLPAREN]() {
					goto l60
				}
				if !_rules[ruleType]() {
					goto l60
				}
				if !_rules[ruleRPAREN]() {
					goto l60
				}
				if !_rules[ruleIdentifier]() {
					goto l60
				}
				if !_rules[rule_]() {
					goto l60
				}
				if !_rules[ruleLBRACE]() {
					goto l60
				}
				{
					position62, tokenIndex62 := position, tokenIndex
					if !_rules[ruleEnumValueList]() {
						goto l62
					}
					goto l63
				l62:
					position, tokenIndex = position62, tokenIndex62
				}
			l63:
				if !_rules[ruleRBRACE]() {
					goto l60
				}
				add(ruleEnumDef, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 14 EnumValueList <- <(EnumValue (COMMA EnumValue)* COMMA?)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if !_rules[ruleEnumValue]() {
					goto l64
				}
			l66:
				{
					position67, tokenIndex67 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l67
					}
					if !_rules[ruleEnumValue]() {
						goto l67
					}
					goto l66
				l67:
					position, tokenIndex = position67, tokenIndex67
				}
				{
					position68, tokenIndex68 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l68
					}
					goto l69
				l68:
					position, tokenIndex = position68, tokenIndex68
				}
			l69:
				add(ruleEnumValueList, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 15 EnumValue <- <(Attribute* _ Identifier _ EQUALS String)> */
		func() bool {
			position70, tokenIndex70 := position, tokenIndex
			{
				position71 := position
			l72:
				{
					position73, tokenIndex73 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l73
					}
					goto l72
				l73:
					position, tokenIndex = position73, tokenIndex73
				}
				if !_rules[rule_]() {
					goto l70
				}
				if !_rules[ruleIdentifier]() {
					goto l70
				}
				if !_rules[rule_]() {
					goto l70
				}
				if !_rules[ruleEQUALS]() {
					goto l70
				}
				if !_rules[ruleString]() {
					goto l70
				}
				add(ruleEnumValue, position71)
			}
			return true
		l70:
			position, tokenIndex = position70, tokenIndex70
			return false
		},
		/* 16 DispatchStmt <- <('d' 'i' 's' 'p' 'a' 't' 'c' 'h' _ DispatchPath _ ('t' 'o') _ DispatchTarget)> */
		func() bool {
			position74, tokenIndex74 := position, tokenIndex
			{
				position75 := position
				if buffer[position] != rune('d') {
					goto l74
				}
				position++
				if buffer[position] != rune('i') {
					goto l74
				}
				position++
				if buffer[position] != rune('s') {
					goto l74
				}
				position++
				if buffer[position] != rune('p') {
					goto l74
				}
				position++
				if buffer[position] != rune('a') {
					goto l74
				}
				position++
				if buffer[position] != rune('t') {
					goto l74
				}
				position++
				if buffer[position] != rune('c') {
					goto l74
				}
				position++
				if buffer[position] != rune('h') {
					goto l74
				}
				position++
				if !_rules[rule_]() {
					goto l74
				}
				if !_rules[ruleDispatchPath]() {
					goto l74
				}
				if !_rules[rule_]() {
					goto l74
				}
				if buffer[position] != rune('t') {
					goto l74
				}
				position++
				if buffer[position] != rune('o') {
					goto l74
				}
				position++
				if !_rules[rule_]() {
					goto l74
				}
				if !_rules[ruleDispatchTarget]() {
					goto l74
				}
				add(ruleDispatchStmt, position75)
			}
			return true
		l74:
			position, tokenIndex = position74, tokenIndex74
			return false
		},
		/* 17 DispatchPath <- <('m' 'i' 'n' 'e' 'c' 'r' 'a' 'f' 't' ':' Identifier LBRACKET DispatchKeyList RBRACKET)> */
		func() bool {
			position76, tokenIndex76 := position, tokenIndex
			{
				position77 := position
				if buffer[position] != rune('m') {
					goto l76
				}
				position++
				if buffer[position] != rune('i') {
					goto l76
				}
				position++
				if buffer[position] != rune('n') {
					goto l76
				}
				position++
				if buffer[position] != rune('e') {
					goto l76
				}
				position++
				if buffer[position] != rune('c') {
					goto l76
				}
				position++
				if buffer[position] != rune('r') {
					goto l76
				}
				position++
				if buffer[position] != rune('a') {
					goto l76
				}
				position++
				if buffer[position] != rune('f') {
					goto l76
				}
				position++
				if buffer[position] != rune('t') {
					goto l76
				}
				position++
				if buffer[position] != rune(':') {
					goto l76
				}
				position++
				if !_rules[ruleIdentifier]() {
					goto l76
				}
				if !_rules[ruleLBRACKET]() {
					goto l76
				}
				if !_rules[ruleDispatchKeyList]() {
					goto l76
				}
				if !_rules[ruleRBRACKET]() {
					goto l76
				}
				add(ruleDispatchPath, position77)
			}
			return true
		l76:
			position, tokenIndex = position76, tokenIndex76
			return false
		},
		/* 18 DispatchKeyList <- <(DispatchKey (COMMA DispatchKey)* COMMA?)> */
		func() bool {
			position78, tokenIndex78 := position, tokenIndex
			{
				position79 := position
				if !_rules[ruleDispatchKey]() {
					goto l78
				}
			l80:
				{
					position81, tokenIndex81 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l81
					}
					if !_rules[ruleDispatchKey]() {
						goto l81
					}
					goto l80
				l81:
					position, tokenIndex = position81, tokenIndex81
				}
				{
					position82, tokenIndex82 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l82
					}
					goto l83
				l82:
					position, tokenIndex = position82, tokenIndex82
				}
			l83:
				add(ruleDispatchKeyList, position79)
			}
			return true
		l78:
			position, tokenIndex = position78, tokenIndex78
			return false
		},
		/* 19 DispatchKey <- <(StaticIndexKey / String / Identifier)> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				{
					position86, tokenIndex86 := position, tokenIndex
					if !_rules[ruleStaticIndexKey]() {
						goto l87
					}
					goto l86
				l87:
					position, tokenIndex = position86, tokenIndex86
					if !_rules[ruleString]() {
						goto l88
					}
					goto l86
				l88:
					position, tokenIndex = position86, tokenIndex86
					if !_rules[ruleIdentifier]() {
						goto l84
					}
				}
			l86:
				add(ruleDispatchKey, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 20 DispatchTarget <- <(('s' 't' 'r' 'u' 'c' 't' _ Identifier _ LBRACE FieldList? RBRACE) / Type)> */
		func() bool {
			position89, tokenIndex89 := position, tokenIndex
			{
				position90 := position
				{
					position91, tokenIndex91 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l92
					}
					position++
					if buffer[position] != rune('t') {
						goto l92
					}
					position++
					if buffer[position] != rune('r') {
						goto l92
					}
					position++
					if buffer[position] != rune('u') {
						goto l92
					}
					position++
					if buffer[position] != rune('c') {
						goto l92
					}
					position++
					if buffer[position] != rune('t') {
						goto l92
					}
					position++
					if !_rules[rule_]() {
						goto l92
					}
					if !_rules[ruleIdentifier]() {
						goto l92
					}
					if !_rules[rule_]() {
						goto l92
					}
					if !_rules[ruleLBRACE]() {
						goto l92
					}
					{
						position93, tokenIndex93 := position, tokenIndex
						if !_rules[ruleFieldList]() {
							goto l93
						}
						goto l94
					l93:
						position, tokenIndex = position93, tokenIndex93
					}
				l94:
					if !_rules[ruleRBRACE]() {
						goto l92
					}
					goto l91
				l92:
					position, tokenIndex = position91, tokenIndex91
					if !_rules[ruleType]() {
						goto l89
					}
				}
			l91:
				add(ruleDispatchTarget, position90)
			}
			return true
		l89:
			position, tokenIndex = position89, tokenIndex89
			return false
		},
		/* 21 SpreadStruct <- <(SPREAD ('s' 't' 'r' 'u' 'c' 't') _ Identifier _ LBRACE FieldList? RBRACE)> */
		nil,
		/* 22 Type <- <(UnionType / AttributedType / ArrayType / StructType / ConstrainedType / PrimitiveType / ReferenceType / LiteralType)> */
		func() bool {
			position96, tokenIndex96 := position, tokenIndex
			{
				position97 := position
				{
					position98, tokenIndex98 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l99
					}
					goto l98
				l99:
					position, tokenIndex = position98, tokenIndex98
					if !_rules[ruleAttributedType]() {
						goto l100
					}
					goto l98
				l100:
					position, tokenIndex = position98, tokenIndex98
					if !_rules[ruleArrayType]() {
						goto l101
					}
					goto l98
				l101:
					position, tokenIndex = position98, tokenIndex98
					if !_rules[ruleStructType]() {
						goto l102
					}
					goto l98
				l102:
					position, tokenIndex = position98, tokenIndex98
					if !_rules[ruleConstrainedType]() {
						goto l103
					}
					goto l98
				l103:
					position, tokenIndex = position98, tokenIndex98
					if !_rules[rulePrimitiveType]() {
						goto l104
					}
					goto l98
				l104:
					position, tokenIndex = position98, tokenIndex98
					if !_rules[ruleReferenceType]() {
						goto l105
					}
					goto l98
				l105:
					position, tokenIndex = position98, tokenIndex98
					if !_rules[ruleLiteralType]() {
						goto l96
					}
				}
			l98:
				add(ruleType, position97)
			}
			return true
		l96:
			position, tokenIndex = position96, tokenIndex96
			return false
		},
		/* 23 AttributedType <- <(Attribute+ _ (UnionType / ArrayType / ConstrainedType / StructType / PrimitiveType / ReferenceType / LiteralType))> */
		func() bool {
			position106, tokenIndex106 := position, tokenIndex
			{
				position107 := position
				if !_rules[ruleAttribute]() {
					goto l106
				}
			l108:
				{
					position109, tokenIndex109 := position, tokenIndex
					if !_rules[ruleAttribute]() {
						goto l109
					}
					goto l108
				l109:
					position, tokenIndex = position109, tokenIndex109
				}
				if !_rules[rule_]() {
					goto l106
				}
				{
					position110, tokenIndex110 := position, tokenIndex
					if !_rules[ruleUnionType]() {
						goto l111
					}
					goto l110
				l111:
					position, tokenIndex = position110, tokenIndex110
					if !_rules[ruleArrayType]() {
						goto l112
					}
					goto l110
				l112:
					position, tokenIndex = position110, tokenIndex110
					if !_rules[ruleConstrainedType]() {
						goto l113
					}
					goto l110
				l113:
					position, tokenIndex = position110, tokenIndex110
					if !_rules[ruleStructType]() {
						goto l114
					}
					goto l110
				l114:
					position, tokenIndex = position110, tokenIndex110
					if !_rules[rulePrimitiveType]() {
						goto l115
					}
					goto l110
				l115:
					position, tokenIndex = position110, tokenIndex110
					if !_rules[ruleReferenceType]() {
						goto l116
					}
					goto l110
				l116:
					position, tokenIndex = position110, tokenIndex110
					if !_rules[ruleLiteralType]() {
						goto l106
					}
				}
			l110:
				add(ruleAttributedType, position107)
			}
			return true
		l106:
			position, tokenIndex = position106, tokenIndex106
			return false
		},
		/* 24 ConstrainedType <- <((PrimitiveType / ReferenceType / LiteralType) _ ArrayConstraint)> */
		func() bool {
			position117, tokenIndex117 := position, tokenIndex
			{
				position118 := position
				{
					position119, tokenIndex119 := position, tokenIndex
					if !_rules[rulePrimitiveType]() {
						goto l120
					}
					goto l119
				l120:
					position, tokenIndex = position119, tokenIndex119
					if !_rules[ruleReferenceType]() {
						goto l121
					}
					goto l119
				l121:
					position, tokenIndex = position119, tokenIndex119
					if !_rules[ruleLiteralType]() {
						goto l117
					}
				}
			l119:
				if !_rules[rule_]() {
					goto l117
				}
				if !_rules[ruleArrayConstraint]() {
					goto l117
				}
				add(ruleConstrainedType, position118)
			}
			return true
		l117:
			position, tokenIndex = position117, tokenIndex117
			return false
		},
		/* 25 UnionType <- <(LPAREN Type (PIPE Type)* PIPE? RPAREN)> */
		func() bool {
			position122, tokenIndex122 := position, tokenIndex
			{
				position123 := position
				if !_rules[ruleLPAREN]() {
					goto l122
				}
				if !_rules[ruleType]() {
					goto l122
				}
			l124:
				{
					position125, tokenIndex125 := position, tokenIndex
					if !_rules[rulePIPE]() {
						goto l125
					}
					if !_rules[ruleType]() {
						goto l125
					}
					goto l124
				l125:
					position, tokenIndex = position125, tokenIndex125
				}
				{
					position126, tokenIndex126 := position, tokenIndex
					if !_rules[rulePIPE]() {
						goto l126
					}
					goto l127
				l126:
					position, tokenIndex = position126, tokenIndex126
				}
			l127:
				if !_rules[ruleRPAREN]() {
					goto l122
				}
				add(ruleUnionType, position123)
			}
			return true
		l122:
			position, tokenIndex = position122, tokenIndex122
			return false
		},
		/* 26 ArrayType <- <(LBRACKET Type RBRACKET ArrayConstraint?)> */
		func() bool {
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				if !_rules[ruleLBRACKET]() {
					goto l128
				}
				if !_rules[ruleType]() {
					goto l128
				}
				if !_rules[ruleRBRACKET]() {
					goto l128
				}
				{
					position130, tokenIndex130 := position, tokenIndex
					if !_rules[ruleArrayConstraint]() {
						goto l130
					}
					goto l131
				l130:
					position, tokenIndex = position130, tokenIndex130
				}
			l131:
				add(ruleArrayType, position129)
			}
			return true
		l128:
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 27 StructType <- <('s' 't' 'r' 'u' 'c' 't' _ Identifier? _ LBRACE FieldList? RBRACE)> */
		func() bool {
			position132, tokenIndex132 := position, tokenIndex
			{
				position133 := position
				if buffer[position] != rune('s') {
					goto l132
				}
				position++
				if buffer[position] != rune('t') {
					goto l132
				}
				position++
				if buffer[position] != rune('r') {
					goto l132
				}
				position++
				if buffer[position] != rune('u') {
					goto l132
				}
				position++
				if buffer[position] != rune('c') {
					goto l132
				}
				position++
				if buffer[position] != rune('t') {
					goto l132
				}
				position++
				if !_rules[rule_]() {
					goto l132
				}
				{
					position134, tokenIndex134 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l134
					}
					goto l135
				l134:
					position, tokenIndex = position134, tokenIndex134
				}
			l135:
				if !_rules[rule_]() {
					goto l132
				}
				if !_rules[ruleLBRACE]() {
					goto l132
				}
				{
					position136, tokenIndex136 := position, tokenIndex
					if !_rules[ruleFieldList]() {
						goto l136
					}
					goto l137
				l136:
					position, tokenIndex = position136, tokenIndex136
				}
			l137:
				if !_rules[ruleRBRACE]() {
					goto l132
				}
				add(ruleStructType, position133)
			}
			return true
		l132:
			position, tokenIndex = position132, tokenIndex132
			return false
		},
		/* 28 PrimitiveType <- <((('s' 't' 'r' 'i' 'n' 'g') / ('d' 'o' 'u' 'b' 'l' 'e') / ('f' 'l' 'o' 'a' 't') / ('i' 'n' 't') / ('b' 'o' 'o' 'l' 'e' 'a' 'n') / ('a' 'n' 'y')) _)> */
		func() bool {
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				{
					position140, tokenIndex140 := position, tokenIndex
					if buffer[position] != rune('s') {
						goto l141
					}
					position++
					if buffer[position] != rune('t') {
						goto l141
					}
					position++
					if buffer[position] != rune('r') {
						goto l141
					}
					position++
					if buffer[position] != rune('i') {
						goto l141
					}
					position++
					if buffer[position] != rune('n') {
						goto l141
					}
					position++
					if buffer[position] != rune('g') {
						goto l141
					}
					position++
					goto l140
				l141:
					position, tokenIndex = position140, tokenIndex140
					if buffer[position] != rune('d') {
						goto l142
					}
					position++
					if buffer[position] != rune('o') {
						goto l142
					}
					position++
					if buffer[position] != rune('u') {
						goto l142
					}
					position++
					if buffer[position] != rune('b') {
						goto l142
					}
					position++
					if buffer[position] != rune('l') {
						goto l142
					}
					position++
					if buffer[position] != rune('e') {
						goto l142
					}
					position++
					goto l140
				l142:
					position, tokenIndex = position140, tokenIndex140
					if buffer[position] != rune('f') {
						goto l143
					}
					position++
					if buffer[position] != rune('l') {
						goto l143
					}
					position++
					if buffer[position] != rune('o') {
						goto l143
					}
					position++
					if buffer[position] != rune('a') {
						goto l143
					}
					position++
					if buffer[position] != rune('t') {
						goto l143
					}
					position++
					goto l140
				l143:
					position, tokenIndex = position140, tokenIndex140
					if buffer[position] != rune('i') {
						goto l144
					}
					position++
					if buffer[position] != rune('n') {
						goto l144
					}
					position++
					if buffer[position] != rune('t') {
						goto l144
					}
					position++
					goto l140
				l144:
					position, tokenIndex = position140, tokenIndex140
					if buffer[position] != rune('b') {
						goto l145
					}
					position++
					if buffer[position] != rune('o') {
						goto l145
					}
					position++
					if buffer[position] != rune('o') {
						goto l145
					}
					position++
					if buffer[position] != rune('l') {
						goto l145
					}
					position++
					if buffer[position] != rune('e') {
						goto l145
					}
					position++
					if buffer[position] != rune('a') {
						goto l145
					}
					position++
					if buffer[position] != rune('n') {
						goto l145
					}
					position++
					goto l140
				l145:
					position, tokenIndex = position140, tokenIndex140
					if buffer[position] != rune('a') {
						goto l138
					}
					position++
					if buffer[position] != rune('n') {
						goto l138
					}
					position++
					if buffer[position] != rune('y') {
						goto l138
					}
					position++
				}
			l140:
				if !_rules[rule_]() {
					goto l138
				}
				add(rulePrimitiveType, position139)
			}
			return true
		l138:
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 29 ReferenceType <- <(ComplexReference / Identifier)> */
		func() bool {
			position146, tokenIndex146 := position, tokenIndex
			{
				position147 := position
				{
					position148, tokenIndex148 := position, tokenIndex
					if !_rules[ruleComplexReference]() {
						goto l149
					}
					goto l148
				l149:
					position, tokenIndex = position148, tokenIndex148
					if !_rules[ruleIdentifier]() {
						goto l146
					}
				}
			l148:
				add(ruleReferenceType, position147)
			}
			return true
		l146:
			position, tokenIndex = position146, tokenIndex146
			return false
		},
		/* 30 ComplexReference <- <(Identifier COLON Identifier ((LBRACKET LBRACKET ComplexRefParam RBRACKET RBRACKET) / (LBRACKET ComplexRefParam RBRACKET)))> */
		func() bool {
			position150, tokenIndex150 := position, tokenIndex
			{
				position151 := position
				if !_rules[ruleIdentifier]() {
					goto l150
				}
				if !_rules[ruleCOLON]() {
					goto l150
				}
				if !_rules[ruleIdentifier]() {
					goto l150
				}
				{
					position152, tokenIndex152 := position, tokenIndex
					if !_rules[ruleLBRACKET]() {
						goto l153
					}
					if !_rules[ruleLBRACKET]() {
						goto l153
					}
					if !_rules[ruleComplexRefParam]() {
						goto l153
					}
					if !_rules[ruleRBRACKET]() {
						goto l153
					}
					if !_rules[ruleRBRACKET]() {
						goto l153
					}
					goto l152
				l153:
					position, tokenIndex = position152, tokenIndex152
					if !_rules[ruleLBRACKET]() {
						goto l150
					}
					if !_rules[ruleComplexRefParam]() {
						goto l150
					}
					if !_rules[ruleRBRACKET]() {
						goto l150
					}
				}
			l152:
				add(ruleComplexReference, position151)
			}
			return true
		l150:
			position, tokenIndex = position150, tokenIndex150
			return false
		},
		/* 31 ComplexRefParam <- <(StaticIndexKey / String / Identifier)> */
		func() bool {
			position154, tokenIndex154 := position, tokenIndex
			{
				position155 := position
				{
					position156, tokenIndex156 := position, tokenIndex
					if !_rules[ruleStaticIndexKey]() {
						goto l157
					}
					goto l156
				l157:
					position, tokenIndex = position156, tokenIndex156
					if !_rules[ruleString]() {
						goto l158
					}
					goto l156
				l158:
					position, tokenIndex = position156, tokenIndex156
					if !_rules[ruleIdentifier]() {
						goto l154
					}
				}
			l156:
				add(ruleComplexRefParam, position155)
			}
			return true
		l154:
			position, tokenIndex = position154, tokenIndex154
			return false
		},
		/* 32 StaticIndexKey <- <((('%' 'f' 'a' 'l' 'l' 'b' 'a' 'c' 'k') / ('%' 'k' 'e' 'y') / ('%' 'p' 'a' 'r' 'e' 'n' 't') / ('%' 'n' 'o' 'n' 'e') / ('%' 'u' 'n' 'k' 'n' 'o' 'w' 'n')) _)> */
		func() bool {
			position159, tokenIndex159 := position, tokenIndex
			{
				position160 := position
				{
					position161, tokenIndex161 := position, tokenIndex
					if buffer[position] != rune('%') {
						goto l162
					}
					position++
					if buffer[position] != rune('f') {
						goto l162
					}
					position++
					if buffer[position] != rune('a') {
						goto l162
					}
					position++
					if buffer[position] != rune('l') {
						goto l162
					}
					position++
					if buffer[position] != rune('l') {
						goto l162
					}
					position++
					if buffer[position] != rune('b') {
						goto l162
					}
					position++
					if buffer[position] != rune('a') {
						goto l162
					}
					position++
					if buffer[position] != rune('c') {
						goto l162
					}
					position++
					if buffer[position] != rune('k') {
						goto l162
					}
					position++
					goto l161
				l162:
					position, tokenIndex = position161, tokenIndex161
					if buffer[position] != rune('%') {
						goto l163
					}
					position++
					if buffer[position] != rune('k') {
						goto l163
					}
					position++
					if buffer[position] != rune('e') {
						goto l163
					}
					position++
					if buffer[position] != rune('y') {
						goto l163
					}
					position++
					goto l161
				l163:
					position, tokenIndex = position161, tokenIndex161
					if buffer[position] != rune('%') {
						goto l164
					}
					position++
					if buffer[position] != rune('p') {
						goto l164
					}
					position++
					if buffer[position] != rune('a') {
						goto l164
					}
					position++
					if buffer[position] != rune('r') {
						goto l164
					}
					position++
					if buffer[position] != rune('e') {
						goto l164
					}
					position++
					if buffer[position] != rune('n') {
						goto l164
					}
					position++
					if buffer[position] != rune('t') {
						goto l164
					}
					position++
					goto l161
				l164:
					position, tokenIndex = position161, tokenIndex161
					if buffer[position] != rune('%') {
						goto l165
					}
					position++
					if buffer[position] != rune('n') {
						goto l165
					}
					position++
					if buffer[position] != rune('o') {
						goto l165
					}
					position++
					if buffer[position] != rune('n') {
						goto l165
					}
					position++
					if buffer[position] != rune('e') {
						goto l165
					}
					position++
					goto l161
				l165:
					position, tokenIndex = position161, tokenIndex161
					if buffer[position] != rune('%') {
						goto l159
					}
					position++
					if buffer[position] != rune('u') {
						goto l159
					}
					position++
					if buffer[position] != rune('n') {
						goto l159
					}
					position++
					if buffer[position] != rune('k') {
						goto l159
					}
					position++
					if buffer[position] != rune('n') {
						goto l159
					}
					position++
					if buffer[position] != rune('o') {
						goto l159
					}
					position++
					if buffer[position] != rune('w') {
						goto l159
					}
					position++
					if buffer[position] != rune('n') {
						goto l159
					}
					position++
				}
			l161:
				if !_rules[rule_]() {
					goto l159
				}
				add(ruleStaticIndexKey, position160)
			}
			return true
		l159:
			position, tokenIndex = position159, tokenIndex159
			return false
		},
		/* 33 LiteralType <- <(String / Number / Boolean)> */
		func() bool {
			position166, tokenIndex166 := position, tokenIndex
			{
				position167 := position
				{
					position168, tokenIndex168 := position, tokenIndex
					if !_rules[ruleString]() {
						goto l169
					}
					goto l168
				l169:
					position, tokenIndex = position168, tokenIndex168
					if !_rules[ruleNumber]() {
						goto l170
					}
					goto l168
				l170:
					position, tokenIndex = position168, tokenIndex168
					if !_rules[ruleBoolean]() {
						goto l166
					}
				}
			l168:
				add(ruleLiteralType, position167)
			}
			return true
		l166:
			position, tokenIndex = position166, tokenIndex166
			return false
		},
		/* 34 ArrayConstraint <- <(AT (Range / Number))> */
		func() bool {
			position171, tokenIndex171 := position, tokenIndex
			{
				position172 := position
				if !_rules[ruleAT]() {
					goto l171
				}
				{
					position173, tokenIndex173 := position, tokenIndex
					if !_rules[ruleRange]() {
						goto l174
					}
					goto l173
				l174:
					position, tokenIndex = position173, tokenIndex173
					if !_rules[ruleNumber]() {
						goto l171
					}
				}
			l173:
				add(ruleArrayConstraint, position172)
			}
			return true
		l171:
			position, tokenIndex = position171, tokenIndex171
			return false
		},
		/* 35 Range <- <((Number ('.' '.') Number?) / ('.' '.' Number))> */
		func() bool {
			position175, tokenIndex175 := position, tokenIndex
			{
				position176 := position
				{
					position177, tokenIndex177 := position, tokenIndex
					if !_rules[ruleNumber]() {
						goto l178
					}
					if buffer[position] != rune('.') {
						goto l178
					}
					position++
					if buffer[position] != rune('.') {
						goto l178
					}
					position++
					{
						position179, tokenIndex179 := position, tokenIndex
						if !_rules[ruleNumber]() {
							goto l179
						}
						goto l180
					l179:
						position, tokenIndex = position179, tokenIndex179
					}
				l180:
					goto l177
				l178:
					position, tokenIndex = position177, tokenIndex177
					if buffer[position] != rune('.') {
						goto l175
					}
					position++
					if buffer[position] != rune('.') {
						goto l175
					}
					position++
					if !_rules[ruleNumber]() {
						goto l175
					}
				}
			l177:
				add(ruleRange, position176)
			}
			return true
		l175:
			position, tokenIndex = position175, tokenIndex175
			return false
		},
		/* 36 Attribute <- <('#' LBRACKET AttributeList RBRACKET)> */
		func() bool {
			position181, tokenIndex181 := position, tokenIndex
			{
				position182 := position
				if buffer[position] != rune('#') {
					goto l181
				}
				position++
				if !_rules[ruleLBRACKET]() {
					goto l181
				}
				if !_rules[ruleAttributeList]() {
					goto l181
				}
				if !_rules[ruleRBRACKET]() {
					goto l181
				}
				add(ruleAttribute, position182)
			}
			return true
		l181:
			position, tokenIndex = position181, tokenIndex181
			return false
		},
		/* 37 AttributeList <- <(AttributeItem (COMMA AttributeItem)*)> */
		func() bool {
			position183, tokenIndex183 := position, tokenIndex
			{
				position184 := position
				if !_rules[ruleAttributeItem]() {
					goto l183
				}
			l185:
				{
					position186, tokenIndex186 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l186
					}
					if !_rules[ruleAttributeItem]() {
						goto l186
					}
					goto l185
				l186:
					position, tokenIndex = position186, tokenIndex186
				}
				add(ruleAttributeList, position184)
			}
			return true
		l183:
			position, tokenIndex = position183, tokenIndex183
			return false
		},
		/* 38 AttributeItem <- <(AttributePair / AttributeCall / Identifier)> */
		func() bool {
			position187, tokenIndex187 := position, tokenIndex
			{
				position188 := position
				{
					position189, tokenIndex189 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l190
					}
					goto l189
				l190:
					position, tokenIndex = position189, tokenIndex189
					if !_rules[ruleAttributeCall]() {
						goto l191
					}
					goto l189
				l191:
					position, tokenIndex = position189, tokenIndex189
					if !_rules[ruleIdentifier]() {
						goto l187
					}
				}
			l189:
				add(ruleAttributeItem, position188)
			}
			return true
		l187:
			position, tokenIndex = position187, tokenIndex187
			return false
		},
		/* 39 AttributeCall <- <(Identifier LPAREN AttributeParamList? RPAREN)> */
		func() bool {
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				if !_rules[ruleIdentifier]() {
					goto l192
				}
				if !_rules[ruleLPAREN]() {
					goto l192
				}
				{
					position194, tokenIndex194 := position, tokenIndex
					if !_rules[ruleAttributeParamList]() {
						goto l194
					}
					goto l195
				l194:
					position, tokenIndex = position194, tokenIndex194
				}
			l195:
				if !_rules[ruleRPAREN]() {
					goto l192
				}
				add(ruleAttributeCall, position193)
			}
			return true
		l192:
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 40 AttributeParamList <- <(AttributeParam (COMMA AttributeParam)*)> */
		func() bool {
			position196, tokenIndex196 := position, tokenIndex
			{
				position197 := position
				if !_rules[ruleAttributeParam]() {
					goto l196
				}
			l198:
				{
					position199, tokenIndex199 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l199
					}
					if !_rules[ruleAttributeParam]() {
						goto l199
					}
					goto l198
				l199:
					position, tokenIndex = position199, tokenIndex199
				}
				add(ruleAttributeParamList, position197)
			}
			return true
		l196:
			position, tokenIndex = position196, tokenIndex196
			return false
		},
		/* 41 AttributeParam <- <(AttributePair / AttributeValue)> */
		func() bool {
			position200, tokenIndex200 := position, tokenIndex
			{
				position201 := position
				{
					position202, tokenIndex202 := position, tokenIndex
					if !_rules[ruleAttributePair]() {
						goto l203
					}
					goto l202
				l203:
					position, tokenIndex = position202, tokenIndex202
					if !_rules[ruleAttributeValue]() {
						goto l200
					}
				}
			l202:
				add(ruleAttributeParam, position201)
			}
			return true
		l200:
			position, tokenIndex = position200, tokenIndex200
			return false
		},
		/* 42 AttributePair <- <(Identifier EQUALS AttributeValue)> */
		func() bool {
			position204, tokenIndex204 := position, tokenIndex
			{
				position205 := position
				if !_rules[ruleIdentifier]() {
					goto l204
				}
				if !_rules[ruleEQUALS]() {
					goto l204
				}
				if !_rules[ruleAttributeValue]() {
					goto l204
				}
				add(ruleAttributePair, position205)
			}
			return true
		l204:
			position, tokenIndex = position204, tokenIndex204
			return false
		},
		/* 43 AttributeValue <- <(ArrayLiteral / String / Number / Boolean / Identifier)> */
		func() bool {
			position206, tokenIndex206 := position, tokenIndex
			{
				position207 := position
				{
					position208, tokenIndex208 := position, tokenIndex
					if !_rules[ruleArrayLiteral]() {
						goto l209
					}
					goto l208
				l209:
					position, tokenIndex = position208, tokenIndex208
					if !_rules[ruleString]() {
						goto l210
					}
					goto l208
				l210:
					position, tokenIndex = position208, tokenIndex208
					if !_rules[ruleNumber]() {
						goto l211
					}
					goto l208
				l211:
					position, tokenIndex = position208, tokenIndex208
					if !_rules[ruleBoolean]() {
						goto l212
					}
					goto l208
				l212:
					position, tokenIndex = position208, tokenIndex208
					if !_rules[ruleIdentifier]() {
						goto l206
					}
				}
			l208:
				add(ruleAttributeValue, position207)
			}
			return true
		l206:
			position, tokenIndex = position206, tokenIndex206
			return false
		},
		/* 44 ArrayLiteral <- <(LBRACKET (AttributeValue (COMMA AttributeValue)*)? RBRACKET)> */
		func() bool {
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				if !_rules[ruleLBRACKET]() {
					goto l213
				}
				{
					position215, tokenIndex215 := position, tokenIndex
					if !_rules[ruleAttributeValue]() {
						goto l215
					}
				l217:
					{
						position218, tokenIndex218 := position, tokenIndex
						if !_rules[ruleCOMMA]() {
							goto l218
						}
						if !_rules[ruleAttributeValue]() {
							goto l218
						}
						goto l217
					l218:
						position, tokenIndex = position218, tokenIndex218
					}
					goto l216
				l215:
					position, tokenIndex = position215, tokenIndex215
				}
			l216:
				if !_rules[ruleRBRACKET]() {
					goto l213
				}
				add(ruleArrayLiteral, position214)
			}
			return true
		l213:
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 45 Comment <- <('/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if buffer[position] != rune('/') {
					goto l219
				}
				position++
				if buffer[position] != rune('/') {
					goto l219
				}
				position++
			l221:
				{
					position222, tokenIndex222 := position, tokenIndex
					{
						position223, tokenIndex223 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l223
						}
						goto l222
					l223:
						position, tokenIndex = position223, tokenIndex223
					}
					if !matchDot() {
						goto l222
					}
					goto l221
				l222:
					position, tokenIndex = position222, tokenIndex222
				}
				{
					position224, tokenIndex224 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l225
					}
					goto l224
				l225:
					position, tokenIndex = position224, tokenIndex224
					{
						position226, tokenIndex226 := position, tokenIndex
						if !matchDot() {
							goto l226
						}
						goto l219
					l226:
						position, tokenIndex = position226, tokenIndex226
					}
				}
			l224:
				add(ruleComment, position220)
			}
			return true
		l219:
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 46 DocComment <- <('/' '/' '/' (!EOL .)* (EOL / !.))> */
		func() bool {
			position227, tokenIndex227 := position, tokenIndex
			{
				position228 := position
				if buffer[position] != rune('/') {
					goto l227
				}
				position++
				if buffer[position] != rune('/') {
					goto l227
				}
				position++
				if buffer[position] != rune('/') {
					goto l227
				}
				position++
			l229:
				{
					position230, tokenIndex230 := position, tokenIndex
					{
						position231, tokenIndex231 := position, tokenIndex
						if !_rules[ruleEOL]() {
							goto l231
						}
						goto l230
					l231:
						position, tokenIndex = position231, tokenIndex231
					}
					if !matchDot() {
						goto l230
					}
					goto l229
				l230:
					position, tokenIndex = position230, tokenIndex230
				}
				{
					position232, tokenIndex232 := position, tokenIndex
					if !_rules[ruleEOL]() {
						goto l233
					}
					goto l232
				l233:
					position, tokenIndex = position232, tokenIndex232
					{
						position234, tokenIndex234 := position, tokenIndex
						if !matchDot() {
							goto l234
						}
						goto l227
					l234:
						position, tokenIndex = position234, tokenIndex234
					}
				}
			l232:
				add(ruleDocComment, position228)
			}
			return true
		l227:
			position, tokenIndex = position227, tokenIndex227
			return false
		},
		/* 47 Identifier <- <(([a-z] / [A-Z] / '_') ([a-z] / [A-Z] / [0-9] / '_')* _)> */
		func() bool {
			position235, tokenIndex235 := position, tokenIndex
			{
				position236 := position
				{
					position237, tokenIndex237 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l238
					}
					position++
					goto l237
				l238:
					position, tokenIndex = position237, tokenIndex237
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l239
					}
					position++
					goto l237
				l239:
					position, tokenIndex = position237, tokenIndex237
					if buffer[position] != rune('_') {
						goto l235
					}
					position++
				}
			l237:
			l240:
				{
					position241, tokenIndex241 := position, tokenIndex
					{
						position242, tokenIndex242 := position, tokenIndex
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l243
						}
						position++
						goto l242
					l243:
						position, tokenIndex = position242, tokenIndex242
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l244
						}
						position++
						goto l242
					l244:
						position, tokenIndex = position242, tokenIndex242
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l245
						}
						position++
						goto l242
					l245:
						position, tokenIndex = position242, tokenIndex242
						if buffer[position] != rune('_') {
							goto l241
						}
						position++
					}
				l242:
					goto l240
				l241:
					position, tokenIndex = position241, tokenIndex241
				}
				if !_rules[rule_]() {
					goto l235
				}
				add(ruleIdentifier, position236)
			}
			return true
		l235:
			position, tokenIndex = position235, tokenIndex235
			return false
		},
		/* 48 String <- <('"' (!'"' .)* '"' _)> */
		func() bool {
			position246, tokenIndex246 := position, tokenIndex
			{
				position247 := position
				if buffer[position] != rune('"') {
					goto l246
				}
				position++
			l248:
				{
					position249, tokenIndex249 := position, tokenIndex
					{
						position250, tokenIndex250 := position, tokenIndex
						if buffer[position] != rune('"') {
							goto l250
						}
						position++
						goto l249
					l250:
						position, tokenIndex = position250, tokenIndex250
					}
					if !matchDot() {
						goto l249
					}
					goto l248
				l249:
					position, tokenIndex = position249, tokenIndex249
				}
				if buffer[position] != rune('"') {
					goto l246
				}
				position++
				if !_rules[rule_]() {
					goto l246
				}
				add(ruleString, position247)
			}
			return true
		l246:
			position, tokenIndex = position246, tokenIndex246
			return false
		},
		/* 49 Number <- <('-'? [0-9]+ ('.' [0-9]+)? _)> */
		func() bool {
			position251, tokenIndex251 := position, tokenIndex
			{
				position252 := position
				{
					position253, tokenIndex253 := position, tokenIndex
					if buffer[position] != rune('-') {
						goto l253
					}
					position++
					goto l254
				l253:
					position, tokenIndex = position253, tokenIndex253
				}
			l254:
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l251
				}
				position++
			l255:
				{
					position256, tokenIndex256 := position, tokenIndex
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l256
					}
					position++
					goto l255
				l256:
					position, tokenIndex = position256, tokenIndex256
				}
				{
					position257, tokenIndex257 := position, tokenIndex
					if buffer[position] != rune('.') {
						goto l257
					}
					position++
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l257
					}
					position++
				l259:
					{
						position260, tokenIndex260 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l260
						}
						position++
						goto l259
					l260:
						position, tokenIndex = position260, tokenIndex260
					}
					goto l258
				l257:
					position, tokenIndex = position257, tokenIndex257
				}
			l258:
				if !_rules[rule_]() {
					goto l251
				}
				add(ruleNumber, position252)
			}
			return true
		l251:
			position, tokenIndex = position251, tokenIndex251
			return false
		},
		/* 50 Boolean <- <((('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e')) _)> */
		func() bool {
			position261, tokenIndex261 := position, tokenIndex
			{
				position262 := position
				{
					position263, tokenIndex263 := position, tokenIndex
					if buffer[position] != rune('t') {
						goto l264
					}
					position++
					if buffer[position] != rune('r') {
						goto l264
					}
					position++
					if buffer[position] != rune('u') {
						goto l264
					}
					position++
					if buffer[position] != rune('e') {
						goto l264
					}
					position++
					goto l263
				l264:
					position, tokenIndex = position263, tokenIndex263
					if buffer[position] != rune('f') {
						goto l261
					}
					position++
					if buffer[position] != rune('a') {
						goto l261
					}
					position++
					if buffer[position] != rune('l') {
						goto l261
					}
					position++
					if buffer[position] != rune('s') {
						goto l261
					}
					position++
					if buffer[position] != rune('e') {
						goto l261
					}
					position++
				}
			l263:
				if !_rules[rule_]() {
					goto l261
				}
				add(ruleBoolean, position262)
			}
			return true
		l261:
			position, tokenIndex = position261, tokenIndex261
			return false
		},
		/* 51 LBRACE <- <('{' _)> */
		func() bool {
			position265, tokenIndex265 := position, tokenIndex
			{
				position266 := position
				if buffer[position] != rune('{') {
					goto l265
				}
				position++
				if !_rules[rule_]() {
					goto l265
				}
				add(ruleLBRACE, position266)
			}
			return true
		l265:
			position, tokenIndex = position265, tokenIndex265
			return false
		},
		/* 52 RBRACE <- <('}' _)> */
		func() bool {
			position267, tokenIndex267 := position, tokenIndex
			{
				position268 := position
				if buffer[position] != rune('}') {
					goto l267
				}
				position++
				if !_rules[rule_]() {
					goto l267
				}
				add(ruleRBRACE, position268)
			}
			return true
		l267:
			position, tokenIndex = position267, tokenIndex267
			return false
		},
		/* 53 LBRACKET <- <('[' _)> */
		func() bool {
			position269, tokenIndex269 := position, tokenIndex
			{
				position270 := position
				if buffer[position] != rune('[') {
					goto l269
				}
				position++
				if !_rules[rule_]() {
					goto l269
				}
				add(ruleLBRACKET, position270)
			}
			return true
		l269:
			position, tokenIndex = position269, tokenIndex269
			return false
		},
		/* 54 RBRACKET <- <(']' _)> */
		func() bool {
			position271, tokenIndex271 := position, tokenIndex
			{
				position272 := position
				if buffer[position] != rune(']') {
					goto l271
				}
				position++
				if !_rules[rule_]() {
					goto l271
				}
				add(ruleRBRACKET, position272)
			}
			return true
		l271:
			position, tokenIndex = position271, tokenIndex271
			return false
		},
		/* 55 LPAREN <- <('(' _)> */
		func() bool {
			position273, tokenIndex273 := position, tokenIndex
			{
				position274 := position
				if buffer[position] != rune('(') {
					goto l273
				}
				position++
				if !_rules[rule_]() {
					goto l273
				}
				add(ruleLPAREN, position274)
			}
			return true
		l273:
			position, tokenIndex = position273, tokenIndex273
			return false
		},
		/* 56 RPAREN <- <(')' _)> */
		func() bool {
			position275, tokenIndex275 := position, tokenIndex
			{
				position276 := position
				if buffer[position] != rune(')') {
					goto l275
				}
				position++
				if !_rules[rule_]() {
					goto l275
				}
				add(ruleRPAREN, position276)
			}
			return true
		l275:
			position, tokenIndex = position275, tokenIndex275
			return false
		},
		/* 57 COMMA <- <(',' _)> */
		func() bool {
			position277, tokenIndex277 := position, tokenIndex
			{
				position278 := position
				if buffer[position] != rune(',') {
					goto l277
				}
				position++
				if !_rules[rule_]() {
					goto l277
				}
				add(ruleCOMMA, position278)
			}
			return true
		l277:
			position, tokenIndex = position277, tokenIndex277
			return false
		},
		/* 58 COLON <- <(':' _)> */
		func() bool {
			position279, tokenIndex279 := position, tokenIndex
			{
				position280 := position
				if buffer[position] != rune(':') {
					goto l279
				}
				position++
				if !_rules[rule_]() {
					goto l279
				}
				add(ruleCOLON, position280)
			}
			return true
		l279:
			position, tokenIndex = position279, tokenIndex279
			return false
		},
		/* 59 SEMICOLON <- <(';' _)> */
		nil,
		/* 60 EQUALS <- <('=' _)> */
		func() bool {
			position282, tokenIndex282 := position, tokenIndex
			{
				position283 := position
				if buffer[position] != rune('=') {
					goto l282
				}
				position++
				if !_rules[rule_]() {
					goto l282
				}
				add(ruleEQUALS, position283)
			}
			return true
		l282:
			position, tokenIndex = position282, tokenIndex282
			return false
		},
		/* 61 PIPE <- <('|' _)> */
		func() bool {
			position284, tokenIndex284 := position, tokenIndex
			{
				position285 := position
				if buffer[position] != rune('|') {
					goto l284
				}
				position++
				if !_rules[rule_]() {
					goto l284
				}
				add(rulePIPE, position285)
			}
			return true
		l284:
			position, tokenIndex = position284, tokenIndex284
			return false
		},
		/* 62 DOT <- <('.' _)> */
		nil,
		/* 63 SPREAD <- <('.' '.' '.' _)> */
		func() bool {
			position287, tokenIndex287 := position, tokenIndex
			{
				position288 := position
				if buffer[position] != rune('.') {
					goto l287
				}
				position++
				if buffer[position] != rune('.') {
					goto l287
				}
				position++
				if buffer[position] != rune('.') {
					goto l287
				}
				position++
				if !_rules[rule_]() {
					goto l287
				}
				add(ruleSPREAD, position288)
			}
			return true
		l287:
			position, tokenIndex = position287, tokenIndex287
			return false
		},
		/* 64 AT <- <('@' _)> */
		func() bool {
			position289, tokenIndex289 := position, tokenIndex
			{
				position290 := position
				if buffer[position] != rune('@') {
					goto l289
				}
				position++
				if !_rules[rule_]() {
					goto l289
				}
				add(ruleAT, position290)
			}
			return true
		l289:
			position, tokenIndex = position289, tokenIndex289
			return false
		},
		/* 65 DoubleColon <- <(':' ':' _)> */
		func() bool {
			position291, tokenIndex291 := position, tokenIndex
			{
				position292 := position
				if buffer[position] != rune(':') {
					goto l291
				}
				position++
				if buffer[position] != rune(':') {
					goto l291
				}
				position++
				if !_rules[rule_]() {
					goto l291
				}
				add(ruleDoubleColon, position292)
			}
			return true
		l291:
			position, tokenIndex = position291, tokenIndex291
			return false
		},
		/* 66 SingleColon <- <(':' _)> */
		func() bool {
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				if buffer[position] != rune(':') {
					goto l293
				}
				position++
				if !_rules[rule_]() {
					goto l293
				}
				add(ruleSingleColon, position294)
			}
			return true
		l293:
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 67 _ <- <(' ' / '\t' / '\r' / '\n' / Comment / DocComment)*> */
		func() bool {
			{
				position296 := position
			l297:
				{
					position298, tokenIndex298 := position, tokenIndex
					{
						position299, tokenIndex299 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l300
						}
						position++
						goto l299
					l300:
						position, tokenIndex = position299, tokenIndex299
						if buffer[position] != rune('\t') {
							goto l301
						}
						position++
						goto l299
					l301:
						position, tokenIndex = position299, tokenIndex299
						if buffer[position] != rune('\r') {
							goto l302
						}
						position++
						goto l299
					l302:
						position, tokenIndex = position299, tokenIndex299
						if buffer[position] != rune('\n') {
							goto l303
						}
						position++
						goto l299
					l303:
						position, tokenIndex = position299, tokenIndex299
						if !_rules[ruleComment]() {
							goto l304
						}
						goto l299
					l304:
						position, tokenIndex = position299, tokenIndex299
						if !_rules[ruleDocComment]() {
							goto l298
						}
					}
				l299:
					goto l297
				l298:
					position, tokenIndex = position298, tokenIndex298
				}
				add(rule_, position296)
			}
			return true
		},
		/* 68 EOL <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			position305, tokenIndex305 := position, tokenIndex
			{
				position306 := position
				{
					position307, tokenIndex307 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l308
					}
					position++
					if buffer[position] != rune('\n') {
						goto l308
					}
					position++
					goto l307
				l308:
					position, tokenIndex = position307, tokenIndex307
					if buffer[position] != rune('\n') {
						goto l309
					}
					position++
					goto l307
				l309:
					position, tokenIndex = position307, tokenIndex307
					if buffer[position] != rune('\r') {
						goto l305
					}
					position++
				}
			l307:
				add(ruleEOL, position306)
			}
			return true
		l305:
			position, tokenIndex = position305, tokenIndex305
			return false
		},
	}
	p.rules = _rules
	return nil
}
